name,file,docstring,content,start_line,end_line
to_param,/Users/bytedance/test_repo/git/neo4j-python-driver/testkitbackend/fromtestkit.py,"Converts testkit parameter format to driver (python) parameter
    ","def to_param(m):
    """""" Converts testkit parameter format to driver (python) parameter
    """"""
    data = m[""data""]
    name = m[""name""]
    if name == ""CypherNull"":
        if data[""value""] is not None:
            raise ValueError(""CypherNull should be None"")
        return None
    if name == ""CypherString"":
        return str(data[""value""])
    if name == ""CypherBool"":
        return bool(data[""value""])
    if name == ""CypherInt"":
        return int(data[""value""])
    if name == ""CypherFloat"":
        return float(data[""value""])
    if name == ""CypherString"":
        return str(data[""value""])
    if name == ""CypherBytes"":
        return bytearray([int(byte, 16) for byte in data[""value""].split()])
    if name == ""CypherList"":
        return [to_param(v) for v in data[""value""]]
    if name == ""CypherMap"":
        return {k: to_param(data[""value""][k]) for k in data[""value""]}
    if name == ""CypherPoint"":
        coords = [data[""x""], data[""y""]]
        if data.get(""z"") is not None:
            coords.append(data[""z""])
        if data[""system""] == ""cartesian"":
            return CartesianPoint(coords)
        if data[""system""] == ""wgs84"":
            return WGS84Point(coords)
        raise ValueError(""Unknown point system: {}"".format(data[""system""]))
    if name == ""CypherDate"":
        return Date(data[""year""], data[""month""], data[""day""])
    if name == ""CypherTime"":
        tz = None
        utc_offset_s = data.get(""utc_offset_s"")
        if utc_offset_s is not None:
            utc_offset_m = utc_offset_s // 60
            if utc_offset_m * 60 != utc_offset_s:
                raise ValueError(""the used timezone library only supports ""
                                 ""UTC offsets by minutes"")
            tz = pytz.FixedOffset(utc_offset_m)
        return Time(data[""hour""], data[""minute""], data[""second""],
                    data[""nanosecond""], tzinfo=tz)
    if name == ""CypherDateTime"":
        datetime = DateTime(
            data[""year""], data[""month""], data[""day""],
            data[""hour""], data[""minute""], data[""second""], data[""nanosecond""]
        )
        utc_offset_s = data[""utc_offset_s""]
        timezone_id = data[""timezone_id""]
        if timezone_id is not None:
            utc_offset = timedelta(seconds=utc_offset_s)
            tz = pytz.timezone(timezone_id)
            localized_datetime = tz.localize(datetime, is_dst=False)
            if localized_datetime.utcoffset() == utc_offset:
                return localized_datetime
            localized_datetime = tz.localize(datetime, is_dst=True)
            if localized_datetime.utcoffset() == utc_offset:
                return localized_datetime
            raise ValueError(
                ""cannot localize datetime %s to timezone %s with UTC ""
                ""offset %s"" % (datetime, timezone_id, utc_offset)
            )
        elif utc_offset_s is not None:
            utc_offset_m = utc_offset_s // 60
            if utc_offset_m * 60 != utc_offset_s:
                raise ValueError(""the used timezone library only supports ""
                                 ""UTC offsets by minutes"")
            tz = pytz.FixedOffset(utc_offset_m)
            return tz.localize(datetime)
        return datetime
    if name == ""CypherDuration"":
        return Duration(
            months=data[""months""], days=data[""days""],
            seconds=data[""seconds""], nanoseconds=data[""nanoseconds""]
        )
    raise ValueError(""Unknown param type "" + name)",82,162
process_request,/Users/bytedance/test_repo/git/neo4j-python-driver/testkitbackend/_sync/backend.py,"Reads next request from the stream and processes it.
        ","def process_request(self):
        """""" Reads next request from the stream and processes it.
        """"""
        in_request = False
        request = """"
        for line in self._rd:
            # Remove trailing newline
            line = line.decode('UTF-8').rstrip()
            if line == ""#request begin"":
                in_request = True
            elif line == ""#request end"":
                self._process(request)
                return True
            else:
                if in_request:
                    request = request + line
        return False",102,118
send_response,/Users/bytedance/test_repo/git/neo4j-python-driver/testkitbackend/_sync/backend.py,"Sends a response to backend.
        ","def send_response(self, name, data):
        """""" Sends a response to backend.
        """"""
        with buffer_handler.lock:
            log_output = buffer_handler.stream.getvalue()
            buffer_handler.stream.truncate(0)
            buffer_handler.stream.seek(0)
        if not log_output.endswith(""\n""):
            log_output += ""\n""
        self._wr.write(log_output.encode(""utf-8""))
        response = {""name"": name, ""data"": data}
        response = dumps(response)
        self._wr.write(b""#response begin\n"")
        self._wr.write(bytes(response + ""\n"", ""utf-8""))
        self._wr.write(b""#response end\n"")
        if isinstance(self._wr, asyncio.StreamWriter):
            self._wr.drain()
        else:
            self._wr.flush()
        log.info("">>> "" + name + dumps(data))",170,189
set_script,/Users/bytedance/test_repo/git/neo4j-python-driver/tests/unit/sync/fixtures/fake_connection.py,"Set a scripted sequence of callbacks.

:param callbacks: The callbacks. They should be a list of 2-tuples.
    `(""name_of_message"", {""callback_name"": arguments})`. E.g.,
    ```
    [
        (""run"", {""on_success"": ({},), ""on_summary"": None}),
        (""pull"", {
            ""on_records"": ([some_record],),
            ""on_success"": None,
            ""on_summary"": None,
        })
        # use any exception to throw it instead of calling handlers
        (""commit"", RuntimeError(""oh no!""))
    ]
    ```
    Note that arguments can be `None`. In this case, ScriptedConnection
    will make a guess on best-suited default arguments.","def set_script(self, callbacks):
            """"""Set a scripted sequence of callbacks.

            :param callbacks: The callbacks. They should be a list of 2-tuples.
                `(""name_of_message"", {""callback_name"": arguments})`. E.g.,
                ```
                [
                    (""run"", {""on_success"": ({},), ""on_summary"": None}),
                    (""pull"", {
                        ""on_records"": ([some_record],),
                        ""on_success"": None,
                        ""on_summary"": None,
                    })
                    # use any exception to throw it instead of calling handlers
                    (""commit"", RuntimeError(""oh no!""))
                ]
                ```
                Note that arguments can be `None`. In this case, ScriptedConnection
                will make a guess on best-suited default arguments.
            """"""
            self._script = callbacks
            self._script_pos = 0",147,168
set_script,/Users/bytedance/test_repo/git/neo4j-python-driver/tests/unit/async_/fixtures/fake_connection.py,"Set a scripted sequence of callbacks.

:param callbacks: The callbacks. They should be a list of 2-tuples.
    `(""name_of_message"", {""callback_name"": arguments})`. E.g.,
    ```
    [
        (""run"", {""on_success"": ({},), ""on_summary"": None}),
        (""pull"", {
            ""on_records"": ([some_record],),
            ""on_success"": None,
            ""on_summary"": None,
        })
        # use any exception to throw it instead of calling handlers
        (""commit"", RuntimeError(""oh no!""))
    ]
    ```
    Note that arguments can be `None`. In this case, ScriptedConnection
    will make a guess on best-suited default arguments.","def set_script(self, callbacks):
            """"""Set a scripted sequence of callbacks.

            :param callbacks: The callbacks. They should be a list of 2-tuples.
                `(""name_of_message"", {""callback_name"": arguments})`. E.g.,
                ```
                [
                    (""run"", {""on_success"": ({},), ""on_summary"": None}),
                    (""pull"", {
                        ""on_records"": ([some_record],),
                        ""on_success"": None,
                        ""on_summary"": None,
                    })
                    # use any exception to throw it instead of calling handlers
                    (""commit"", RuntimeError(""oh no!""))
                ]
                ```
                Note that arguments can be `None`. In this case, ScriptedConnection
                will make a guess on best-suited default arguments.
            """"""
            self._script = callbacks
            self._script_pos = 0",147,168
server_info,/Users/bytedance/test_repo/git/neo4j-python-driver/tests/integration/test_bolt_driver.py,"Simple fixture to provide quick and easy access to a
:class:`.ServerInfo` object.","def server_info(driver):
    """""" Simple fixture to provide quick and easy access to a
    :class:`.ServerInfo` object.
    """"""
    with driver.session() as session:
        summary = session.run(""RETURN 1"").consume()
        yield summary.server",21,27
__eq__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"In order to be flexible regarding comparison, the equality rules
for a record permit comparison with any other Sequence or Mapping.

:param other:
:returns:","def __eq__(self, other: object) -> bool:
        """""" In order to be flexible regarding comparison, the equality rules
        for a record permit comparison with any other Sequence or Mapping.

        :param other:
        :returns:
        """"""
        compare_as_sequence = isinstance(other, Sequence)
        compare_as_mapping = isinstance(other, Mapping)
        if compare_as_sequence and compare_as_mapping:
            other = t.cast(t.Mapping, other)
            return list(self) == list(other) and dict(self) == dict(other)
        elif compare_as_sequence:
            other = t.cast(t.Sequence, other)
            return list(self) == list(other)
        elif compare_as_mapping:
            other = t.cast(t.Mapping, other)
            return dict(self) == dict(other)
        else:
            return False",94,113
get,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Obtain a value from the record by key, returning a default
value if the key does not exist.

:param key: a key
:param default: default value

:returns: a value","def get(self, key: str, default: t.Optional[object] = None) -> t.Any:
        """""" Obtain a value from the record by key, returning a default
        value if the key does not exist.

        :param key: a key
        :param default: default value

        :returns: a value
        """"""
        try:
            index = self.__keys.index(str(key))
        except ValueError:
            return default
        if 0 <= index < len(self):
            return self._super_getitem_single(index)
        else:
            return default",149,165
index,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Return the index of the given item.

:param key: a key

:returns: index","def index(self, key: _K) -> int:  # type: ignore[override]
        """""" Return the index of the given item.

        :param key: a key

        :returns: index
        """"""
        if isinstance(key, int):
            if 0 <= key < len(self.__keys):
                return key
            raise IndexError(key)
        elif isinstance(key, str):
            try:
                return self.__keys.index(key)
            except ValueError as exc:
                raise KeyError(key) from exc
        else:
            raise TypeError(key)",167,184
value,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Obtain a single value from the record by index or key. If no
index or key is specified, the first value is returned. If the
specified item does not exist, the default value is returned.

:param key: an index or key
:param default: default value

:returns: a single value","def value(
        self, key: _K = 0, default: t.Optional[object] = None
    ) -> t.Any:
        """""" Obtain a single value from the record by index or key. If no
        index or key is specified, the first value is returned. If the
        specified item does not exist, the default value is returned.

        :param key: an index or key
        :param default: default value

        :returns: a single value
        """"""
        try:
            index = self.index(key)
        except (IndexError, KeyError):
            return default
        else:
            return self[index]",186,203
keys,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Return the keys of the record.

:returns: list of key names","def keys(self) -> t.List[str]:  # type: ignore[override]
        """""" Return the keys of the record.

        :returns: list of key names
        """"""
        return list(self.__keys)",205,210
values,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Return the values of the record, optionally filtering to
include only certain values by index or key.

:param keys: indexes or keys of the items to include; if none
             are provided, all values will be included

:returns: list of values","def values(self, *keys: _K) -> t.List[t.Any]:  # type: ignore[override]
        """""" Return the values of the record, optionally filtering to
        include only certain values by index or key.

        :param keys: indexes or keys of the items to include; if none
                     are provided, all values will be included

        :returns: list of values
        """"""
        if keys:
            d: t.List[t.Any] = []
            for key in keys:
                try:
                    i = self.index(key)
                except KeyError:
                    d.append(None)
                else:
                    d.append(self[i])
            return d
        return list(self)",212,231
items,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Return the fields of the record as a list of key and value tuples

:returns: a list of value tuples","def items(self, *keys):
        """""" Return the fields of the record as a list of key and value tuples

        :returns: a list of value tuples
        """"""
        if keys:
            d = []
            for key in keys:
                try:
                    i = self.index(key)
                except KeyError:
                    d.append((key, None))
                else:
                    d.append((self.__keys[i], self[i]))
            return d
        return list((self.__keys[i], self._super_getitem_single(i))
                    for i in range(len(self)))",233,249
data,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Return the record as a dictionary.

Return the keys and values of this record as a dictionary, optionally
including only certain values by index or key.
Keys provided in the items that are not in the record will be inserted
with a value of :data:`None`; indexes provided that are out of bounds
will trigger an :exc:`IndexError`.

This function provides a convenient but opinionated way to transform
the record into a mostly JSON serializable format. It is mainly useful
for interactive sessions and rapid prototyping.

The transformation works as follows:

 * Nodes are transformed into dictionaries of their
   properties.

   * No indication of their original type remains.
   * Not all information is serialized (e.g., labels and element_id are
     absent).

 * Relationships are transformed to a tuple of
   ``(start_node, type, end_node)``, where the nodes are transformed
   as described above, and type is the relationship type name
   (:class:`str`).

   * No indication of their original type remains.
   * No other information (properties, element_id, start_node,
     end_node, ...) is serialized.

 * Paths are transformed into lists of nodes and relationships. No
   indication of the original type remains.
 * :class:`list` and :class:`dict` values are recursively transformed.
 * Every other type remains unchanged.

   * Spatial types and durations inherit from :class:`tuple`. Hence,
     they are JSON serializable, but, like graph types, type
     information will be lost in the process.
   * The remaining temporal types are not JSON serializable.

You will have to implement a custom serializer should you need more
control over the output format.

:param keys: Indexes or keys of the items to include. If none are
    provided, all values will be included.

:returns: dictionary of values, keyed by field name

:raises: :exc:`IndexError` if an out-of-bounds index is specified.","def data(self, *keys: _K) -> t.Dict[str, t.Any]:
        """"""Return the record as a dictionary.

        Return the keys and values of this record as a dictionary, optionally
        including only certain values by index or key.
        Keys provided in the items that are not in the record will be inserted
        with a value of :data:`None`; indexes provided that are out of bounds
        will trigger an :exc:`IndexError`.

        This function provides a convenient but opinionated way to transform
        the record into a mostly JSON serializable format. It is mainly useful
        for interactive sessions and rapid prototyping.

        The transformation works as follows:

         * Nodes are transformed into dictionaries of their
           properties.

           * No indication of their original type remains.
           * Not all information is serialized (e.g., labels and element_id are
             absent).

         * Relationships are transformed to a tuple of
           ``(start_node, type, end_node)``, where the nodes are transformed
           as described above, and type is the relationship type name
           (:class:`str`).

           * No indication of their original type remains.
           * No other information (properties, element_id, start_node,
             end_node, ...) is serialized.

         * Paths are transformed into lists of nodes and relationships. No
           indication of the original type remains.
         * :class:`list` and :class:`dict` values are recursively transformed.
         * Every other type remains unchanged.

           * Spatial types and durations inherit from :class:`tuple`. Hence,
             they are JSON serializable, but, like graph types, type
             information will be lost in the process.
           * The remaining temporal types are not JSON serializable.

        You will have to implement a custom serializer should you need more
        control over the output format.

        :param keys: Indexes or keys of the items to include. If none are
            provided, all values will be included.

        :returns: dictionary of values, keyed by field name

        :raises: :exc:`IndexError` if an out-of-bounds index is specified.
        """"""
        return RecordExporter().transform(dict(self.items(*keys)))",251,302
transform,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_data.py,"Transform a value, or collection of values.

:param x: input value
:returns: output value","def transform(self, x):
        """""" Transform a value, or collection of values.

        :param x: input value
        :returns: output value
        """"""",311,316
get_user_agent,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_meta.py,"Obtain the default user agent string sent to the server after
a successful handshake.","def get_user_agent():
    """""" Obtain the default user agent string sent to the server after
    a successful handshake.
    """"""
    return USER_AGENT",78,82
deprecated,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_meta.py,"Decorator for deprecating functions and methods.

::

    @deprecated(""'foo' has been deprecated in favour of 'bar'"")
    def foo(x):
        pass","def deprecated(message: str) -> t.Callable[[_FuncT], _FuncT]:
    """""" Decorator for deprecating functions and methods.

    ::

        @deprecated(""'foo' has been deprecated in favour of 'bar'"")
        def foo(x):
            pass

    """"""
    return _make_warning_decorator(message, deprecation_warn)",100,110
experimental,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_meta.py,"Decorator for tagging experimental functions and methods.

::

    @experimental(""'foo' is an experimental function and may be ""
                  ""removed in a future release"")
    def foo(x):
        pass

.. deprecated:: 5.8
    we now use ""preview"" instead of ""experimental"".","def experimental(message) -> t.Callable[[_FuncT], _FuncT]:
    """""" Decorator for tagging experimental functions and methods.

    ::

        @experimental(""'foo' is an experimental function and may be ""
                      ""removed in a future release"")
        def foo(x):
            pass

    .. deprecated:: 5.8
        we now use ""preview"" instead of ""experimental"".
    """"""
    return _make_warning_decorator(message, experimental_warn)",132,145
preview,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_meta.py,"Decorator for tagging preview functions and methods.

    @preview(""foo is a preview."")
    def foo(x):
        pass","def preview(message) -> t.Callable[[_FuncT], _FuncT]:
    """"""
    Decorator for tagging preview functions and methods.

        @preview(""foo is a preview."")
        def foo(x):
            pass
    """"""
    return _make_warning_decorator(message, preview_warn)",165,173
basic_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Generate a basic auth token for a given user and password.

This will set the scheme to ""basic"" for the auth token.

:param user: user name, this will set the
:param password: current password, this will set the credentials
:param realm: specifies the authentication provider

:returns: auth token for use with :meth:`GraphDatabase.driver` or
    :meth:`AsyncGraphDatabase.driver`","def basic_auth(
    user: str, password: str, realm: t.Optional[str] = None
) -> Auth:
    """"""Generate a basic auth token for a given user and password.

    This will set the scheme to ""basic"" for the auth token.

    :param user: user name, this will set the
    :param password: current password, this will set the credentials
    :param realm: specifies the authentication provider

    :returns: auth token for use with :meth:`GraphDatabase.driver` or
        :meth:`AsyncGraphDatabase.driver`
    """"""
    return Auth(""basic"", user, password, realm)",124,138
kerberos_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Generate a kerberos auth token with the base64 encoded ticket.

This will set the scheme to ""kerberos"" for the auth token.

:param base64_encoded_ticket: a base64 encoded service ticket, this will set
                              the credentials

:returns: auth token for use with :meth:`GraphDatabase.driver` or
    :meth:`AsyncGraphDatabase.driver`","def kerberos_auth(base64_encoded_ticket: str) -> Auth:
    """"""Generate a kerberos auth token with the base64 encoded ticket.

    This will set the scheme to ""kerberos"" for the auth token.

    :param base64_encoded_ticket: a base64 encoded service ticket, this will set
                                  the credentials

    :returns: auth token for use with :meth:`GraphDatabase.driver` or
        :meth:`AsyncGraphDatabase.driver`
    """"""
    return Auth(""kerberos"", """", base64_encoded_ticket)",141,152
bearer_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Generate an auth token for Single-Sign-On providers.

This will set the scheme to ""bearer"" for the auth token.

:param base64_encoded_token: a base64 encoded authentication token generated
                             by a Single-Sign-On provider.

:returns: auth token for use with :meth:`GraphDatabase.driver` or
    :meth:`AsyncGraphDatabase.driver`","def bearer_auth(base64_encoded_token: str) -> Auth:
    """"""Generate an auth token for Single-Sign-On providers.

    This will set the scheme to ""bearer"" for the auth token.

    :param base64_encoded_token: a base64 encoded authentication token generated
                                 by a Single-Sign-On provider.

    :returns: auth token for use with :meth:`GraphDatabase.driver` or
        :meth:`AsyncGraphDatabase.driver`
    """"""
    return Auth(""bearer"", None, base64_encoded_token)",155,166
custom_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Generate a custom auth token.

:param principal: specifies who is being authenticated
:param credentials: authenticates the principal
:param realm: specifies the authentication provider
:param scheme: specifies the type of authentication
:param parameters: extra key word parameters passed along to the
                   authentication provider

:returns: auth token for use with :meth:`GraphDatabase.driver` or
    :meth:`AsyncGraphDatabase.driver`","def custom_auth(
    principal: t.Optional[str],
    credentials: t.Optional[str],
    realm: t.Optional[str],
    scheme: t.Optional[str],
    **parameters: t.Any
) -> Auth:
    """"""Generate a custom auth token.

    :param principal: specifies who is being authenticated
    :param credentials: authenticates the principal
    :param realm: specifies the authentication provider
    :param scheme: specifies the type of authentication
    :param parameters: extra key word parameters passed along to the
                       authentication provider

    :returns: auth token for use with :meth:`GraphDatabase.driver` or
        :meth:`AsyncGraphDatabase.driver`
    """"""
    return Auth(scheme, principal, credentials, realm, **parameters)",169,188
parse_routing_context,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Parse the query portion of a URI to generate a routing context dictionary.
    ","def parse_routing_context(query):
    """""" Parse the query portion of a URI to generate a routing context dictionary.
    """"""
    if not query:
        return {}

    context = {}
    parameters = parse_qs(query, True)
    for key in parameters:
        value_list = parameters[key]
        if len(value_list) != 1:
            raise ConfigurationError(""Duplicated query parameters with key '%s', value '%s' found in query string '%s'"" % (key, value_list, query))
        value = value_list[0]
        if not value:
            raise ConfigurationError(""Invalid parameters:'%s=%s' in query string '%s'."" % (key, value, query))
        context[key] = value

    return context",534,551
__repr__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,:returns: repr string with sorted values,"def __repr__(self) -> str:
        """"""
        :returns: repr string with sorted values
        """"""
        return ""<Bookmark values={{{}}}>"".format("", "".join([""'{}'"".format(ix) for ix in sorted(self._values)]))",216,220
values,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,:returns: immutable list of bookmark string values,"def values(self) -> frozenset:
        """"""
        :returns: immutable list of bookmark string values
        """"""
        return self._values",226,230
__repr__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,:returns: repr string with sorted values,"def __repr__(self) -> str:
        """"""
        :returns: repr string with sorted values
        """"""
        return ""<Bookmarks values={{{}}}>"".format(
            "", "".join(map(repr, sorted(self._raw_values)))
        )",248,254
__bool__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,True if there are bookmarks in the container.,"def __bool__(self) -> bool:
        """"""True if there are bookmarks in the container.""""""
        return bool(self._raw_values)",256,258
__add__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,Add multiple containers together.,"def __add__(self, other: Bookmarks) -> Bookmarks:
        """"""Add multiple containers together.""""""
        if isinstance(other, Bookmarks):
            if not other:
                return self
            ret = self.__class__()
            ret._raw_values = self._raw_values | other._raw_values
            return ret
        return NotImplemented",260,268
raw_values,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"The raw bookmark values.

You should not need to access them unless you want to serialize
bookmarks.

:returns: immutable list of bookmark string values
:rtype: frozenset[str]","def raw_values(self) -> t.FrozenSet[str]:
        """"""The raw bookmark values.

        You should not need to access them unless you want to serialize
        bookmarks.

        :returns: immutable list of bookmark string values
        :rtype: frozenset[str]
        """"""
        return self._raw_values",271,280
from_raw_values,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Create a Bookmarks object from a list of raw bookmark string values.

You should not need to use this method unless you want to deserialize
bookmarks.

:param values: ASCII string values (raw bookmarks)
:type values: Iterable[str]","def from_raw_values(cls, values: t.Iterable[str]) -> Bookmarks:
        """"""Create a Bookmarks object from a list of raw bookmark string values.

        You should not need to use this method unless you want to deserialize
        bookmarks.

        :param values: ASCII string values (raw bookmarks)
        :type values: Iterable[str]
        """"""
        obj = cls()
        bookmarks = []
        for value in values:
            if not isinstance(value, str):
                raise TypeError(""Raw bookmark values must be str. ""
                                ""Found {}"".format(type(value)))
            try:
                value.encode(""ascii"")
            except UnicodeEncodeError as e:
                raise ValueError(f""The value {value} is not ASCII"") from e
            bookmarks.append(value)
        obj._raw_values = frozenset(bookmarks)
        return obj",283,304
address,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Network address of the remote server.
        ","def address(self) -> Address:
        """""" Network address of the remote server.
        """"""
        return self._address",317,320
protocol_version,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Bolt protocol version with which the remote server
communicates. This is returned as a 2-tuple:class:`tuple` (subclass) of
``(major, minor)`` integers.","def protocol_version(self) -> t.Tuple[int, int]:
        """""" Bolt protocol version with which the remote server
        communicates. This is returned as a 2-tuple:class:`tuple` (subclass) of
        ``(major, minor)`` integers.
        """"""
        return self._protocol_version",323,328
agent,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Server agent string by which the remote server identifies
itself.","def agent(self) -> str:
        """""" Server agent string by which the remote server identifies
        itself.
        """"""
        return str(self._metadata.get(""server""))",331,335
connection_id,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Unique identifier for the remote server connection.
        ","def connection_id(self):
        """""" Unique identifier for the remote server connection.
        """"""
        return self._metadata.get(""connection_id"")",340,343
update,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Update server information with extra metadata. This is
typically drawn from the metadata received after successful
connection initialisation.","def update(self, metadata: dict) -> None:
        """""" Update server information with extra metadata. This is
        typically drawn from the metadata received after successful
        connection initialisation.
        """"""
        self._metadata.update(metadata)",345,350
update_bookmarks,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Handle bookmark updates.

:param previous_bookmarks:
    The bookmarks used at the start of a transaction
:param new_bookmarks:
    The new bookmarks retrieved at the end of a transaction","def update_bookmarks(
        self, previous_bookmarks: t.Collection[str],
        new_bookmarks: t.Collection[str]
    ) -> None:
        """"""Handle bookmark updates.

        :param previous_bookmarks:
            The bookmarks used at the start of a transaction
        :param new_bookmarks:
            The new bookmarks retrieved at the end of a transaction
        """"""
        ...",427,438
get_bookmarks,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/api.py,"Return the bookmarks stored in the bookmark manager.

:returns: The bookmarks for the given database","def get_bookmarks(self) -> t.Collection[str]:
        """"""Return the bookmarks stored in the bookmark manager.

        :returns: The bookmarks for the given database
        """"""
        ...",441,446
expires_in,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_auth_management.py,"Return a (flat) copy of this object with a new expiration time.

This is a convenience method for creating an :class:`.ExpiringAuth`
for a relative expiration time (""expires in"" instead of ""expires at"").

    >>> import time, freezegun
    >>> with freezegun.freeze_time(""1970-01-01 00:00:40""):
    ...     ExpiringAuth((""user"", ""pass"")).expires_in(2)
    ExpiringAuth(auth=('user', 'pass'), expires_at=42.0)
    >>> with freezegun.freeze_time(""1970-01-01 00:00:40""):
    ...     ExpiringAuth((""user"", ""pass""), time.time() + 2)
    ExpiringAuth(auth=('user', 'pass'), expires_at=42.0)

:param seconds:
    The number of seconds from now until the authentication information
    expires.

.. versionadded:: 5.9","def expires_in(self, seconds: float) -> ExpiringAuth:
        """"""Return a (flat) copy of this object with a new expiration time.

        This is a convenience method for creating an :class:`.ExpiringAuth`
        for a relative expiration time (""expires in"" instead of ""expires at"").

            >>> import time, freezegun
            >>> with freezegun.freeze_time(""1970-01-01 00:00:40""):
            ...     ExpiringAuth((""user"", ""pass"")).expires_in(2)
            ExpiringAuth(auth=('user', 'pass'), expires_at=42.0)
            >>> with freezegun.freeze_time(""1970-01-01 00:00:40""):
            ...     ExpiringAuth((""user"", ""pass""), time.time() + 2)
            ExpiringAuth(auth=('user', 'pass'), expires_at=42.0)

        :param seconds:
            The number of seconds from now until the authentication information
            expires.

        .. versionadded:: 5.9
        """"""
        return ExpiringAuth(self.auth, time.time() + seconds)",70,90
get_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_auth_management.py,"Return the current authentication information.

The driver will call this method very frequently. It is recommended
to implement some form of caching to avoid unnecessary overhead.

.. warning::

    The method must only ever return auth information belonging to the
    same identity.
    Switching identities using the `AuthManager` is undefined behavior.
    You may use :ref:`session-level authentication<session-auth-ref>`
    for such use-cases.","def get_auth(self) -> _TAuth:
        """"""Return the current authentication information.

        The driver will call this method very frequently. It is recommended
        to implement some form of caching to avoid unnecessary overhead.

        .. warning::

            The method must only ever return auth information belonging to the
            same identity.
            Switching identities using the `AuthManager` is undefined behavior.
            You may use :ref:`session-level authentication<session-auth-ref>`
            for such use-cases.
        """"""
        ...",134,148
handle_security_exception,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_auth_management.py,"Handle the server indicating authentication failure.

The driver will call this method when the server returns any
`Neo.ClientError.Security.*` error. The error will then be processed
further as usual.

:param auth:
    The authentication information that was used when the server
    returned the error.
:param error:
    The error returned by the server.

:returns:
    Whether the error was handled (:data:`True`), in which case the
    driver will mark the error as retryable
    (see :meth:`.Neo4jError.is_retryable`).

.. versionadded:: 5.12","def handle_security_exception(
        self, auth: _TAuth, error: Neo4jError
    ) -> bool:
        """"""Handle the server indicating authentication failure.

        The driver will call this method when the server returns any
        `Neo.ClientError.Security.*` error. The error will then be processed
        further as usual.

        :param auth:
            The authentication information that was used when the server
            returned the error.
        :param error:
            The error returned by the server.

        :returns:
            Whether the error was handled (:data:`True`), in which case the
            driver will mark the error as retryable
            (see :meth:`.Neo4jError.is_retryable`).

        .. versionadded:: 5.12
        """"""
        ...",151,173
get_certificate,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_auth_management.py,"Return the new certificate (if present) to use for new connections.

If no new certificate is available, return :data:`None`.
This will make the driver continue using the current certificate.

Note that a new certificate will only be used for new connections.
Already established connections will continue using the old
certificate as TLS is established during connection setup.

:returns: The new certificate to use for new connections.","def get_certificate(self) -> t.Optional[ClientCertificate]:
        """"""
        Return the new certificate (if present) to use for new connections.

        If no new certificate is available, return :data:`None`.
        This will make the driver continue using the current certificate.

        Note that a new certificate will only be used for new connections.
        Already established connections will continue using the old
        certificate as TLS is established during connection setup.

        :returns: The new certificate to use for new connections.
        """"""
        ...",269,282
watch,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/debug.py,"Quick wrapper for using  :class:`.Watcher`.

Create a Watcher with the given configuration, enable watching and return
it.

Example::

    from neo4j.debug import watch

    watch(""neo4j"")
    # from now on, DEBUG logging to stderr is enabled in the driver

.. note::
    The exact logging format and messages are not part of the API contract
    and might change at any time without notice. They are meant for
    debugging purposes and human consumption only.

:param logger_names: Names of loggers to watch.
:param level: see ``default_level`` of :class:`.Watcher`.
:param out: see ``default_out`` of :class:`.Watcher`.
:type out: stream or file-like object
:param colour: see ``colour`` of :class:`.Watcher`.
:param thread_info: see ``thread_info`` of :class:`.Watcher`.
:param task_info: see ``task_info`` of :class:`.Watcher`.

:returns: Watcher instance
:rtype: :class:`.Watcher`

.. versionchanged:: 5.3

    * Added ``thread_info`` and ``task_info`` parameters.
    * Logging format around thread and task information changed.","def watch(
    *logger_names: t.Optional[str],
    level: int = DEBUG,
    out: t.TextIO = stderr,
    colour: bool = False,
    thread_info: bool = True,
    task_info: bool = True,
) -> Watcher:
    """"""Quick wrapper for using  :class:`.Watcher`.

    Create a Watcher with the given configuration, enable watching and return
    it.

    Example::

        from neo4j.debug import watch

        watch(""neo4j"")
        # from now on, DEBUG logging to stderr is enabled in the driver

    .. note::
        The exact logging format and messages are not part of the API contract
        and might change at any time without notice. They are meant for
        debugging purposes and human consumption only.

    :param logger_names: Names of loggers to watch.
    :param level: see ``default_level`` of :class:`.Watcher`.
    :param out: see ``default_out`` of :class:`.Watcher`.
    :type out: stream or file-like object
    :param colour: see ``colour`` of :class:`.Watcher`.
    :param thread_info: see ``thread_info`` of :class:`.Watcher`.
    :param task_info: see ``task_info`` of :class:`.Watcher`.

    :returns: Watcher instance
    :rtype: :class:`.Watcher`

    .. versionchanged:: 5.3

        * Added ``thread_info`` and ``task_info`` parameters.
        * Logging format around thread and task information changed.
    """"""
    watcher = Watcher(*logger_names, default_level=level, default_out=out,
                      colour=colour, thread_info=thread_info,
                      task_info=task_info)
    watcher.watch()
    return watcher",185,230
__enter__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/debug.py,Enable logging for all loggers.,"def __enter__(self) -> Watcher:
        """"""Enable logging for all loggers.""""""
        self.watch()
        return self",140,143
__exit__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/debug.py,Disable logging for all loggers.,"def __exit__(self, exc_type, exc_val, exc_tb):
        """"""Disable logging for all loggers.""""""
        self.stop()",145,147
watch,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/debug.py,"Enable logging for all loggers.

:param level: Minimum log level to show.
    If :data:`None`, the ``default_level`` is used.
:param out: Output stream for all loggers.
    If :data:`None`, the ``default_out`` is used.
:type out: stream or file-like object","def watch(
        self, level: t.Optional[int] = None, out: t.Optional[t.TextIO] = None
    ) -> None:
        """"""Enable logging for all loggers.

        :param level: Minimum log level to show.
            If :data:`None`, the ``default_level`` is used.
        :param out: Output stream for all loggers.
            If :data:`None`, the ``default_out`` is used.
        :type out: stream or file-like object
        """"""
        if level is None:
            level = self.default_level
        if out is None:
            out = self.default_out
        self.stop()
        handler = StreamHandler(out)
        handler.setFormatter(self.formatter)
        handler.setLevel(level)
        if self._task_info:
            handler.addFilter(TaskIdFilter())
        for logger in self. _loggers:
            self._handlers[logger.name] = handler
            logger.addHandler(handler)
            if logger.getEffectiveLevel() > level:
                logger.setLevel(level)",149,174
stop,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/debug.py,Disable logging for all loggers.,"def stop(self) -> None:
        """"""Disable logging for all loggers.""""""
        for logger in self._loggers:
            try:
                logger.removeHandler(self._handlers.pop(logger.name))
            except KeyError:
                pass",176,182
parse_routing_info,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_routing.py,"Parse the records returned from the procedure call and
return a new RoutingTable instance.","def parse_routing_info(cls, *, database, servers, ttl):
        """""" Parse the records returned from the procedure call and
        return a new RoutingTable instance.
        """"""
        routers = []
        readers = []
        writers = []
        try:
            for server in servers:
                role = server[""role""]
                addresses = []
                for address in server[""addresses""]:
                    addresses.append(Address.parse(address, default_port=7687))
                if role == ""ROUTE"":
                    routers.extend(addresses)
                elif role == ""READ"":
                    readers.extend(addresses)
                elif role == ""WRITE"":
                    writers.extend(addresses)
        except (KeyError, TypeError) as exc:
            raise ValueError(""Cannot parse routing info"") from exc
        else:
            return cls(database=database, routers=routers, readers=readers, writers=writers, ttl=ttl)",79,101
is_fresh,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_routing.py,"Indicator for whether routing information is still usable.
        ","def is_fresh(self, readonly=False):
        """""" Indicator for whether routing information is still usable.
        """"""
        assert isinstance(readonly, bool)
        expired = self.last_updated_time + self.ttl <= monotonic()
        if readonly:
            has_server_for_mode = bool(self.readers)
        else:
            has_server_for_mode = bool(self.writers)
        res = not expired and self.routers and has_server_for_mode
        log.debug(""[#0000]  _: <ROUTING> checking table freshness ""
                  ""(readonly=%r): table expired=%r, ""
                  ""has_server_for_mode=%r, table routers=%r => %r"",
                  readonly, expired, has_server_for_mode, self.routers, res)
        return res",126,140
should_be_purged_from_memory,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_routing.py,"Check if the routing table is stale and not used for a long time and should be removed from memory.

:returns: Returns true if it is old and not used for a while.
:rtype: bool","def should_be_purged_from_memory(self):
        """""" Check if the routing table is stale and not used for a long time and should be removed from memory.

        :returns: Returns true if it is old and not used for a while.
        :rtype: bool
        """"""
        from ._conf import RoutingConfig
        perf_time = monotonic()
        res = self.last_updated_time + self.ttl + RoutingConfig.routing_table_purge_delay <= perf_time
        log.debug(""[#0000]  _: <ROUTING> purge check: ""
                  ""last_updated_time=%r, ttl=%r, perf_time=%r => %r"",
                  self.last_updated_time, self.ttl, perf_time, res)
        return res",142,154
update,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_routing.py,"Update the current routing table with new routing information
from a replacement table.","def update(self, new_routing_table):
        """""" Update the current routing table with new routing information
        from a replacement table.
        """"""
        self.routers.replace(new_routing_table.routers)
        self.readers.replace(new_routing_table.readers)
        self.writers.replace(new_routing_table.writers)
        self.initialized_without_writers = not self.writers
        self.last_updated_time = monotonic()
        self.ttl = new_routing_table.ttl
        log.debug(""[#0000]  _: <ROUTING> updated table=%r"", self)",156,166
iter_items,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_conf.py,"Iterate through all items (key-value pairs) within an iterable
dictionary-like object. If the object has a `keys` method, this is
used along with `__getitem__` to yield each pair in turn. If no
`keys` method exists, each iterable element is assumed to be a
2-tuple of key and value.","def iter_items(iterable):
    """""" Iterate through all items (key-value pairs) within an iterable
    dictionary-like object. If the object has a `keys` method, this is
    used along with `__getitem__` to yield each pair in turn. If no
    `keys` method exists, each iterable element is assumed to be a
    2-tuple of key and value.
    """"""
    if hasattr(iterable, ""keys""):
        for key in iterable.keys():
            yield key, iterable[key]
    else:
        for key, value in iterable:
            yield key, value",36,48
is_retriable,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/exceptions.py,"Whether the error is retryable.

See :meth:`.is_retryable`.

:returns: :data:`True` if the error is retryable,
    :data:`False` otherwise.

.. deprecated:: 5.0
    This method will be removed in a future version.
    Please use :meth:`.is_retryable` instead.","def is_retriable(self) -> bool:
        """"""Whether the error is retryable.

        See :meth:`.is_retryable`.

        :returns: :data:`True` if the error is retryable,
            :data:`False` otherwise.

        .. deprecated:: 5.0
            This method will be removed in a future version.
            Please use :meth:`.is_retryable` instead.
        """"""
        return self.is_retryable()",210,222
is_retryable,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/exceptions.py,"Whether the error is retryable.

Indicates whether a transaction that yielded this error makes sense to
retry. This method makes mostly sense when implementing a custom
retry policy in conjunction with :ref:`explicit-transactions-ref`.

:returns: :data:`True` if the error is retryable,
    :data:`False` otherwise.

.. versionadded:: 5.0","def is_retryable(self) -> bool:
        """"""Whether the error is retryable.

        Indicates whether a transaction that yielded this error makes sense to
        retry. This method makes mostly sense when implementing a custom
        retry policy in conjunction with :ref:`explicit-transactions-ref`.

        :returns: :data:`True` if the error is retryable,
            :data:`False` otherwise.

        .. versionadded:: 5.0
        """"""
        return self._retryable",224,236
is_retryable,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/exceptions.py,"Whether the error is retryable.

Indicates whether a transaction that yielded this error makes sense to
retry. This method makes mostly sense when implementing a custom
retry policy in conjunction with :ref:`explicit-transactions-ref`.

:returns: :data:`True` if the error is retryable,
    :data:`False` otherwise.

.. versionadded:: 5.0","def is_retryable(self) -> bool:
        """"""Whether the error is retryable.

        Indicates whether a transaction that yielded this error makes sense to
        retry. This method makes mostly sense when implementing a custom
        retry policy in conjunction with :ref:`explicit-transactions-ref`.

        :returns: :data:`True` if the error is retryable,
            :data:`False` otherwise.

        .. versionadded:: 5.0
        """"""
        return False",407,419
from_socket,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/addressing.py,"Create an address from a socket object.

Uses the socket's ``getpeername`` method to retrieve the remote
address the socket is connected to.","def from_socket(
        cls,
        socket: _WithPeerName
    ) -> Address:
        """"""Create an address from a socket object.

        Uses the socket's ``getpeername`` method to retrieve the remote
        address the socket is connected to.
        """"""
        address = socket.getpeername()
        return cls(address)",110,120
parse,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/addressing.py,"Parse a string into an address.

The string must be in the format ``host:port`` (IPv4) or
``[host]:port`` (IPv6).
If no port is specified, or is empty, ``default_port`` will be used.
If no host is specified, or is empty, ``default_host`` will be used.

    >>> Address.parse(""localhost:7687"")
    IPv4Address(('localhost', 7687))
    >>> Address.parse(""[::1]:7687"")
    IPv6Address(('::1', 7687, 0, 0))
    >>> Address.parse(""localhost"")
    IPv4Address(('localhost', 0))
    >>> Address.parse(""localhost"", default_port=1234)
    IPv4Address(('localhost', 1234))

:param s: The string to parse.
:param default_host: The default host to use if none is specified.
    :data:`None` indicates to use ``""localhost""`` as default.
:param default_port: The default port to use if none is specified.
    :data:`None` indicates to use ``0`` as default.

:returns: The parsed address.","def parse(
        cls,
        s: str,
        default_host: t.Optional[str] = None,
        default_port: t.Optional[int] = None
    ) -> Address:
        """"""Parse a string into an address.

        The string must be in the format ``host:port`` (IPv4) or
        ``[host]:port`` (IPv6).
        If no port is specified, or is empty, ``default_port`` will be used.
        If no host is specified, or is empty, ``default_host`` will be used.

            >>> Address.parse(""localhost:7687"")
            IPv4Address(('localhost', 7687))
            >>> Address.parse(""[::1]:7687"")
            IPv6Address(('::1', 7687, 0, 0))
            >>> Address.parse(""localhost"")
            IPv4Address(('localhost', 0))
            >>> Address.parse(""localhost"", default_port=1234)
            IPv4Address(('localhost', 1234))

        :param s: The string to parse.
        :param default_host: The default host to use if none is specified.
            :data:`None` indicates to use ``""localhost""`` as default.
        :param default_port: The default port to use if none is specified.
            :data:`None` indicates to use ``0`` as default.

        :returns: The parsed address.
        """"""
        if not isinstance(s, str):
            raise TypeError(""Address.parse requires a string argument"")
        if s.startswith(""[""):
            # IPv6
            port: t.Union[str, int]
            host, _, port = s[1:].rpartition(""]"")
            port = port.lstrip("":"")
            try:
                port = int(port)
            except (TypeError, ValueError):
                pass
            return cls((host or default_host or ""localhost"",
                        port or default_port or 0, 0, 0))
        else:
            # IPv4
            host, _, port = s.partition("":"")
            try:
                port = int(port)
            except (TypeError, ValueError):
                pass
            return cls((host or default_host or ""localhost"",
                        port or default_port or 0))",123,174
parse_list,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/addressing.py,"Parse multiple addresses into a list.

See :meth:`.parse` for details on the string format.

Either a whitespace-separated list of strings or multiple strings
can be used.

    >>> Address.parse_list(""localhost:7687"", ""[::1]:7687"")
    [IPv4Address(('localhost', 7687)), IPv6Address(('::1', 7687, 0, 0))]
    >>> Address.parse_list(""localhost:7687 [::1]:7687"")
    [IPv4Address(('localhost', 7687)), IPv6Address(('::1', 7687, 0, 0))]

:param s: The string(s) to parse.
:param default_host: The default host to use if none is specified.
    :data:`None` indicates to use ``""localhost""`` as default.
:param default_port: The default port to use if none is specified.
    :data:`None` indicates to use ``0`` as default.

:returns: The list of parsed addresses.","def parse_list(
        cls,
        *s: str,
        default_host: t.Optional[str] = None,
        default_port: t.Optional[int] = None
    ) -> t.List[Address]:
        """"""Parse multiple addresses into a list.

        See :meth:`.parse` for details on the string format.

        Either a whitespace-separated list of strings or multiple strings
        can be used.

            >>> Address.parse_list(""localhost:7687"", ""[::1]:7687"")
            [IPv4Address(('localhost', 7687)), IPv6Address(('::1', 7687, 0, 0))]
            >>> Address.parse_list(""localhost:7687 [::1]:7687"")
            [IPv4Address(('localhost', 7687)), IPv6Address(('::1', 7687, 0, 0))]

        :param s: The string(s) to parse.
        :param default_host: The default host to use if none is specified.
            :data:`None` indicates to use ``""localhost""`` as default.
        :param default_port: The default port to use if none is specified.
            :data:`None` indicates to use ``0`` as default.

        :returns: The list of parsed addresses.
        """"""
        if not all(isinstance(s0, str) for s0 in s):
            raise TypeError(""Address.parse_list requires a string argument"")
        return [cls.parse(a, default_host, default_port)
                for a in "" "".join(s).split()]",177,206
host,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/addressing.py,"The host part of the address.

This is the first part of the address tuple.

    >>> Address((""localhost"", 7687)).host
    'localhost'","def host(self) -> t.Any:
        """"""The host part of the address.

        This is the first part of the address tuple.

            >>> Address((""localhost"", 7687)).host
            'localhost'
        """"""
        return self[0]",216,224
port,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/addressing.py,"The port part of the address.

This is the second part of the address tuple.

    >>> Address((""localhost"", 7687)).port
    7687
    >>> Address((""localhost"", 7687, 0, 0)).port
    7687
    >>> Address((""localhost"", ""7687"")).port
    '7687'
    >>> Address((""localhost"", ""http"")).port
    'http'","def port(self) -> t.Any:
        """"""The port part of the address.

        This is the second part of the address tuple.

            >>> Address((""localhost"", 7687)).port
            7687
            >>> Address((""localhost"", 7687, 0, 0)).port
            7687
            >>> Address((""localhost"", ""7687"")).port
            '7687'
            >>> Address((""localhost"", ""http"")).port
            'http'
        """"""
        return self[1]",227,241
port_number,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/addressing.py,"The port part of the address as an integer.

First try to resolve the port as an integer, using
:func:`socket.getservbyname`. If that fails, fall back to parsing the
port as an integer.

    >>> Address((""localhost"", 7687)).port_number
    7687
    >>> Address((""localhost"", ""http"")).port_number
    80
    >>> Address((""localhost"", ""7687"")).port_number
    7687
    >>> Address((""localhost"", [])).port_number
    Traceback (most recent call last):
        ...
    TypeError: Unknown port value []
    >>> Address((""localhost"", ""banana-protocol"")).port_number
    Traceback (most recent call last):
        ...
    ValueError: Unknown port value 'banana-protocol'

:returns: The resolved port number.

:raise ValueError: If the port cannot be resolved.
:raise TypeError: If the port cannot be resolved.","def port_number(self) -> int:
        """"""The port part of the address as an integer.

        First try to resolve the port as an integer, using
        :func:`socket.getservbyname`. If that fails, fall back to parsing the
        port as an integer.

            >>> Address((""localhost"", 7687)).port_number
            7687
            >>> Address((""localhost"", ""http"")).port_number
            80
            >>> Address((""localhost"", ""7687"")).port_number
            7687
            >>> Address((""localhost"", [])).port_number
            Traceback (most recent call last):
                ...
            TypeError: Unknown port value []
            >>> Address((""localhost"", ""banana-protocol"")).port_number
            Traceback (most recent call last):
                ...
            ValueError: Unknown port value 'banana-protocol'

        :returns: The resolved port number.

        :raise ValueError: If the port cannot be resolved.
        :raise TypeError: If the port cannot be resolved.
        """"""
        error_cls: t.Type = TypeError

        try:
            return getservbyname(self[1])
        except OSError:
            # OSError: service/proto not found
            error_cls = ValueError
        except TypeError:
            # TypeError: getservbyname() argument 1 must be str, not X
            pass
        try:
            return int(self[1])
        except ValueError:
            error_cls = ValueError
        except TypeError:
            pass
        raise error_cls(""Unknown port value %r"" % self[1])",248,291
result,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_exceptions.py,"The Result object to which this failure is attached (if any).
        ","def result(self):
        """""" The Result object to which this failure is attached (if any).
        """"""
        try:
            return self.response.result
        except AttributeError:
            return None",151,157
release,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,Release the lock,"def release(self):
        """"""Release the lock""""""
        me = asyncio.current_task()
        return self._release(me)",162,165
locked,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,Return True if lock is acquired.,"def locked(self):
        """"""Return True if lock is acquired.""""""
        return self._locked",188,190
acquire,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,"Acquire a lock.

This method will raise a RuntimeError where an ordinary
(non-placeholder) lock would need to block. I.e., when the lock is
already taken.

Returns True if the lock was successfully acquired.","def acquire(self):
        """"""Acquire a lock.

        This method will raise a RuntimeError where an ordinary
        (non-placeholder) lock would need to block. I.e., when the lock is
        already taken.

        Returns True if the lock was successfully acquired.
        """"""
        if self._locked:
            raise RuntimeError(""Cannot acquire a locked cooperative lock."")
        self._locked = True
        return True",192,204
release,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,"Release a lock.

When the lock is locked, reset it to unlocked, and return.

When invoked on an unlocked lock, a RuntimeError is raised.

There is no return value.","def release(self):
        """"""Release a lock.

        When the lock is locked, reset it to unlocked, and return.

        When invoked on an unlocked lock, a RuntimeError is raised.

        There is no return value.
        """"""
        if self._locked:
            self._locked = False
        else:
            raise RuntimeError(""Lock is not acquired."")",206,218
locked,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,Return True if lock is acquired.,"def locked(self):
        """"""Return True if lock is acquired.""""""
        return self._owner is not None",253,255
acquire,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,"Acquire a lock.

This method will raise a RuntimeError where an ordinary
(non-placeholder) lock would need to block. I.e., when the lock is
already taken by another Task.

Returns True if the lock was successfully acquired.","def acquire(self):
        """"""Acquire a lock.

        This method will raise a RuntimeError where an ordinary
        (non-placeholder) lock would need to block. I.e., when the lock is
        already taken by another Task.

        Returns True if the lock was successfully acquired.
        """"""
        me = asyncio.current_task()
        if self._owner is None:
            self._owner = me
            self._count = 1
            return True
        if self._owner is me:
            self._count += 1
            return True
        raise RuntimeError(
            ""Cannot acquire a foreign locked cooperative lock.""
        )",257,276
release,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,"Release a lock.

When the lock is locked, reset it to unlocked, and return.

When invoked on an unlocked or foreign lock, a RuntimeError is raised.

There is no return value.","def release(self):
        """"""Release a lock.

        When the lock is locked, reset it to unlocked, and return.

        When invoked on an unlocked or foreign lock, a RuntimeError is raised.

        There is no return value.
        """"""
        me = asyncio.current_task()
        if self._owner is None:
            raise RuntimeError(""Lock is not acquired."")
        if self._owner is not me:
            raise RuntimeError(""Cannot release a foreign lock."")
        self._count -= 1
        if not self._count:
            self._owner = None",278,294
notify,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,"By default, wake up one coroutine waiting on this condition, if any.
If the calling coroutine has not acquired the lock when this method
is called, a RuntimeError is raised.

This method wakes up at most n of the coroutines waiting for the
condition variable; it is a no-op if no coroutines are waiting.

Note: an awakened coroutine does not actually return from its
wait() call until it can reacquire the lock. Since notify() does
not release the lock, its caller should.","def notify(self, n=1):
        """"""By default, wake up one coroutine waiting on this condition, if any.
        If the calling coroutine has not acquired the lock when this method
        is called, a RuntimeError is raised.

        This method wakes up at most n of the coroutines waiting for the
        condition variable; it is a no-op if no coroutines are waiting.

        Note: an awakened coroutine does not actually return from its
        wait() call until it can reacquire the lock. Since notify() does
        not release the lock, its caller should.
        """"""
        if not self.locked():
            raise RuntimeError('cannot notify on un-acquired lock')

        idx = 0
        for fut in self._waiters:
            if idx >= n:
                break

            if not fut.done():
                idx += 1
                fut.set_result(False)",437,459
notify_all,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/concurrency.py,"Wake up all threads waiting on this condition. This method acts
like notify(), but wakes up all waiting threads instead of one. If the
calling thread has not acquired the lock when this method is called,
a RuntimeError is raised.","def notify_all(self):
        """"""Wake up all threads waiting on this condition. This method acts
        like notify(), but wakes up all waiting threads instead of one. If the
        calling thread has not acquired the lock when this method is called,
        a RuntimeError is raised.
        """"""
        self.notify(len(self._waiters))",461,467
_connect,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/network/_bolt_socket.py,":param resolved_address:
:param timeout: seconds
:param keep_alive: True or False
:returns: socket object","def _connect(cls, resolved_address, timeout, keep_alive):
        """"""

        :param resolved_address:
        :param timeout: seconds
        :param keep_alive: True or False
        :returns: socket object
        """"""

        s = None  # The socket

        try:
            if len(resolved_address) == 2:
                s = socket(AF_INET)
            elif len(resolved_address) == 4:
                s = socket(AF_INET6)
            else:
                raise ValueError(
                    ""Unsupported address {!r}"".format(resolved_address))
            t = s.gettimeout()
            if timeout:
                s.settimeout(timeout)
            log.debug(""[#0000]  C: <OPEN> %s"", resolved_address)
            s.connect(resolved_address)
            s.settimeout(t)
            keep_alive = 1 if keep_alive else 0
            s.setsockopt(SOL_SOCKET, SO_KEEPALIVE, keep_alive)
            return s
        except SocketTimeout:
            log.debug(""[#0000]  S: <TIMEOUT> %s"", resolved_address)
            log.debug(""[#0000]  C: <CLOSE> %s"", resolved_address)
            cls._kill_raw_socket(s)
            raise ServiceUnavailable(
                ""Timed out trying to establish connection to {!r}"".format(
                    resolved_address))
        except Exception as error:
            log.debug(""[#0000]  S: <ERROR> %s %s"", type(error).__name__,
                      "" "".join(map(repr, error.args)))
            log.debug(""[#0000]  C: <CLOSE> %s"", resolved_address)
            cls._kill_raw_socket(s)
            if isinstance(error, OSError):
                raise ServiceUnavailable(
                    ""Failed to establish connection to {!r} (reason {})""
                    .format(resolved_address, error)
                ) from error
            raise",505,550
_handshake,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/network/_bolt_socket.py,":param s: Socket
:param resolved_address:
:param deadline:

:returns: (socket, version, client_handshake, server_response_data)","def _handshake(cls, s, resolved_address, deadline):
        """"""

        :param s: Socket
        :param resolved_address:
        :param deadline:

        :returns: (socket, version, client_handshake, server_response_data)
        """"""
        local_port = s.getsockname()[1]

        # TODO: Optimize logging code
        handshake = cls.Bolt.get_handshake()
        handshake = struct.unpack("">16B"", handshake)
        handshake = [handshake[i:i + 4] for i in range(0, len(handshake), 4)]

        supported_versions = [
            (""0x%02X%02X%02X%02X"" % (vx[0], vx[1], vx[2], vx[3])) for vx in
            handshake]

        log.debug(""[#%04X]  C: <MAGIC> 0x%08X"", local_port,
                  int.from_bytes(cls.Bolt.MAGIC_PREAMBLE, byteorder=""big""))
        log.debug(""[#%04X]  C: <HANDSHAKE> %s %s %s %s"", local_port,
                  *supported_versions)

        request = cls.Bolt.MAGIC_PREAMBLE + cls.Bolt.get_handshake()

        # Handle the handshake response
        original_timeout = s.gettimeout()
        s.settimeout(deadline.to_timeout())
        try:
            s.sendall(request)
            response = s.recv(4)
        except OSError as exc:
            raise ServiceUnavailable(
                f""Failed to read any data from server {resolved_address!r} ""
                f""after connected (deadline {deadline})""
            ) from exc
        finally:
            s.settimeout(original_timeout)
        data_size = len(response)
        if data_size == 0:
            # If no data is returned after a successful select
            # response, the server has closed the connection
            log.debug(""[#%04X]  S: <CLOSE>"", local_port)
            cls._kill_raw_socket(s)
            raise ServiceUnavailable(
                f""Connection to {resolved_address} closed without handshake ""
                ""response""
            )
        if data_size != 4:
            # Some garbled data has been received
            log.debug(""[#%04X]  S: @*#!"", local_port)
            cls._kill_raw_socket(s)
            raise BoltProtocolError(
                ""Expected four byte Bolt handshake response from ""
                f""{resolved_address!r}, received {response!r} instead; ""
                ""check for incorrect port number""
                , address=resolved_address
            )
        elif response == b""HTTP"":
            log.debug(""[#%04X]  S: <CLOSE>"", local_port)
            cls._kill_raw_socket(s)
            raise ServiceUnavailable(
                f""Cannot to connect to Bolt service on {resolved_address!r} ""
                ""(looks like HTTP)""
            )
        agreed_version = response[-1], response[-2]
        log.debug(""[#%04X]  S: <HANDSHAKE> 0x%06X%02X"", local_port,
                  agreed_version[1], agreed_version[0])
        return cls(s), agreed_version, handshake, response",578,648
connect,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/network/_bolt_socket.py,"Connect and perform a handshake and return a valid Connection object,
assuming a protocol version can be agreed.","def connect(cls, address, *, tcp_timeout, deadline, custom_resolver,
                ssl_context, keep_alive):
        """""" Connect and perform a handshake and return a valid Connection object,
        assuming a protocol version can be agreed.
        """"""
        errors = []
        # Establish a connection to the host and port specified
        # Catches refused connections see:
        # https://docs.python.org/2/library/errno.html

        resolved_addresses = NetworkUtil.resolve_address(
            addressing.Address(address), resolver=custom_resolver
        )
        for resolved_address in resolved_addresses:
            deadline_timeout = deadline.to_timeout()
            if (
                deadline_timeout is not None
                and deadline_timeout <= tcp_timeout
            ):
                tcp_timeout = deadline_timeout
            s = None
            try:
                s = BoltSocket._connect(resolved_address, tcp_timeout,
                                        keep_alive)
                s = BoltSocket._secure(s, resolved_address._host_name,
                                       ssl_context)
                return BoltSocket._handshake(s, resolved_address, deadline)
            except (BoltError, DriverError, OSError) as error:
                try:
                    local_port = s.getsockname()[1]
                except (OSError, AttributeError):
                    local_port = 0
                err_str = error.__class__.__name__
                if str(error):
                    err_str += "": "" + str(error)
                log.debug(""[#%04X]  S: <CONNECTION FAILED> %s"", local_port,
                          err_str)
                if s:
                    cls.close_socket(s)
                errors.append(error)
            except Exception:
                if s:
                    cls.close_socket(s)
                raise
        if not errors:
            raise ServiceUnavailable(
                ""Couldn't connect to %s (resolved to %s)"" % (
                    str(address), tuple(map(str, resolved_addresses)))
            )
        else:
            raise ServiceUnavailable(
                ""Couldn't connect to %s (resolved to %s):\n%s"" % (
                    str(address), tuple(map(str, resolved_addresses)),
                    ""\n"".join(map(str, errors))
                )
            ) from errors[0]",668,723
_dns_resolver,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/network/_util.py,"Regular DNS resolver. Takes an address object and optional
address family for filtering.

:param address:
:param family:
:returns:","def _dns_resolver(address, family=0):
        """""" Regular DNS resolver. Takes an address object and optional
        address family for filtering.

        :param address:
        :param family:
        :returns:
        """"""
        try:
            info = NetworkUtil.get_address_info(
                address.host, address.port, family=family,
                type=socket.SOCK_STREAM
            )
        except OSError:
            raise ValueError(""Cannot resolve address {}"".format(address))
        return _resolved_addresses_from_info(info, address._host_name)",105,120
resolve_address,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async_compat/network/_util.py,"Carry out domain name resolution on this Address object.

If a resolver function is supplied, and is callable, this is
called first, with this object as its argument. This may yield
multiple output addresses, which are chained into a subsequent
regular DNS resolution call. If no resolver function is passed,
the DNS resolution is carried out on the original Address
object.

This function returns a list of resolved Address objects.

:param address: the Address to resolve
:param family: optional address family to filter resolved
               addresses by (e.g. `socket.AF_INET6`)
:param resolver: optional customer resolver function to be
                 called before regular DNS resolution","def resolve_address(address, family=0, resolver=None):
        """""" Carry out domain name resolution on this Address object.

        If a resolver function is supplied, and is callable, this is
        called first, with this object as its argument. This may yield
        multiple output addresses, which are chained into a subsequent
        regular DNS resolution call. If no resolver function is passed,
        the DNS resolution is carried out on the original Address
        object.

        This function returns a list of resolved Address objects.

        :param address: the Address to resolve
        :param family: optional address family to filter resolved
                       addresses by (e.g. `socket.AF_INET6`)
        :param resolver: optional customer resolver function to be
                         called before regular DNS resolution
        """"""
        if isinstance(address, addressing.ResolvedAddress):
            yield address
            return

        log.debug(""[#0000]  _: <RESOLVE> in: %s"", address)
        if resolver:
            for address in map(addressing.Address, resolver(address)):
                log.debug(""[#0000]  _: <RESOLVE> custom resolver out: %s"",
                          address)
                for resolved_address in NetworkUtil._dns_resolver(
                    address, family=family
                ):
                    log.debug(""[#0000]  _: <RESOLVE> dns resolver out: %s"",
                              resolved_address)
                    yield resolved_address
        else:
            for resolved_address in NetworkUtil._dns_resolver(
                address, family=family
            ):
                log.debug(""[#0000]  _: <RESOLVE> dns resolver out: %s"",
                          resolved_address)
                yield resolved_address",123,162
point_type,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_spatial/__init__.py,"Dynamically create a Point subclass.
    ","def point_type(
    name: str,
    fields: t.Tuple[str, str, str],
    srid_map: t.Dict[int, int]
) -> t.Type[Point]:
    """""" Dynamically create a Point subclass.
    """"""

    def srid(self):
        try:
            return srid_map[len(self)]
        except KeyError:
            return None

    attributes = {""srid"": property(srid)}

    for index, subclass_field in enumerate(fields):

        def accessor(self, i=index, f=subclass_field):
            try:
                return self[i]
            except IndexError:
                raise AttributeError(f)

        for field_alias in {subclass_field, ""xyz""[index]}:
            attributes[field_alias] = property(accessor)

    cls = t.cast(t.Type[Point], type(name, (Point,), attributes))

    with srid_table_lock:
        for dim, srid_ in srid_map.items():
            srid_table[srid_] = (cls, dim)

    return cls",80,113
hydrate_date,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Hydrator for `Date` values.

:param days:
:returns: Date","def hydrate_date(days):
    """""" Hydrator for `Date` values.

    :param days:
    :returns: Date
    """"""
    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)",56,62
dehydrate_date,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `date` values.

:param value:
:type value: Date
:returns:","def dehydrate_date(value):
    """""" Dehydrator for `date` values.

    :param value:
    :type value: Date
    :returns:
    """"""
    return Structure(b""D"", value.toordinal() - get_date_unix_epoch().toordinal())",65,72
hydrate_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Hydrator for `Time` and `LocalTime` values.

:param nanoseconds:
:param tz:
:returns: Time","def hydrate_time(nanoseconds, tz=None):
    """""" Hydrator for `Time` and `LocalTime` values.

    :param nanoseconds:
    :param tz:
    :returns: Time
    """"""
    from pytz import FixedOffset
    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))
    minutes, seconds = map(int, divmod(seconds, 60))
    hours, minutes = map(int, divmod(minutes, 60))
    t = Time(hours, minutes, seconds, nanoseconds)
    if tz is None:
        return t
    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)
    zone = FixedOffset(tz_offset_minutes)
    return zone.localize(t)",75,91
dehydrate_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `time` values.

:param value:
:type value: Time
:returns:","def dehydrate_time(value):
    """""" Dehydrator for `time` values.

    :param value:
    :type value: Time
    :returns:
    """"""
    if isinstance(value, Time):
        nanoseconds = value.ticks
    elif isinstance(value, time):
        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +
                       1000000000 * value.second + 1000 * value.microsecond)
    else:
        raise TypeError(""Value must be a neo4j.time.Time or a datetime.time"")
    if value.tzinfo:
        return Structure(b""T"", nanoseconds,
                         int(value.tzinfo.utcoffset(value).total_seconds()))
    else:
        return Structure(b""t"", nanoseconds)",94,112
hydrate_datetime,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Hydrator for `DateTime` and `LocalDateTime` values.

:param seconds:
:param nanoseconds:
:param tz:
:returns: datetime","def hydrate_datetime(seconds, nanoseconds, tz=None):
    """""" Hydrator for `DateTime` and `LocalDateTime` values.

    :param seconds:
    :param nanoseconds:
    :param tz:
    :returns: datetime
    """"""
    from pytz import (
        FixedOffset,
        timezone,
    )
    minutes, seconds = map(int, divmod(seconds, 60))
    hours, minutes = map(int, divmod(minutes, 60))
    days, hours = map(int, divmod(hours, 24))
    t = DateTime.combine(
        Date.from_ordinal(get_date_unix_epoch_ordinal() + days),
        Time(hours, minutes, seconds, nanoseconds)
    )
    if tz is None:
        return t
    if isinstance(tz, int):
        tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)
        zone = FixedOffset(tz_offset_minutes)
    else:
        zone = timezone(tz)
    return zone.localize(t)",115,141
dehydrate_datetime,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `datetime` values.

:param value:
:type value: datetime or DateTime
:returns:","def dehydrate_datetime(value):
    """""" Dehydrator for `datetime` values.

    :param value:
    :type value: datetime or DateTime
    :returns:
    """"""

    def seconds_and_nanoseconds(dt):
        if isinstance(dt, datetime):
            dt = DateTime.from_native(dt)
        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)
        dt_clock_time = dt.to_clock_time()
        zone_epoch_clock_time = zone_epoch.to_clock_time()
        t = dt_clock_time - zone_epoch_clock_time
        return t.seconds, t.nanoseconds

    tz = value.tzinfo
    if tz is None:
        # without time zone
        from pytz import utc
        value = utc.localize(value)
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        return Structure(b""d"", seconds, nanoseconds)
    elif hasattr(tz, ""zone"") and tz.zone and isinstance(tz.zone, str):
        # with named pytz time zone
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        return Structure(b""f"", seconds, nanoseconds, tz.zone)
    elif hasattr(tz, ""key"") and tz.key and isinstance(tz.key, str):
        # with named zoneinfo (Python 3.9+) time zone
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        return Structure(b""f"", seconds, nanoseconds, tz.key)
    else:
        if isinstance(tz, timezone):
            # offset of the timezone is constant, so any date will do
            offset = tz.utcoffset(ANY_BUILTIN_DATETIME)
        else:
            offset = tz.utcoffset(value)
        # with time offset
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        return Structure(b""F"", seconds, nanoseconds,
                         int(offset.total_seconds()))",144,185
hydrate_duration,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Hydrator for `Duration` values.

:param months:
:param days:
:param seconds:
:param nanoseconds:
:returns: `duration` namedtuple","def hydrate_duration(months, days, seconds, nanoseconds):
    """""" Hydrator for `Duration` values.

    :param months:
    :param days:
    :param seconds:
    :param nanoseconds:
    :returns: `duration` namedtuple
    """"""
    return Duration(months=months, days=days, seconds=seconds, nanoseconds=nanoseconds)",232,241
dehydrate_duration,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `duration` values.

:param value:
:type value: Duration
:returns:","def dehydrate_duration(value):
    """""" Dehydrator for `duration` values.

    :param value:
    :type value: Duration
    :returns:
    """"""
    return Structure(b""E"", value.months, value.days, value.seconds, value.nanoseconds)",244,251
dehydrate_timedelta,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `timedelta` values.

:param value:
:type value: timedelta
:returns:","def dehydrate_timedelta(value):
    """""" Dehydrator for `timedelta` values.

    :param value:
    :type value: timedelta
    :returns:
    """"""
    months = 0
    days = value.days
    seconds = value.seconds
    nanoseconds = 1000 * value.microseconds
    return Structure(b""E"", months, days, seconds, nanoseconds)",254,265
dehydrate_np_datetime,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `numpy.datetime64` values.

:param value:
:type value: numpy.datetime64
:returns:","def dehydrate_np_datetime(value):
        """""" Dehydrator for `numpy.datetime64` values.

        :param value:
        :type value: numpy.datetime64
        :returns:
        """"""
        if np.isnat(value):
            return None
        year = value.astype(""datetime64[Y]"").astype(int) + 1970
        if not 0 < year <= 9999:
            # while we could encode years outside the range, they would fail
            # when retrieved from the database.
            raise ValueError(f""Year out of range ({MIN_YEAR:d}..{MAX_YEAR:d}) ""
                             f""found {year}"")
        seconds = value.astype(np.dtype(""datetime64[s]"")).astype(int)
        nanoseconds = (value.astype(np.dtype(""datetime64[ns]"")).astype(int)
                       % NANO_SECONDS)
        return Structure(b""d"", seconds, nanoseconds)",189,207
dehydrate_pandas_datetime,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `pandas.Timestamp` values.

:param value:
:type value: pandas.Timestamp
:returns:","def dehydrate_pandas_datetime(value):
        """""" Dehydrator for `pandas.Timestamp` values.

        :param value:
        :type value: pandas.Timestamp
        :returns:
        """"""
        return dehydrate_datetime(
            DateTime(
                value.year,
                value.month,
                value.day,
                value.hour,
                value.minute,
                value.second,
                value.microsecond * 1000 + value.nanosecond,
                value.tzinfo,
            )
        )",211,229
dehydrate_np_timedelta,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `numpy.timedelta64` values.

:param value:
:type value: numpy.timedelta64
:returns:","def dehydrate_np_timedelta(value):
        """""" Dehydrator for `numpy.timedelta64` values.

        :param value:
        :type value: numpy.timedelta64
        :returns:
        """"""
        if np.isnat(value):
            return None
        unit, step_size = np.datetime_data(value)
        numer = int(value.astype(int))
        # raise RuntimeError((type(numer), type(step_size)))
        kwarg = _NUMPY_DURATION_UNITS.get(unit)
        if kwarg is not None:
            return dehydrate_duration(Duration(**{kwarg: numer * step_size}))
        return dehydrate_duration(Duration(
            nanoseconds=value.astype(""timedelta64[ns]"").astype(int)
        ))",282,299
dehydrate_pandas_timedelta,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/temporal.py,"Dehydrator for `pandas.Timedelta` values.

:param value:
:type value: pandas.Timedelta
:returns:","def dehydrate_pandas_timedelta(value):
        """""" Dehydrator for `pandas.Timedelta` values.

        :param value:
        :type value: pandas.Timedelta
        :returns:
        """"""
        return dehydrate_duration(Duration(
            nanoseconds=value.value
        ))",303,312
hydrate_point,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/spatial.py,"Create a new instance of a Point subclass from a raw
set of fields. The subclass chosen is determined by the
given SRID; a ValueError will be raised if no such
subclass can be found.","def hydrate_point(srid, *coordinates):
    """""" Create a new instance of a Point subclass from a raw
    set of fields. The subclass chosen is determined by the
    given SRID; a ValueError will be raised if no such
    subclass can be found.
    """"""
    try:
        point_class, dim = srid_table[srid]
    except KeyError:
        point = Point(coordinates)
        point.srid = srid
        return point
    else:
        if len(coordinates) != dim:
            raise ValueError(""SRID %d requires %d coordinates (%d provided)"" % (srid, dim, len(coordinates)))
        return point_class(coordinates)",24,39
dehydrate_point,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v1/spatial.py,"Dehydrator for Point data.

:param value:
:type value: Point
:returns:","def dehydrate_point(value):
    """""" Dehydrator for Point data.

    :param value:
    :type value: Point
    :returns:
    """"""
    dim = len(value)
    if dim == 2:
        return Structure(b""X"", value.srid, *value)
    elif dim == 3:
        return Structure(b""Y"", value.srid, *value)
    else:
        raise ValueError(""Cannot dehydrate Point with %d dimensions"" % dim)",42,55
hydrate_datetime,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v2/temporal.py,"Hydrator for `DateTime` and `LocalDateTime` values.

:param seconds:
:param nanoseconds:
:param tz:
:returns: datetime","def hydrate_datetime(seconds, nanoseconds, tz=None):  # type: ignore[no-redef]
    """""" Hydrator for `DateTime` and `LocalDateTime` values.

    :param seconds:
    :param nanoseconds:
    :param tz:
    :returns: datetime
    """"""
    import pytz

    minutes, seconds = map(int, divmod(seconds, 60))
    hours, minutes = map(int, divmod(minutes, 60))
    days, hours = map(int, divmod(hours, 24))
    t = DateTime.combine(
        Date.from_ordinal(get_date_unix_epoch_ordinal() + days),
        Time(hours, minutes, seconds, nanoseconds)
    )
    if tz is None:
        return t
    if isinstance(tz, int):
        tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)
        zone = pytz.FixedOffset(tz_offset_minutes)
    else:
        zone = pytz.timezone(tz)
    t = t.replace(tzinfo=pytz.UTC)
    return t.as_timezone(zone)",20,45
dehydrate_datetime,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v2/temporal.py,"Dehydrator for `datetime` values.

:param value:
:type value: datetime
:returns:","def dehydrate_datetime(value):  # type: ignore[no-redef]
    """""" Dehydrator for `datetime` values.

    :param value:
    :type value: datetime
    :returns:
    """"""

    import pytz

    def seconds_and_nanoseconds(dt):
        if isinstance(dt, datetime):
            dt = DateTime.from_native(dt)
        dt = dt.astimezone(pytz.UTC)
        utc_epoch = DateTime(1970, 1, 1, tzinfo=pytz.UTC)
        dt_clock_time = dt.to_clock_time()
        utc_epoch_clock_time = utc_epoch.to_clock_time()
        t = dt_clock_time - utc_epoch_clock_time
        return t.seconds, t.nanoseconds

    tz = value.tzinfo
    if tz is None:
        # without time zone
        value = pytz.UTC.localize(value)
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        return Structure(b""d"", seconds, nanoseconds)
    elif hasattr(tz, ""zone"") and tz.zone and isinstance(tz.zone, str):
        # with named pytz time zone
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        return Structure(b""i"", seconds, nanoseconds, tz.zone)
    elif hasattr(tz, ""key"") and tz.key and isinstance(tz.key, str):
        # with named zoneinfo (Python 3.9+) time zone
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        return Structure(b""i"", seconds, nanoseconds, tz.key)
    else:
        # with time offset
        if isinstance(tz, timezone):
            # offset of the timezone is constant, so any date will do
            offset = tz.utcoffset(datetime(1970, 1, 1))
        else:
            offset = tz.utcoffset(value)
        seconds, nanoseconds = seconds_and_nanoseconds(value)
        if offset.microseconds:
            raise ValueError(""Bolt protocol does not support sub-second ""
                             ""UTC offsets."")
        offset_seconds = offset.days * 86400 + offset.seconds
        return Structure(b""I"", seconds, nanoseconds, offset_seconds)",48,94
dehydrate_pandas_datetime,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/hydration/v2/temporal.py,"Dehydrator for `pandas.Timestamp` values.

:param value:
:type value: pandas.Timestamp
:returns:","def dehydrate_pandas_datetime(value):
        """""" Dehydrator for `pandas.Timestamp` values.

        :param value:
        :type value: pandas.Timestamp
        :returns:
        """"""
        seconds, nanoseconds = divmod(value.value, NANO_SECONDS)

        import pytz

        tz = value.tzinfo
        if tz is None:
            # without time zone
            return Structure(b""d"", seconds, nanoseconds)
        elif hasattr(tz, ""zone"") and tz.zone and isinstance(tz.zone, str):
            # with named pytz time zone
            return Structure(b""i"", seconds, nanoseconds, tz.zone)
        elif hasattr(tz, ""key"") and tz.key and isinstance(tz.key, str):
            # with named zoneinfo (Python 3.9+) time zone
            return Structure(b""i"", seconds, nanoseconds, tz.key)
        else:
            # with time offset
            offset = tz.utcoffset(value)
            if offset.microseconds:
                raise ValueError(""Bolt protocol does not support sub-second ""
                                 ""UTC offsets."")
            offset_seconds = offset.days * 86400 + offset.seconds
            return Structure(b""I"", seconds, nanoseconds, offset_seconds)",98,126
pop_u16,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_codec/packstream/v1/__init__.py,"Remove the last two bytes of data, returning them as a big-endian
16-bit unsigned integer.","def pop_u16(self):
        """""" Remove the last two bytes of data, returning them as a big-endian
        16-bit unsigned integer.
        """"""
        if self.used >= 2:
            value = 0x100 * self.data[self.used - 2] + self.data[self.used - 1]
            self.used -= 2
            return value
        else:
            return -1",500,509
static,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/auth_management.py,"Create a static auth manager.

The manager will always return the auth info provided at its creation.

Example::

    # NOTE: this example is for illustration purposes only.
    #       The driver will automatically wrap static auth info in a
    #       static auth manager.

    import neo4j
    from neo4j.auth_management import AsyncAuthManagers


    auth = neo4j.basic_auth(""neo4j"", ""password"")

    with neo4j.GraphDatabase.driver(
        ""neo4j://example.com:7687"",
        auth=AsyncAuthManagers.static(auth)
        # auth=auth  # this is equivalent
    ) as driver:
        ...  # do stuff

:param auth: The auth to return.

:returns:
    An instance of an implementation of :class:`.AsyncAuthManager` that
    always returns the same auth.

.. versionadded:: 5.8

.. versionchanged:: 5.14 Stabilized from preview.","def static(auth: _TAuth) -> AsyncAuthManager:
        """"""Create a static auth manager.

        The manager will always return the auth info provided at its creation.

        Example::

            # NOTE: this example is for illustration purposes only.
            #       The driver will automatically wrap static auth info in a
            #       static auth manager.

            import neo4j
            from neo4j.auth_management import AsyncAuthManagers


            auth = neo4j.basic_auth(""neo4j"", ""password"")

            with neo4j.GraphDatabase.driver(
                ""neo4j://example.com:7687"",
                auth=AsyncAuthManagers.static(auth)
                # auth=auth  # this is equivalent
            ) as driver:
                ...  # do stuff

        :param auth: The auth to return.

        :returns:
            An instance of an implementation of :class:`.AsyncAuthManager` that
            always returns the same auth.

        .. versionadded:: 5.8

        .. versionchanged:: 5.14 Stabilized from preview.
        """"""
        return AsyncStaticAuthManager(auth)",126,160
basic,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/auth_management.py,"Create an auth manager handling basic auth password rotation.

This factory wraps the provider function in an auth manager
implementation that caches the provided auth info until the server
notifies the driver that the auth info has expired (by returning
an error that indicates that the password is invalid).

Note that this implies that the provider function will be called again
if it provides wrong auth info, potentially deferring failure due to a
wrong password or username.

.. warning::

    The provider function **must not** interact with the driver in any
    way as this can cause deadlocks and undefined behaviour.

    The provider function must only ever return auth information
    belonging to the same identity.
    Switching identities is undefined behavior.
    You may use :ref:`session-level authentication<session-auth-ref>`
    for such use-cases.

Example::

    import neo4j
    from neo4j.auth_management import (
        AsyncAuthManagers,
        ExpiringAuth,
    )


    async def auth_provider():
        # some way of getting a token
        user, password = await get_current_auth()
        return (user, password)


    with neo4j.GraphDatabase.driver(
        ""neo4j://example.com:7687"",
        auth=AsyncAuthManagers.basic(auth_provider)
    ) as driver:
        ...  # do stuff

:param provider:
    A callable that provides new auth info whenever the server notifies
    the driver that the previous auth info is invalid.

:returns:
    An instance of an implementation of :class:`.AsyncAuthManager` that
    returns auth info from the given provider and refreshes it, calling
    the provider again, when the auth info was rejected by the server.

.. versionadded:: 5.12

.. versionchanged:: 5.14 Stabilized from preview.","def basic(
        provider: t.Callable[[], t.Awaitable[_TAuth]]
    ) -> AsyncAuthManager:
        """"""Create an auth manager handling basic auth password rotation.

        This factory wraps the provider function in an auth manager
        implementation that caches the provided auth info until the server
        notifies the driver that the auth info has expired (by returning
        an error that indicates that the password is invalid).

        Note that this implies that the provider function will be called again
        if it provides wrong auth info, potentially deferring failure due to a
        wrong password or username.

        .. warning::

            The provider function **must not** interact with the driver in any
            way as this can cause deadlocks and undefined behaviour.

            The provider function must only ever return auth information
            belonging to the same identity.
            Switching identities is undefined behavior.
            You may use :ref:`session-level authentication<session-auth-ref>`
            for such use-cases.

        Example::

            import neo4j
            from neo4j.auth_management import (
                AsyncAuthManagers,
                ExpiringAuth,
            )


            async def auth_provider():
                # some way of getting a token
                user, password = await get_current_auth()
                return (user, password)


            with neo4j.GraphDatabase.driver(
                ""neo4j://example.com:7687"",
                auth=AsyncAuthManagers.basic(auth_provider)
            ) as driver:
                ...  # do stuff

        :param provider:
            A callable that provides new auth info whenever the server notifies
            the driver that the previous auth info is invalid.

        :returns:
            An instance of an implementation of :class:`.AsyncAuthManager` that
            returns auth info from the given provider and refreshes it, calling
            the provider again, when the auth info was rejected by the server.

        .. versionadded:: 5.12

        .. versionchanged:: 5.14 Stabilized from preview.
        """"""
        handled_codes = frozenset((""Neo.ClientError.Security.Unauthorized"",))

        async def wrapped_provider() -> ExpiringAuth:
            return ExpiringAuth(await provider())

        return AsyncNeo4jAuthTokenManager(wrapped_provider, handled_codes)",163,227
bearer,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/auth_management.py,"Create an auth manager for potentially expiring bearer auth tokens.

This factory wraps the provider function in an auth manager
implementation that caches the provided auth info until either the
:attr:`.ExpiringAuth.expires_at` exceeded or the server notified the
driver that the auth info has expired (by returning an error that
indicates that the bearer auth token has expired).

.. warning::

    The provider function **must not** interact with the driver in any
    way as this can cause deadlocks and undefined behaviour.

    The provider function must only ever return auth information
    belonging to the same identity.
    Switching identities is undefined behavior.
    You may use :ref:`session-level authentication<session-auth-ref>`
    for such use-cases.

Example::

    import neo4j
    from neo4j.auth_management import (
        AsyncAuthManagers,
        ExpiringAuth,
    )


    async def auth_provider():
        # some way of getting a token
        sso_token = await get_sso_token()
        # assume we know our tokens expire every 60 seconds
        expires_in = 60

        return ExpiringAuth(
            auth=neo4j.bearer_auth(sso_token),
            # Include a little buffer so that we fetch a new token
            # *before* the old one expires
            expires_in=expires_in - 10
        )


    with neo4j.GraphDatabase.driver(
        ""neo4j://example.com:7687"",
        auth=AsyncAuthManagers.bearer(auth_provider)
    ) as driver:
        ...  # do stuff

:param provider:
    A callable that provides a :class:`.ExpiringAuth` instance.

:returns:
    An instance of an implementation of :class:`.AsyncAuthManager` that
    returns auth info from the given provider and refreshes it, calling
    the provider again, when the auth info expires (either because it's
    reached its expiry time or because the server flagged it as
    expired).

.. versionadded:: 5.12

.. versionchanged:: 5.14 Stabilized from preview.","def bearer(
        provider: t.Callable[[], t.Awaitable[ExpiringAuth]]
    ) -> AsyncAuthManager:
        """"""Create an auth manager for potentially expiring bearer auth tokens.

        This factory wraps the provider function in an auth manager
        implementation that caches the provided auth info until either the
        :attr:`.ExpiringAuth.expires_at` exceeded or the server notified the
        driver that the auth info has expired (by returning an error that
        indicates that the bearer auth token has expired).

        .. warning::

            The provider function **must not** interact with the driver in any
            way as this can cause deadlocks and undefined behaviour.

            The provider function must only ever return auth information
            belonging to the same identity.
            Switching identities is undefined behavior.
            You may use :ref:`session-level authentication<session-auth-ref>`
            for such use-cases.

        Example::

            import neo4j
            from neo4j.auth_management import (
                AsyncAuthManagers,
                ExpiringAuth,
            )


            async def auth_provider():
                # some way of getting a token
                sso_token = await get_sso_token()
                # assume we know our tokens expire every 60 seconds
                expires_in = 60

                return ExpiringAuth(
                    auth=neo4j.bearer_auth(sso_token),
                    # Include a little buffer so that we fetch a new token
                    # *before* the old one expires
                    expires_in=expires_in - 10
                )


            with neo4j.GraphDatabase.driver(
                ""neo4j://example.com:7687"",
                auth=AsyncAuthManagers.bearer(auth_provider)
            ) as driver:
                ...  # do stuff

        :param provider:
            A callable that provides a :class:`.ExpiringAuth` instance.

        :returns:
            An instance of an implementation of :class:`.AsyncAuthManager` that
            returns auth info from the given provider and refreshes it, calling
            the provider again, when the auth info expires (either because it's
            reached its expiry time or because the server flagged it as
            expired).

        .. versionadded:: 5.12

        .. versionchanged:: 5.14 Stabilized from preview.
        """"""
        handled_codes = frozenset((
            ""Neo.ClientError.Security.TokenExpired"",
            ""Neo.ClientError.Security.Unauthorized"",
        ))
        return AsyncNeo4jAuthTokenManager(provider, handled_codes)",230,299
static,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/auth_management.py,"Create a static client certificate provider.

The provider simply makes the driver use the given certificate for all
connections.","def static(cert: ClientCertificate) -> AsyncClientCertificateProvider:
        """"""
        Create a static client certificate provider.

        The provider simply makes the driver use the given certificate for all
        connections.
        """"""
        return _AsyncStaticClientCertificateProvider(cert)",403,410
rotating,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/auth_management.py,"Create certificate provider that allows for rotating certificates.

.. seealso:: :class:`.AsyncRotatingClientCertificateProvider`","def rotating(
        initial_cert: ClientCertificate
    ) -> AsyncRotatingClientCertificateProvider:
        """"""
        Create certificate provider that allows for rotating certificates.

        .. seealso:: :class:`.AsyncRotatingClientCertificateProvider`
        """"""
        return AsyncRotatingClientCertificateProvider(initial_cert)",414,422
bookmark_manager,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"Create a :class:`.AsyncBookmarkManager` with default implementation.

Basic usage example to configure sessions with the built-in bookmark
manager implementation so that all work is automatically causally
chained (i.e., all reads can observe all previous writes even in a
clustered setup)::

    import neo4j


    # omitting closing the driver for brevity
    driver = neo4j.AsyncGraphDatabase.driver(...)
    bookmark_manager = neo4j.AsyncGraphDatabase.bookmark_manager(...)

    async with driver.session(
        bookmark_manager=bookmark_manager
    ) as session1:
        async with driver.session(
            bookmark_manager=bookmark_manager,
            access_mode=neo4j.READ_ACCESS
        ) as session2:
            result1 = await session1.run(""<WRITE_QUERY>"")
            await result1.consume()
            # READ_QUERY is guaranteed to see what WRITE_QUERY wrote.
            result2 = await session2.run(""<READ_QUERY>"")
            await result2.consume()

This is a very contrived example, and in this particular case, having
both queries in the same session has the exact same effect and might
even be more performant. However, when dealing with sessions spanning
multiple threads, async Tasks, processes, or even hosts, the bookmark
manager can come in handy as sessions are not safe to be used
concurrently.

:param initial_bookmarks:
    The initial set of bookmarks. The returned bookmark manager will
    use this to initialize its internal bookmarks.
:param bookmarks_supplier:
    Function which will be called every time the default bookmark
    manager's method :meth:`.AsyncBookmarkManager.get_bookmarks`
    gets called.
    The function takes no arguments and must return a
    :class:`.Bookmarks` object. The result of ``bookmarks_supplier``
    will then be concatenated with the internal set of bookmarks and
    used to configure the session in creation. It will, however, not
    update the internal set of bookmarks.
:param bookmarks_consumer:
    Function which will be called whenever the set of bookmarks
    handled by the bookmark manager gets updated with the new
    internal bookmark set. It will receive the new set of bookmarks
    as a :class:`.Bookmarks` object and return :data:`None`.

:returns: A default implementation of :class:`.AsyncBookmarkManager`.

.. versionadded:: 5.0

.. versionchanged:: 5.3
    The bookmark manager no longer tracks bookmarks per database.
    This effectively changes the signature of almost all bookmark
    manager related methods:

    * ``initial_bookmarks`` is no longer a mapping from database name
      to bookmarks but plain bookmarks.
    * ``bookmarks_supplier`` no longer receives the database name as
      an argument.
    * ``bookmarks_consumer`` no longer receives the database name as
      an argument.

.. versionchanged:: 5.8 Stabilized from experimental.","def bookmark_manager(
        cls,
        initial_bookmarks: t.Union[None, Bookmarks, t.Iterable[str]] = None,
        bookmarks_supplier: t.Optional[_TBmSupplier] = None,
        bookmarks_consumer: t.Optional[_TBmConsumer] = None
    ) -> AsyncBookmarkManager:
        """"""Create a :class:`.AsyncBookmarkManager` with default implementation.

        Basic usage example to configure sessions with the built-in bookmark
        manager implementation so that all work is automatically causally
        chained (i.e., all reads can observe all previous writes even in a
        clustered setup)::

            import neo4j


            # omitting closing the driver for brevity
            driver = neo4j.AsyncGraphDatabase.driver(...)
            bookmark_manager = neo4j.AsyncGraphDatabase.bookmark_manager(...)

            async with driver.session(
                bookmark_manager=bookmark_manager
            ) as session1:
                async with driver.session(
                    bookmark_manager=bookmark_manager,
                    access_mode=neo4j.READ_ACCESS
                ) as session2:
                    result1 = await session1.run(""<WRITE_QUERY>"")
                    await result1.consume()
                    # READ_QUERY is guaranteed to see what WRITE_QUERY wrote.
                    result2 = await session2.run(""<READ_QUERY>"")
                    await result2.consume()

        This is a very contrived example, and in this particular case, having
        both queries in the same session has the exact same effect and might
        even be more performant. However, when dealing with sessions spanning
        multiple threads, async Tasks, processes, or even hosts, the bookmark
        manager can come in handy as sessions are not safe to be used
        concurrently.

        :param initial_bookmarks:
            The initial set of bookmarks. The returned bookmark manager will
            use this to initialize its internal bookmarks.
        :param bookmarks_supplier:
            Function which will be called every time the default bookmark
            manager's method :meth:`.AsyncBookmarkManager.get_bookmarks`
            gets called.
            The function takes no arguments and must return a
            :class:`.Bookmarks` object. The result of ``bookmarks_supplier``
            will then be concatenated with the internal set of bookmarks and
            used to configure the session in creation. It will, however, not
            update the internal set of bookmarks.
        :param bookmarks_consumer:
            Function which will be called whenever the set of bookmarks
            handled by the bookmark manager gets updated with the new
            internal bookmark set. It will receive the new set of bookmarks
            as a :class:`.Bookmarks` object and return :data:`None`.

        :returns: A default implementation of :class:`.AsyncBookmarkManager`.

        .. versionadded:: 5.0

        .. versionchanged:: 5.3
            The bookmark manager no longer tracks bookmarks per database.
            This effectively changes the signature of almost all bookmark
            manager related methods:

            * ``initial_bookmarks`` is no longer a mapping from database name
              to bookmarks but plain bookmarks.
            * ``bookmarks_supplier`` no longer receives the database name as
              an argument.
            * ``bookmarks_consumer`` no longer receives the database name as
              an argument.

        .. versionchanged:: 5.8 Stabilized from experimental.
        """"""
        return AsyncNeo4jBookmarkManager(
            initial_bookmarks=initial_bookmarks,
            bookmarks_supplier=bookmarks_supplier,
            bookmarks_consumer=bookmarks_consumer
        )",315,395
bolt_driver,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"Create a driver for direct Bolt server access that uses
socket I/O and thread-based concurrency.","def bolt_driver(cls, target, **config):
        """""" Create a driver for direct Bolt server access that uses
        socket I/O and thread-based concurrency.
        """"""
        from .._exceptions import (
            BoltHandshakeError,
            BoltSecurityError,
        )

        try:
            return AsyncBoltDriver.open(target, **config)
        except (BoltHandshakeError, BoltSecurityError) as error:
            from ..exceptions import ServiceUnavailable
            raise ServiceUnavailable(str(error)) from error",398,411
neo4j_driver,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"Create a driver for routing-capable Neo4j service access
that uses socket I/O and thread-based concurrency.","def neo4j_driver(cls, *targets, routing_context=None, **config):
        """""" Create a driver for routing-capable Neo4j service access
        that uses socket I/O and thread-based concurrency.
        """"""

        # TODO: 6.0 - adjust signature to only take one target
        if len(targets) > 1:
            deprecation_warn(
                ""Creating a routing driver with multiple targets is ""
                ""deprecated. The driver only uses the first target anyway. ""
                ""The method signature will change in a future release."",
            )

        from .._exceptions import (
            BoltHandshakeError,
            BoltSecurityError,
        )

        try:
            return AsyncNeo4jDriver.open(*targets, routing_context=routing_context, **config)
        except (BoltHandshakeError, BoltSecurityError) as error:
            from ..exceptions import ServiceUnavailable
            raise ServiceUnavailable(str(error)) from error",414,436
parse_target,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"Parse a target string to produce an address.
        ","def parse_target(cls, target):
        """""" Parse a target string to produce an address.
        """"""
        if not target:
            target = cls.default_target
        address = Address.parse(target, default_host=cls.default_host,
                                default_port=cls.default_port)
        return address",454,461
parse_targets,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"Parse a sequence of target strings to produce an address
list.","def parse_targets(cls, *targets):
        """""" Parse a sequence of target strings to produce an address
        list.
        """"""
        targets = "" "".join(targets)
        if not targets:
            targets = cls.default_targets
        addresses = Address.parse_list(targets, default_host=cls.default_host, default_port=cls.default_port)
        return addresses",479,487
encrypted,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,Indicate whether the driver was configured to use encryption.,"def encrypted(self) -> bool:
        """"""Indicate whether the driver was configured to use encryption.""""""
        return bool(self._pool.pool_config.encrypted)",547,549
execute_query_bookmark_manager,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"The driver's default query bookmark manager.

This is the default :class:`.AsyncBookmarkManager` used by
:meth:`.execute_query`. This can be used to causally chain
:meth:`.execute_query` calls and sessions. Example::

    async def example(driver: neo4j.AsyncDriver) -> None:
        await driver.execute_query(""<QUERY 1>"")
        async with driver.session(
            bookmark_manager=driver.execute_query_bookmark_manager
        ) as session:
            # every query inside this session will be causally chained
            # (i.e., can read what was written by <QUERY 1>)
            await session.run(""<QUERY 2>"")
        # subsequent execute_query calls will be causally chained
        # (i.e., can read what was written by <QUERY 2>)
        await driver.execute_query(""<QUERY 3>"")

.. versionadded:: 5.5

.. versionchanged:: 5.8

    * Renamed from ``query_bookmark_manager`` to
      ``execute_query_bookmark_manager``.
    * Stabilized from experimental.","def execute_query_bookmark_manager(self) -> AsyncBookmarkManager:
        """"""The driver's default query bookmark manager.

        This is the default :class:`.AsyncBookmarkManager` used by
        :meth:`.execute_query`. This can be used to causally chain
        :meth:`.execute_query` calls and sessions. Example::

            async def example(driver: neo4j.AsyncDriver) -> None:
                await driver.execute_query(""<QUERY 1>"")
                async with driver.session(
                    bookmark_manager=driver.execute_query_bookmark_manager
                ) as session:
                    # every query inside this session will be causally chained
                    # (i.e., can read what was written by <QUERY 1>)
                    await session.run(""<QUERY 2>"")
                # subsequent execute_query calls will be causally chained
                # (i.e., can read what was written by <QUERY 2>)
                await driver.execute_query(""<QUERY 3>"")

        .. versionadded:: 5.5

        .. versionchanged:: 5.8

            * Renamed from ``query_bookmark_manager`` to
              ``execute_query_bookmark_manager``.
            * Stabilized from experimental.
        """"""
        return self._query_bookmark_manager",946,973
open,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,":param target:
:param auth:
:param config: The values that can be specified are found in :class: `neo4j.PoolConfig` and :class: `neo4j.WorkspaceConfig`

:returns:
:rtype: :class: `neo4j.BoltDriver`","def open(cls, target, **config):
        """"""
        :param target:
        :param auth:
        :param config: The values that can be specified are found in :class: `neo4j.PoolConfig` and :class: `neo4j.WorkspaceConfig`

        :returns:
        :rtype: :class: `neo4j.BoltDriver`
        """"""
        from .io import AsyncBoltPool
        address = cls.parse_target(target)
        pool_config, default_workspace_config = Config.consume_chain(config, AsyncPoolConfig, WorkspaceConfig)
        pool = AsyncBoltPool.open(address, pool_config=pool_config, workspace_config=default_workspace_config)
        return cls(pool, default_workspace_config)",1282,1295
driver,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"Create a driver.

:param uri: the connection URI for the driver,
    see :ref:`async-uri-ref` for available URIs.
:param auth: the authentication details,
    see :ref:`auth-ref` for available authentication details.
:param config: driver configuration key-word arguments,
    see :ref:`async-driver-configuration-ref` for available
    key-word arguments.","def driver(
            cls,
            uri: str,
            *,
            auth: t.Union[_TAuth, AsyncAuthManager] = None,
            **config
        ) -> AsyncDriver:
            """"""Create a driver.

            :param uri: the connection URI for the driver,
                see :ref:`async-uri-ref` for available URIs.
            :param auth: the authentication details,
                see :ref:`auth-ref` for available authentication details.
            :param config: driver configuration key-word arguments,
                see :ref:`async-driver-configuration-ref` for available
                key-word arguments.
            """"""

            driver_type, security_type, parsed = parse_neo4j_uri(uri)

            if not isinstance(auth, AsyncAuthManager):
                auth = AsyncAuthManagers.static(auth)
            config[""auth""] = auth

            client_certificate = config.get(""client_certificate"")
            if isinstance(client_certificate, ClientCertificate):
                # using internal class until public factory is GA:
                # AsyncClientCertificateProviders.static
                config[""client_certificate""] = \
                    _AsyncStaticClientCertificateProvider(client_certificate)
            if client_certificate is not None:
                preview_warn(""Mutual TLS is a preview feature."",
                             stack_level=2)

            # TODO: 6.0 - remove ""trust"" config option
            if ""trust"" in config.keys():
                if config[""trust""] not in (
                    TRUST_ALL_CERTIFICATES,
                    TRUST_SYSTEM_CA_SIGNED_CERTIFICATES
                ):
                    raise ConfigurationError(
                        ""The config setting `trust` values are {!r}""
                        .format(
                            [
                                TRUST_ALL_CERTIFICATES,
                                TRUST_SYSTEM_CA_SIGNED_CERTIFICATES,
                            ]
                        )
                    )

            if (""trusted_certificates"" in config.keys()
                and not isinstance(config[""trusted_certificates""],
                                   TrustStore)):
                raise ConfigurationError(
                    'The config setting ""trusted_certificates"" must be of '
                    ""type neo4j.TrustAll, neo4j.TrustCustomCAs, or""
                    ""neo4j.TrustSystemCAs but was {}"".format(
                        type(config[""trusted_certificates""])
                    )
                )

            if (security_type in (SECURITY_TYPE_SELF_SIGNED_CERTIFICATE,
                                  SECURITY_TYPE_SECURE)
                and (""encrypted"" in config
                     or ""trust"" in config
                     or ""trusted_certificates"" in config
                     or ""ssl_context"" in config)):

                # TODO: 6.0 - remove ""trust"" from error message
                raise ConfigurationError(
                    'The config settings ""encrypted"", ""trust"", '
                    '""trusted_certificates"", and ""ssl_context"" can only be '
                    ""used with the URI schemes {!r}. Use the other URI ""
                    ""schemes {!r} for setting encryption settings.""
                    .format(
                        [
                            URI_SCHEME_BOLT,
                            URI_SCHEME_NEO4J,
                        ],
                        [
                            URI_SCHEME_BOLT_SELF_SIGNED_CERTIFICATE,
                            URI_SCHEME_BOLT_SECURE,
                            URI_SCHEME_NEO4J_SELF_SIGNED_CERTIFICATE,
                            URI_SCHEME_NEO4J_SECURE,
                        ]
                    )
                )

            if security_type == SECURITY_TYPE_SECURE:
                config[""encrypted""] = True
            elif security_type == SECURITY_TYPE_SELF_SIGNED_CERTIFICATE:
                config[""encrypted""] = True
                config[""trusted_certificates""] = TrustAll()
            if ""warn_notification_severity"" in config:
                preview_warn(""notification warnings are a preview feature."",
                             stack_level=2)
            _normalize_notifications_config(config, driver_level=True)
            liveness_check_timeout = config.get(""liveness_check_timeout"")
            if (
                liveness_check_timeout is not None
                and liveness_check_timeout < 0
            ):
                raise ConfigurationError(
                    'The config setting ""liveness_check_timeout"" must be '
                    ""greater than or equal to 0 but was ""
                    f""{liveness_check_timeout}.""
                )

            assert driver_type in (DRIVER_BOLT, DRIVER_NEO4J)
            if driver_type == DRIVER_BOLT:
                if parse_routing_context(parsed.query):
                    deprecation_warn(
                        'Creating a direct driver (""bolt://"" scheme) with '
                        ""routing context (URI parameters) is deprecated. They ""
                        ""will be ignored. This will raise an error in a ""
                        'future release. Given URI ""{}""'.format(uri),
                        stack_level=2
                    )
                    # TODO: 6.0 - raise instead of warning
                    # raise ValueError(
                    #     'Routing parameters are not supported with scheme '
                    #     '""bolt"". Given URI ""{}"".'.format(uri)
                    # )
                return cls.bolt_driver(parsed.netloc, **config)
            # else driver_type == DRIVER_NEO4J
            routing_context = parse_routing_context(parsed.query)
            return cls.neo4j_driver(parsed.netloc,
                                    routing_context=routing_context, **config)",185,312
session,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/driver.py,"Create a session, see :ref:`async-session-construction-ref`

:param config: session configuration key-word arguments,
    see :ref:`async-session-configuration-ref` for available
    key-word arguments.

:returns: new :class:`neo4j.AsyncSession` object","def session(self, **config) -> AsyncSession:
            """"""Create a session, see :ref:`async-session-construction-ref`

            :param config: session configuration key-word arguments,
                see :ref:`async-session-configuration-ref` for available
                key-word arguments.

            :returns: new :class:`neo4j.AsyncSession` object
            """"""
            if ""warn_notification_severity"" in config:
                # Would work just fine, but we don't want to introduce yet
                # another undocumented/unsupported config option.
                del config[""warn_notification_severity""]
            self._check_state()
            session_config = self._read_session_config(config)
            return self._session(session_config)",583,598
kill_and_release,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_pool.py,"Release connections back into the pool after closing them.

This method is thread safe.","def kill_and_release(self, *connections):
        """""" Release connections back into the pool after closing them.

        This method is thread safe.
        """"""
        for connection in connections:
            if not (connection.defunct()
                    or connection.closed()):
                log.debug(
                    ""[#%04X]  _: <POOL> killing connection on release %s"",
                    connection.local_port, connection.connection_id
                )
                connection.kill()
        with self.lock:
            for connection in connections:
                connection.in_use = False
            self.cond.notify_all()",335,351
in_use_connection_count,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_pool.py,"Count the number of connections currently in use to a given
address.","def in_use_connection_count(self, address):
        """""" Count the number of connections currently in use to a given
        address.
        """"""
        with self.lock:
            connections = self.connections.get(address, ())
            return sum(connection.in_use for connection in connections)",395,401
open,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_pool.py,"Create a new BoltPool

:param address:
:param pool_config:
:param workspace_config:
:returns: BoltPool","def open(cls, address, *, pool_config, workspace_config):
        """"""Create a new BoltPool

        :param address:
        :param pool_config:
        :param workspace_config:
        :returns: BoltPool
        """"""

        async def opener(addr, auth_manager, deadline):
            return await AsyncBolt.open(
                addr, auth_manager=auth_manager, deadline=deadline,
                routing_context=None, pool_config=pool_config
            )

        pool = cls(opener, pool_config, workspace_config, address)
        log.debug(""[#0000]  _: <POOL> created, direct address %r"", address)
        return pool",493,510
open,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_pool.py,"Create a new Neo4jPool

:param addresses: one or more address as positional argument
:param pool_config:
:param workspace_config:
:param routing_context:
:returns: Neo4jPool","def open(cls, *addresses, pool_config, workspace_config,
             routing_context=None):
        """"""Create a new Neo4jPool

        :param addresses: one or more address as positional argument
        :param pool_config:
        :param workspace_config:
        :param routing_context:
        :returns: Neo4jPool
        """"""

        address = addresses[0]
        if routing_context is None:
            routing_context = {}
        elif ""address"" in routing_context:
            raise ConfigurationError(""The key 'address' is reserved for routing context."")
        routing_context[""address""] = str(address)

        async def opener(addr, auth_manager, deadline):
            return await AsyncBolt.open(
                addr, auth_manager=auth_manager, deadline=deadline,
                routing_context=routing_context, pool_config=pool_config
            )

        pool = cls(opener, pool_config, workspace_config, address)
        log.debug(""[#0000]  _: <POOL> created, routing address %r"", address)
        return pool",541,567
__init__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_pool.py,":param opener:
:param pool_config:
:param workspace_config:
:param address:","def __init__(self, opener, pool_config, workspace_config, address):
        """"""

        :param opener:
        :param pool_config:
        :param workspace_config:
        :param address:
        """"""
        super().__init__(opener, pool_config, workspace_config)
        # Each database have a routing table, the default database is a special case.
        self.address = address
        self.routing_tables = {}
        self.refresh_lock = AsyncRLock()
        self.is_direct_pool = False",569,582
__repr__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_pool.py,"The representation shows the initial routing addresses.

:returns: The representation
:rtype: str","def __repr__(self):
        """""" The representation shows the initial routing addresses.

        :returns: The representation
        :rtype: str
        """"""
        return ""<{} address={!r}>"".format(self.__class__.__name__,
                                          self.address)",584,591
check_supported_server_product,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_common.py,"Checks that a server product is supported by the driver by
looking at the server agent string.

:param agent: server agent string to check for validity

:raises UnsupportedServerProduct: if the product is not supported","def check_supported_server_product(agent):
    """""" Checks that a server product is supported by the driver by
    looking at the server agent string.

    :param agent: server agent string to check for validity

    :raises UnsupportedServerProduct: if the product is not supported
    """"""
    if not agent.startswith(""Neo4j/""):
        raise UnsupportedServerProduct(agent)",308,317
__init__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_common.py,":param connection the connection object to warp
:type connection Bolt
:param on_error the function to be called when a method of
    connection raises of of the caught errors.
:type on_error callable","def __init__(self, connection, on_error):
        """"""
        :param connection the connection object to warp
        :type connection Bolt
        :param on_error the function to be called when a method of
            connection raises of of the caught errors.
        :type on_error callable
        """"""
        self.__connection = connection
        self.__on_error = on_error",159,168
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt3.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        self.assert_re_auth_support()",220,222
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt3.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        self.assert_re_auth_support()",224,226
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt4.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        self.assert_re_auth_support()",141,143
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt4.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        self.assert_re_auth_support()",145,147
get_base_headers,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt4.py,"Bolt 4.1 passes the routing context, originally taken from
the URI, into the connection initialisation message. This
enables server-side routing to propagate the same behaviour
through its driver.","def get_base_headers(self):
        """""" Bolt 4.1 passes the routing context, originally taken from
        the URI, into the connection initialisation message. This
        enables server-side routing to propagate the same behaviour
        through its driver.
        """"""
        headers = {
            ""user_agent"": self.user_agent,
        }
        if self.routing_context is not None:
            headers[""routing""] = self.routing_context
        return headers",399,410
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt5.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        self.assert_re_auth_support()",163,165
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt5.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        self.assert_re_auth_support()",167,169
tx_timeout_as_ms,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Round transaction timeout to milliseconds.

Values in (0, 1], else values are rounded using the built-in round()
function (round n.5 values to nearest even).

:param timeout: timeout in seconds (must be >= 0)

:returns: timeout in milliseconds (rounded)

:raise ValueError: if timeout is negative","def tx_timeout_as_ms(timeout: float) -> int:
    """"""Round transaction timeout to milliseconds.

    Values in (0, 1], else values are rounded using the built-in round()
    function (round n.5 values to nearest even).

    :param timeout: timeout in seconds (must be >= 0)

    :returns: timeout in milliseconds (rounded)

    :raise ValueError: if timeout is negative
    """"""
    try:
        timeout = float(timeout)
    except (TypeError, ValueError) as e:
        err_type = type(e)
        msg = ""Timeout must be specified as a number of seconds""
        raise err_type(msg) from None
    if timeout < 0:
        raise ValueError(""Timeout must be a positive number or 0."")
    ms = int(round(1000 * timeout))
    if ms == 0 and timeout > 0:
        # Special case for 0 < timeout < 0.5 ms.
        # This would be rounded to 0 ms, but the server interprets this as
        # infinite timeout. So we round to the smallest possible timeout: 1 ms.
        ms = 1
    return ms",993,1019
supports_multiple_results,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Boolean flag to indicate if the connection version supports multiple
queries to be buffered on the server side (True) or if all results need
to be eagerly pulled before sending the next RUN (False).","def supports_multiple_results(self):
        """""" Boolean flag to indicate if the connection version supports multiple
        queries to be buffered on the server side (True) or if all results need
        to be eagerly pulled before sending the next RUN (False).
        """"""
        pass",213,218
supports_multiple_databases,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Boolean flag to indicate if the connection version supports multiple
databases.","def supports_multiple_databases(self):
        """""" Boolean flag to indicate if the connection version supports multiple
        databases.
        """"""
        pass",222,226
supports_re_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,Whether the connection version supports re-authentication.,"def supports_re_auth(self):
        """"""Whether the connection version supports re-authentication.""""""
        pass",230,232
supports_notification_filtering,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,Whether the connection version supports re-authentication.,"def supports_notification_filtering(self):
        """"""Whether the connection version supports re-authentication.""""""
        pass",244,246
protocol_handlers,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Return a dictionary of available Bolt protocol handlers,
keyed by version tuple. If an explicit protocol version is
provided, the dictionary will contain either zero or one items,
depending on whether that version is supported. If no protocol
version is provided, all available versions will be returned.

:param protocol_version: tuple identifying a specific protocol
    version (e.g. (3, 5)) or None
:returns: dictionary of version tuple to handler class for all
    relevant and supported protocol versions
:raise TypeError: if protocol version is not passed in a tuple","def protocol_handlers(cls, protocol_version=None):
        """""" Return a dictionary of available Bolt protocol handlers,
        keyed by version tuple. If an explicit protocol version is
        provided, the dictionary will contain either zero or one items,
        depending on whether that version is supported. If no protocol
        version is provided, all available versions will be returned.

        :param protocol_version: tuple identifying a specific protocol
            version (e.g. (3, 5)) or None
        :returns: dictionary of version tuple to handler class for all
            relevant and supported protocol versions
        :raise TypeError: if protocol version is not passed in a tuple
        """"""

        # Carry out Bolt subclass imports locally to avoid circular dependency issues.
        from ._bolt3 import AsyncBolt3
        from ._bolt4 import (
            AsyncBolt4x1,
            AsyncBolt4x2,
            AsyncBolt4x3,
            AsyncBolt4x4,
        )
        from ._bolt5 import (
            AsyncBolt5x0,
            AsyncBolt5x1,
            AsyncBolt5x2,
            AsyncBolt5x3,
            AsyncBolt5x4,
        )

        handlers = {
            AsyncBolt3.PROTOCOL_VERSION: AsyncBolt3,
            # 4.0 unsupported because no space left in the handshake
            AsyncBolt4x1.PROTOCOL_VERSION: AsyncBolt4x1,
            AsyncBolt4x2.PROTOCOL_VERSION: AsyncBolt4x2,
            AsyncBolt4x3.PROTOCOL_VERSION: AsyncBolt4x3,
            AsyncBolt4x4.PROTOCOL_VERSION: AsyncBolt4x4,
            AsyncBolt5x0.PROTOCOL_VERSION: AsyncBolt5x0,
            AsyncBolt5x1.PROTOCOL_VERSION: AsyncBolt5x1,
            AsyncBolt5x2.PROTOCOL_VERSION: AsyncBolt5x2,
            AsyncBolt5x3.PROTOCOL_VERSION: AsyncBolt5x3,
            AsyncBolt5x4.PROTOCOL_VERSION: AsyncBolt5x4,
        }

        if protocol_version is None:
            return handlers

        if not isinstance(protocol_version, tuple):
            raise TypeError(""Protocol version must be specified as a tuple"")

        if protocol_version in handlers:
            return {protocol_version: handlers[protocol_version]}

        return {}",258,311
version_list,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Return a list of supported protocol versions in order of
preference. The number of protocol versions (or ranges)
returned is limited to four.","def version_list(cls, versions, limit=4):
        """""" Return a list of supported protocol versions in order of
        preference. The number of protocol versions (or ranges)
        returned is limited to four.
        """"""
        # In fact, 4.3 is the fist version to support ranges. However, the
        # range support got backported to 4.2. But even if the server is too
        # old to have the backport, negotiating BOLT 4.1 is no problem as it's
        # equivalent to 4.2
        first_with_range_support = Version(4, 2)
        result = []
        for version in versions:
            if (result
                    and version >= first_with_range_support
                    and result[-1][0] == version[0]
                    and result[-1][1][1] == version[1] + 1):
                # can use range to encompass this version
                result[-1][1][1] = version[1]
                continue
            result.append(Version(version[0], [version[1], version[1]]))
            if len(result) == 4:
                break
        return result",314,336
get_handshake,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Return the supported Bolt versions as bytes.
The length is 16 bytes as specified in the Bolt version negotiation.
:returns: bytes","def get_handshake(cls):
        """""" Return the supported Bolt versions as bytes.
        The length is 16 bytes as specified in the Bolt version negotiation.
        :returns: bytes
        """"""
        supported_versions = sorted(cls.protocol_handlers().keys(), reverse=True)
        offered_versions = cls.version_list(supported_versions)
        return b"""".join(version.to_bytes() for version in offered_versions).ljust(16, b""\x00"")",339,346
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        pass",529,531
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        pass",534,536
mark_unauthenticated,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,Mark the connection as unauthenticated.,"def mark_unauthenticated(self):
        """"""Mark the connection as unauthenticated.""""""
        self.auth_dict = {}",538,540
re_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Append LOGON, LOGOFF to the outgoing queue.

If auth is the same as the current auth, this method does nothing.

:returns: whether the auth was changed","def re_auth(
        self, auth, auth_manager, force=False,
        dehydration_hooks=None, hydration_hooks=None,
    ):
        """"""Append LOGON, LOGOFF to the outgoing queue.

        If auth is the same as the current auth, this method does nothing.

        :returns: whether the auth was changed
        """"""
        new_auth_dict = self._to_auth_dict(auth)
        if not force and new_auth_dict == self.auth_dict:
            self.auth_manager = auth_manager
            self.auth = auth
            return False
        self.logoff(dehydration_hooks=dehydration_hooks,
                     hydration_hooks=hydration_hooks)
        self.auth_dict = new_auth_dict
        self.auth_manager = auth_manager
        self.auth = auth
        self.logon(dehydration_hooks=dehydration_hooks,
                    hydration_hooks=hydration_hooks)
        return True",542,564
telemetry,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Send telemetry information about the API usage to the server.

:param api: the API used.
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def telemetry(self, api: TelemetryAPI, dehydration_hooks=None,
                  hydration_hooks=None, **handlers) -> None:
        """"""Send telemetry information about the API usage to the server.

        :param api: the API used.
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",595,609
run,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Appends a RUN message to the output queue.

:param query: Cypher query string
:param parameters: dictionary of Cypher parameters
:param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
:param bookmarks: iterable of bookmark values after which this transaction should begin
:param metadata: custom metadata dictionary to attach to the transaction
:param timeout: timeout for transaction execution (seconds)
:param db: name of the database against which to begin the transaction
    Requires Bolt 4.0+.
:param imp_user: the user to impersonate
    Requires Bolt 4.4+.
:param notifications_min_severity:
    minimum severity of notifications to be received.
    Requires Bolt 5.2+.
:param notifications_disabled_categories:
    list of notification categories to be disabled.
    Requires Bolt 5.2+.
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object","def run(self, query, parameters=None, mode=None, bookmarks=None,
            metadata=None, timeout=None, db=None, imp_user=None,
            notifications_min_severity=None,
            notifications_disabled_categories=None, dehydration_hooks=None,
            hydration_hooks=None, **handlers):
        """""" Appends a RUN message to the output queue.

        :param query: Cypher query string
        :param parameters: dictionary of Cypher parameters
        :param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
        :param bookmarks: iterable of bookmark values after which this transaction should begin
        :param metadata: custom metadata dictionary to attach to the transaction
        :param timeout: timeout for transaction execution (seconds)
        :param db: name of the database against which to begin the transaction
            Requires Bolt 4.0+.
        :param imp_user: the user to impersonate
            Requires Bolt 4.4+.
        :param notifications_min_severity:
            minimum severity of notifications to be received.
            Requires Bolt 5.2+.
        :param notifications_disabled_categories:
            list of notification categories to be disabled.
            Requires Bolt 5.2+.
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        """"""
        pass",612,645
discard,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Appends a DISCARD message to the output queue.

:param n: number of records to discard, default = -1 (ALL)
:param qid: query ID to discard for, default = -1 (last query)
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object","def discard(self, n=-1, qid=-1, dehydration_hooks=None,
                hydration_hooks=None, **handlers):
        """""" Appends a DISCARD message to the output queue.

        :param n: number of records to discard, default = -1 (ALL)
        :param qid: query ID to discard for, default = -1 (last query)
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        """"""
        pass",648,664
pull,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Appends a PULL message to the output queue.

:param n: number of records to pull, default = -1 (ALL)
:param qid: query ID to pull for, default = -1 (last query)
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object","def pull(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None,
             **handlers):
        """""" Appends a PULL message to the output queue.

        :param n: number of records to pull, default = -1 (ALL)
        :param qid: query ID to pull for, default = -1 (last query)
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        """"""
        pass",667,683
begin,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Appends a BEGIN message to the output queue.

:param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
:param bookmarks: iterable of bookmark values after which this transaction should begin
:param metadata: custom metadata dictionary to attach to the transaction
:param timeout: timeout for transaction execution (seconds)
:param db: name of the database against which to begin the transaction
    Requires Bolt 4.0+.
:param imp_user: the user to impersonate
    Requires Bolt 4.4+
:param notifications_min_severity:
    minimum severity of notifications to be received.
    Requires Bolt 5.2+.
:param notifications_disabled_categories:
    list of notification categories to be disabled.
    Requires Bolt 5.2+.
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object
:returns: Response object","def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,
              db=None, imp_user=None, notifications_min_severity=None,
              notifications_disabled_categories=None, dehydration_hooks=None,
              hydration_hooks=None, **handlers):
        """""" Appends a BEGIN message to the output queue.

        :param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
        :param bookmarks: iterable of bookmark values after which this transaction should begin
        :param metadata: custom metadata dictionary to attach to the transaction
        :param timeout: timeout for transaction execution (seconds)
        :param db: name of the database against which to begin the transaction
            Requires Bolt 4.0+.
        :param imp_user: the user to impersonate
            Requires Bolt 4.4+
        :param notifications_min_severity:
            minimum severity of notifications to be received.
            Requires Bolt 5.2+.
        :param notifications_disabled_categories:
            list of notification categories to be disabled.
            Requires Bolt 5.2+.
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        :returns: Response object
        """"""
        pass",686,717
commit,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Appends a COMMIT message to the output queue.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def commit(self, dehydration_hooks=None, hydration_hooks=None, **handlers):
        """""" Appends a COMMIT message to the output queue.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",720,732
rollback,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Appends a ROLLBACK message to the output queue.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def rollback(self, dehydration_hooks=None, hydration_hooks=None, **handlers):
        """""" Appends a ROLLBACK message to the output queue.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.""""""
        pass",735,746
goodbye,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Append a GOODBYE message to the outgoing queue.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def goodbye(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a GOODBYE message to the outgoing queue.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",765,777
_append,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Appends a message to the outgoing queue.

:param signature: the signature of the message
:param fields: the fields of the message as a tuple
:param response: a response object to handle callbacks
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.","def _append(self, signature, fields=(), response=None,
                dehydration_hooks=None):
        """""" Appends a message to the outgoing queue.

        :param signature: the signature of the message
        :param fields: the fields of the message as a tuple
        :param response: a response object to handle callbacks
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        """"""
        self.outbox.append_message(signature, fields, dehydration_hooks)
        self.responses.append(response)
        if response:
            self._get_client_state_manager().transition(response.message)",782,797
kill,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Close the socket most violently. No flush, no goodbye, no mercy.","def kill(self):
        """"""Close the socket most violently. No flush, no goodbye, no mercy.""""""
        if self._closed:
            return
        log.debug(""[#%04X]  C: <KILL>"", self.local_port)
        self._closing = True
        try:
            self.socket.kill()
        except OSError as exc:
            log.debug(""[#%04X]  _: <CONNECTION> ignoring failed kill %r"",
                      self.local_port, exc)
        finally:
            self._closed = True",959,971
is_idle_for,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/io/_bolt.py,"Check if connection has been idle for at least the given timeout.

:param timeout: timeout in seconds
:type timeout: float

:rtype: bool","def is_idle_for(self, timeout):
        """"""Check if connection has been idle for at least the given timeout.

        :param timeout: timeout in seconds
        :type timeout: float

        :rtype: bool
        """"""
        return monotonic() - self.idle_since > timeout",979,987
closed,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/work/transaction.py,"Indicate whether the transaction has been closed or cancelled.

:returns:
    :data:`True` if closed or cancelled, :data:`False` otherwise.
:rtype: bool","def closed(self) -> bool:
        """"""Indicate whether the transaction has been closed or cancelled.

        :returns:
            :data:`True` if closed or cancelled, :data:`False` otherwise.
        :rtype: bool
        """"""
        return self._closed()",288,295
cancel,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/work/transaction.py,"Cancel this transaction.

If the transaction is already closed, this method does nothing.
Else, it will close the connection without ROLLBACK or COMMIT in
a non-blocking manner.

The primary purpose of this function is to handle
:class:`asyncio.CancelledError`.

::

    tx = await session.begin_transaction()
    try:
        ...  # do some work
    except asyncio.CancelledError:
        tx.cancel()
        raise","def cancel(self) -> None:
            """"""Cancel this transaction.

            If the transaction is already closed, this method does nothing.
            Else, it will close the connection without ROLLBACK or COMMIT in
            a non-blocking manner.

            The primary purpose of this function is to handle
            :class:`asyncio.CancelledError`.

            ::

                tx = await session.begin_transaction()
                try:
                    ...  # do some work
                except asyncio.CancelledError:
                    tx.cancel()
                    raise

            """"""
            return self._cancel()",298,318
cancel,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/work/session.py,"Cancel this session.

If the session is already closed, this method does nothing.
Else, it will if present, forcefully close the connection the
session holds. This will violently kill all work in flight.

The primary purpose of this function is to handle
:class:`asyncio.CancelledError`.

::

    session = driver.session()
    try:
        ...  # do some work
    except asyncio.CancelledError:
        session.cancel()
        raise","def cancel(self) -> None:
            """"""Cancel this session.

            If the session is already closed, this method does nothing.
            Else, it will if present, forcefully close the connection the
            session holds. This will violently kill all work in flight.

            The primary purpose of this function is to handle
            :class:`asyncio.CancelledError`.

            ::

                session = driver.session()
                try:
                    ...  # do some work
                except asyncio.CancelledError:
                    session.cancel()
                    raise

            """"""
            self._handle_cancellation(message=""manual cancel"")",230,250
_obtain_summary,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/work/result.py,"Obtain the summary of this result.

:returns: The :class:`neo4j.ResultSummary` for this result","def _obtain_summary(self) -> ResultSummary:
        """"""Obtain the summary of this result.

        :returns: The :class:`neo4j.ResultSummary` for this result
        """"""
        if self._summary is None:
            self._summary = ResultSummary(self._address, **self._metadata)
        return self._summary",438,445
keys,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/work/result.py,"The keys for the records in this result.

:returns: tuple of key names
:rtype: tuple","def keys(self) -> t.Tuple[str, ...]:
        """"""The keys for the records in this result.

        :returns: tuple of key names
        :rtype: tuple
        """"""
        return self._keys",447,453
closed,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/work/result.py,"Return True if the result has been closed.

When a result gets consumed :meth:`consume` or the transaction that
owns the result gets closed (committed, rolled back, closed), the
result cannot be used to acquire further records.

In such case, all methods that need to access the Result's records,
will raise a :exc:`.ResultConsumedError` when called.

:returns: whether the result is closed.

.. versionadded:: 5.0","def closed(self) -> bool:
        """"""Return True if the result has been closed.

        When a result gets consumed :meth:`consume` or the transaction that
        owns the result gets closed (committed, rolled back, closed), the
        result cannot be used to acquire further records.

        In such case, all methods that need to access the Result's records,
        will raise a :exc:`.ResultConsumedError` when called.

        :returns: whether the result is closed.

        .. versionadded:: 5.0
        """"""
        return self._out_of_scope or self._consumed",908,922
closed,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_async/work/workspace.py,"Indicate whether the session has been closed.

:returns: :data:`True` if closed, :data:`False` otherwise.","def closed(self) -> bool:
        """"""Indicate whether the session has been closed.

        :returns: :data:`True` if closed, :data:`False` otherwise.
        """"""
        return self._closed",205,210
nodes,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"Access a set view of the nodes in this graph.
        ","def nodes(self) -> EntitySetView[Node]:
        """""" Access a set view of the nodes in this graph.
        """"""
        return self._node_set_view",65,68
relationships,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"Access a set view of the relationships in this graph.
        ","def relationships(self) -> EntitySetView[Relationship]:
        """""" Access a set view of the relationships in this graph.
        """"""
        return self._relationship_set_view",71,74
relationship_type,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"Obtain a :class:`.Relationship` subclass for a given
relationship type name.","def relationship_type(self, name: str) -> t.Type[Relationship]:
        """""" Obtain a :class:`.Relationship` subclass for a given
        relationship type name.
        """"""
        try:
            cls = self._relationship_types[name]
        except KeyError:
            cls = self._relationship_types[name] = t.cast(
                t.Type[Relationship],
                type(str(name), (Relationship,), {})
            )
        return cls",76,87
graph,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The :class:`.Graph` to which this entity belongs.
        ","def graph(self) -> Graph:
        """""" The :class:`.Graph` to which this entity belongs.
        """"""
        return self._graph",137,140
id,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The legacy identity of this entity in its container :class:`.Graph`.

Depending on the version of the server this entity was retrieved from,
this may be empty (None).

.. warning::
    This value can change for the same entity across multiple
    transactions. Don't rely on it for cross-transactional
    computations.

.. deprecated:: 5.0
    Use :attr:`.element_id` instead.","def id(self) -> int:
        """"""The legacy identity of this entity in its container :class:`.Graph`.

        Depending on the version of the server this entity was retrieved from,
        this may be empty (None).

        .. warning::
            This value can change for the same entity across multiple
            transactions. Don't rely on it for cross-transactional
            computations.

        .. deprecated:: 5.0
            Use :attr:`.element_id` instead.
        """"""
        return self._id",144,158
element_id,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The identity of this entity in its container :class:`.Graph`.

.. warning::
    This value can change for the same entity across multiple
    transactions. Don't rely on it for cross-transactional
    computations.

.. versionadded:: 5.0","def element_id(self) -> str:
        """"""The identity of this entity in its container :class:`.Graph`.

        .. warning::
            This value can change for the same entity across multiple
            transactions. Don't rely on it for cross-transactional
            computations.

        .. versionadded:: 5.0
        """"""
        return self._element_id",161,171
get,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"Get a property value by name, optionally with a default.
        ","def get(self, name: str, default: t.Optional[object] = None) -> t.Any:
        """""" Get a property value by name, optionally with a default.
        """"""
        return self._properties.get(name, default)",173,176
keys,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"Return an iterable of all property names.
        ","def keys(self) -> t.KeysView[str]:
        """""" Return an iterable of all property names.
        """"""
        return self._properties.keys()",178,181
values,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"Return an iterable of all property values.
        ","def values(self) -> t.ValuesView[t.Any]:
        """""" Return an iterable of all property values.
        """"""
        return self._properties.values()",183,186
items,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"Return an iterable of all property name-value pairs.
        ","def items(self) -> t.ItemsView[str, t.Any]:
        """""" Return an iterable of all property name-value pairs.
        """"""
        return self._properties.items()",188,191
labels,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The set of labels attached to this node.
        ","def labels(self) -> t.FrozenSet[str]:
        """""" The set of labels attached to this node.
        """"""
        return self._labels",243,246
nodes,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The pair of nodes which this relationship connects.
        ","def nodes(self) -> t.Tuple[t.Optional[Node], t.Optional[Node]]:
        """""" The pair of nodes which this relationship connects.
        """"""
        return self._start_node, self._end_node",270,273
start_node,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The start node of this relationship.
        ","def start_node(self) -> t.Optional[Node]:
        """""" The start node of this relationship.
        """"""
        return self._start_node",276,279
end_node,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The end node of this relationship.
        ","def end_node(self) -> t.Optional[Node]:
        """""" The end node of this relationship.
        """"""
        return self._end_node",282,285
type,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The type name of this relationship.
This is functionally equivalent to ``type(relationship).__name__``.","def type(self) -> str:
        """""" The type name of this relationship.
        This is functionally equivalent to ``type(relationship).__name__``.
        """"""
        return type(self).__name__",288,292
graph,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The :class:`.Graph` to which this path belongs.
        ","def graph(self) -> Graph:
        """""" The :class:`.Graph` to which this path belongs.
        """"""
        return self._nodes[0].graph",339,342
nodes,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The sequence of :class:`.Node` objects in this path.
        ","def nodes(self) -> t.Tuple[Node, ...]:
        """""" The sequence of :class:`.Node` objects in this path.
        """"""
        return self._nodes",345,348
start_node,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The first :class:`.Node` in this path.
        ","def start_node(self) -> Node:
        """""" The first :class:`.Node` in this path.
        """"""
        return self._nodes[0]",351,354
end_node,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The last :class:`.Node` in this path.
        ","def end_node(self) -> Node:
        """""" The last :class:`.Node` in this path.
        """"""
        return self._nodes[-1]",357,360
relationships,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/graph/__init__.py,"The sequence of :class:`.Relationship` objects in this path.
        ","def relationships(self) -> t.Tuple[Relationship, ...]:
        """""" The sequence of :class:`.Relationship` objects in this path.
        """"""
        return self._relationships",363,366
_normalize_day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Coerce the day of the month to an internal value that may or
may not match the ""public"" value.

With the exception of the last three days of every month, all
days are stored as-is. The last three days are instead stored
as -1 (the last), -2 (the second to last) and -3 (the third to
last).

Therefore, for a 28-day month, the last week is as follows:

    Day   | 22 23 24 25 26 27 28
    Value | 22 23 24 25 -3 -2 -1

For a 29-day month, the last week is as follows:

    Day   | 23 24 25 26 27 28 29
    Value | 23 24 25 26 -3 -2 -1

For a 30-day month, the last week is as follows:

    Day   | 24 25 26 27 28 29 30
    Value | 24 25 26 27 -3 -2 -1

For a 31-day month, the last week is as follows:

    Day   | 25 26 27 28 29 30 31
    Value | 25 26 27 28 -3 -2 -1

This slightly unintuitive system makes some temporal arithmetic
produce a more desirable outcome.

:param year:
:param month:
:param day:
:returns:","def _normalize_day(year, month, day):
    """""" Coerce the day of the month to an internal value that may or
    may not match the ""public"" value.

    With the exception of the last three days of every month, all
    days are stored as-is. The last three days are instead stored
    as -1 (the last), -2 (the second to last) and -3 (the third to
    last).

    Therefore, for a 28-day month, the last week is as follows:

        Day   | 22 23 24 25 26 27 28
        Value | 22 23 24 25 -3 -2 -1

    For a 29-day month, the last week is as follows:

        Day   | 23 24 25 26 27 28 29
        Value | 23 24 25 26 -3 -2 -1

    For a 30-day month, the last week is as follows:

        Day   | 24 25 26 27 28 29 30
        Value | 24 25 26 27 -3 -2 -1

    For a 31-day month, the last week is as follows:

        Day   | 25 26 27 28 29 30 31
        Value | 25 26 27 28 -3 -2 -1

    This slightly unintuitive system makes some temporal arithmetic
    produce a more desirable outcome.

    :param year:
    :param month:
    :param day:
    :returns:
    """"""
    if year < MIN_YEAR or year > MAX_YEAR:
        raise ValueError(""Year out of range (%d..%d)"" % (MIN_YEAR, MAX_YEAR))
    if month < 1 or month > 12:
        raise ValueError(""Month out of range (1..12)"")
    days_in_month = DAYS_IN_MONTH[(year, month)]
    if day in (days_in_month, -1):
        return year, month, -1
    if day in (days_in_month - 1, -2):
        return year, month, -2
    if day in (days_in_month - 2, -3):
        return year, month, -3
    if 1 <= day <= days_in_month - 3:
        return year, month, int(day)
    # TODO improve this error message
    raise ValueError(""Day %d out of range (1..%d, -1, -2 ,-3)"" % (day, days_in_month))",138,189
precision,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The precision of this clock implementation, represented as a
number of decimal places. Therefore, for a nanosecond precision
clock, this function returns `9`.","def precision(cls):
        """""" The precision of this clock implementation, represented as a
        number of decimal places. Therefore, for a nanosecond precision
        clock, this function returns `9`.
        """"""
        raise NotImplementedError(""No clock implementation selected"")",279,284
available,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"A boolean flag to indicate whether or not this clock
implementation is available on this platform.","def available(cls):
        """""" A boolean flag to indicate whether or not this clock
        implementation is available on this platform.
        """"""
        raise NotImplementedError(""No clock implementation selected"")",287,291
local_offset,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The offset from UTC for local time read from this clock.
This may raise OverflowError if not supported, because of platform depending C libraries.

:returns:
:rtype:

:raises OverflowError:","def local_offset(cls):
        """"""The offset from UTC for local time read from this clock.
        This may raise OverflowError if not supported, because of platform depending C libraries.

        :returns:
        :rtype:

        :raises OverflowError:
        """"""
        # Adding and subtracting two days to avoid passing a pre-epoch time to
        # `mktime`, which can cause a `OverflowError` on some platforms (e.g.,
        # Windows).
        return ClockTime(-int(mktime(gmtime(172800))) + 172800)",294,306
local_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Read and return the current local time from this clock, measured relative to the Unix Epoch.
This may raise OverflowError if not supported, because of platform depending C libraries.

:returns:
:rtype:

:raises OverflowError:","def local_time(self):
        """""" Read and return the current local time from this clock, measured relative to the Unix Epoch.
        This may raise OverflowError if not supported, because of platform depending C libraries.

        :returns:
        :rtype:

        :raises OverflowError:
        """"""
        return self.utc_time() + self.local_offset()",308,317
utc_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Read and return the current UTC time from this clock, measured
relative to the Unix Epoch.","def utc_time(self):
        """""" Read and return the current UTC time from this clock, measured
        relative to the Unix Epoch.
        """"""
        raise NotImplementedError(""No clock implementation selected"")",319,323
__bool__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Falsy if all primary instance attributes are.,"def __bool__(self) -> bool:
        """"""Falsy if all primary instance attributes are.""""""
        return any(map(bool, self))",418,420
__add__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Add a :class:`.Duration` or :class:`datetime.timedelta`.,"def __add__(  # type: ignore[override]
        self, other: t.Union[Duration, timedelta]
    ) -> Duration:
        """"""Add a :class:`.Duration` or :class:`datetime.timedelta`.""""""
        if isinstance(other, Duration):
            return Duration(
                months=self[0] + int(other.months),
                days=self[1] + int(other.days),
                seconds=self[2] + int(other.seconds),
                nanoseconds=self[3] + int(other.nanoseconds)
            )
        if isinstance(other, timedelta):
            return Duration(
                months=self[0], days=self[1] + other.days,
                seconds=self[2] + other.seconds,
                nanoseconds=self[3] + other.microseconds * 1000
            )
        return NotImplemented",424,441
__sub__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Subtract a :class:`.Duration` or :class:`datetime.timedelta`.,"def __sub__(self, other: t.Union[Duration, timedelta]) -> Duration:
        """"""Subtract a :class:`.Duration` or :class:`datetime.timedelta`.""""""
        if isinstance(other, Duration):
            return Duration(
                months=self[0] - int(other.months),
                days=self[1] - int(other.days),
                seconds=self[2] - int(other.seconds),
                nanoseconds=self[3] - int(other.nanoseconds)
            )
        if isinstance(other, timedelta):
            return Duration(
                months=self[0],
                days=self[1] - other.days,
                seconds=self[2] - other.seconds,
                nanoseconds=self[3] - other.microseconds * 1000
            )
        return NotImplemented",443,459
__mul__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Multiply by an :class:`int` or :class:`float`.

The operation is performed element-wise on
``(months, days, nanaoseconds)`` where

* years go into months,
* weeks go into days,
* seconds and all sub-second units go into nanoseconds.

Each element will be rounded to the nearest integer (.5 towards even).","def __mul__(self, other: float) -> Duration:  # type: ignore[override]
        """"""Multiply by an :class:`int` or :class:`float`.

        The operation is performed element-wise on
        ``(months, days, nanaoseconds)`` where

        * years go into months,
        * weeks go into days,
        * seconds and all sub-second units go into nanoseconds.

        Each element will be rounded to the nearest integer (.5 towards even).
        """"""
        if isinstance(other, (int, float)):
            return Duration(
                months=round_half_to_even(self[0] * other),
                days=round_half_to_even(self[1] * other),
                nanoseconds=round_half_to_even(
                    self[2] * NANO_SECONDS * other
                    + self[3] * other
                )
            )
        return NotImplemented",461,482
__floordiv__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Integer division by an :class:`int`.

The operation is performed element-wise on
``(months, days, nanaoseconds)`` where

* years go into months,
* weeks go into days,
* seconds and all sub-second units go into nanoseconds.

Each element will be rounded towards -inf.","def __floordiv__(self, other: int) -> Duration:  # type: ignore[override]
        """"""Integer division by an :class:`int`.

        The operation is performed element-wise on
        ``(months, days, nanaoseconds)`` where

        * years go into months,
        * weeks go into days,
        * seconds and all sub-second units go into nanoseconds.

        Each element will be rounded towards -inf.
        """"""
        if isinstance(other, int):
            return Duration(
                months=self[0] // other, days=self[1] // other,
                nanoseconds=(self[2] * NANO_SECONDS + self[3]) // other
            )
        return NotImplemented",484,501
__mod__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Modulo operation by an :class:`int`.

The operation is performed element-wise on
``(months, days, nanaoseconds)`` where

* years go into months,
* weeks go into days,
* seconds and all sub-second units go into nanoseconds.","def __mod__(self, other: int) -> Duration:  # type: ignore[override]
        """"""Modulo operation by an :class:`int`.

        The operation is performed element-wise on
        ``(months, days, nanaoseconds)`` where

        * years go into months,
        * weeks go into days,
        * seconds and all sub-second units go into nanoseconds.
        """"""
        if isinstance(other, int):
            return Duration(
                months=self[0] % other, days=self[1] % other,
                nanoseconds=(self[2] * NANO_SECONDS + self[3]) % other
            )
        return NotImplemented",503,518
__divmod__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Division and modulo operation by an :class:`int`.

See :meth:`__floordiv__` and :meth:`__mod__`.","def __divmod__(  # type: ignore[override]
        self, other: int
    ) -> t.Tuple[Duration, Duration]:
        """"""Division and modulo operation by an :class:`int`.

        See :meth:`__floordiv__` and :meth:`__mod__`.
        """"""
        if isinstance(other, int):
            return self.__floordiv__(other), self.__mod__(other)
        return NotImplemented",520,529
__truediv__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Division by an :class:`int` or :class:`float`.

The operation is performed element-wise on
``(months, days, nanaoseconds)`` where

* years go into months,
* weeks go into days,
* seconds and all sub-second units go into nanoseconds.

Each element will be rounded to the nearest integer (.5 towards even).","def __truediv__(self, other: float) -> Duration:  # type: ignore[override]
        """"""Division by an :class:`int` or :class:`float`.

        The operation is performed element-wise on
        ``(months, days, nanaoseconds)`` where

        * years go into months,
        * weeks go into days,
        * seconds and all sub-second units go into nanoseconds.

        Each element will be rounded to the nearest integer (.5 towards even).
        """"""
        if isinstance(other, (int, float)):
            return Duration(
                months=round_half_to_even(self[0] / other),
                days=round_half_to_even(self[1] / other),
                nanoseconds=round_half_to_even(
                    self[2] * NANO_SECONDS / other
                    + self[3] / other
                )
            )
        return NotImplemented",531,552
from_iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Parse a ISO formatted duration string.

Accepted formats (all lowercase letters are placeholders):
    'P', a zero length duration
    'PyY', y being a number of years
    'PmM', m being a number of months
    'PdD', d being a number of days

    Any combination of the above, e.g., 'P25Y1D' for 25 years and 1 day.

    'PThH', h being a number of hours
    'PTmM', h being a number of minutes
    'PTsS', h being a number of seconds
    'PTs.sss...S', h being a fractional number of seconds

    Any combination of the above, e.g. 'PT5H1.2S' for 5 hours and 1.2
    seconds.
    Any combination of all options, e.g. 'P13MT100M' for 13 months and
    100 minutes.

:param s: String to parse

:raises ValueError: if the string does not match the required format.","def from_iso_format(cls, s: str) -> Duration:
        """"""Parse a ISO formatted duration string.

        Accepted formats (all lowercase letters are placeholders):
            'P', a zero length duration
            'PyY', y being a number of years
            'PmM', m being a number of months
            'PdD', d being a number of days

            Any combination of the above, e.g., 'P25Y1D' for 25 years and 1 day.

            'PThH', h being a number of hours
            'PTmM', h being a number of minutes
            'PTsS', h being a number of seconds
            'PTs.sss...S', h being a fractional number of seconds

            Any combination of the above, e.g. 'PT5H1.2S' for 5 hours and 1.2
            seconds.
            Any combination of all options, e.g. 'P13MT100M' for 13 months and
            100 minutes.

        :param s: String to parse

        :raises ValueError: if the string does not match the required format.
        """"""
        match = DURATION_ISO_PATTERN.match(s)
        if match:
            ns = 0
            if match.group(15):
                ns = int(match.group(15)[1:10].ljust(9, ""0""))
            return cls(
                years=int(match.group(2) or 0),
                months=int(match.group(4) or 0),
                days=int(match.group(6) or 0),
                hours=int(match.group(9) or 0),
                minutes=int(match.group(11) or 0),
                seconds=int(match.group(14) or 0),
                nanoseconds=ns
            )
        raise ValueError(""Duration string must be in ISO format"")",589,628
iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return the :class:`Duration` as ISO formatted string.

:param sep: the separator before the time components.","def iso_format(self, sep: str = ""T"") -> str:
        """"""Return the :class:`Duration` as ISO formatted string.

        :param sep: the separator before the time components.
        """"""
        parts = []
        hours, minutes, seconds, nanoseconds = \
            self.hours_minutes_seconds_nanoseconds
        if hours:
            parts.append(""%dH"" % hours)
        if minutes:
            parts.append(""%dM"" % minutes)
        if nanoseconds:
            if seconds >= 0 and nanoseconds >= 0:
                parts.append(""%d.%sS"" %
                             (seconds,
                              str(nanoseconds).rjust(9, ""0"").rstrip(""0"")))
            elif seconds <= 0 and nanoseconds <= 0:
                parts.append(""-%d.%sS"" %
                             (abs(seconds),
                              str(abs(nanoseconds)).rjust(9, ""0"").rstrip(""0"")))

            else:
                assert False and ""Please report this issue""
        elif seconds:
            parts.append(""%dS"" % seconds)
        if parts:
            parts.insert(0, sep)
        years, months, days = self.years_months_days
        if days:
            parts.insert(0, ""%dD"" % days)
        if months:
            parts.insert(0, ""%dM"" % months)
        if years:
            parts.insert(0, ""%dY"" % years)
        if parts:
            parts.insert(0, ""P"")
            return """".join(parts)
        else:
            return ""PT0S""",632,671
months,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The months of the :class:`Duration`.,"def months(self) -> int:
        """"""The months of the :class:`Duration`.""""""
        return self[0]",674,676
days,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The days of the :class:`Duration`.,"def days(self) -> int:
        """"""The days of the :class:`Duration`.""""""
        return self[1]",679,681
seconds,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The seconds of the :class:`Duration`.,"def seconds(self) -> int:
        """"""The seconds of the :class:`Duration`.""""""
        return self[2]",684,686
nanoseconds,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The nanoseconds of the :class:`Duration`.,"def nanoseconds(self) -> int:
        """"""The nanoseconds of the :class:`Duration`.""""""
        return self[3]",689,691
years_months_days,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Months and days components as a 3-tuple.

t.Tuple of years, months and days.","def years_months_days(self) -> t.Tuple[int, int, int]:
        """"""Months and days components as a 3-tuple.

        t.Tuple of years, months and days.
        """"""
        years, months = symmetric_divmod(self[0], 12)
        return years, months, self[1]",694,700
hours_minutes_seconds_nanoseconds,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Seconds and nanoseconds components as a 4-tuple.

t.Tuple of hours, minutes, seconds and nanoseconds.","def hours_minutes_seconds_nanoseconds(self) -> t.Tuple[int, int, int, int]:
        """"""Seconds and nanoseconds components as a 4-tuple.

        t.Tuple of hours, minutes, seconds and nanoseconds.
        """"""
        minutes, seconds = symmetric_divmod(self[2], 60)
        hours, minutes = symmetric_divmod(minutes, 60)
        return hours, minutes, seconds, self[3]",703,710
today,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the current date.

:param tz: timezone or None to get the local :class:`.Date`.

:raises OverflowError: if the timestamp is out of the range of values
    supported by the platform C localtime() function. Its common for
    this to be restricted to years from 1970 through 2038.","def today(cls, tz: t.Optional[_tzinfo] = None) -> Date:
        """"""Get the current date.

        :param tz: timezone or None to get the local :class:`.Date`.

        :raises OverflowError: if the timestamp is out of the range of values
            supported by the platform C localtime() function. Its common for
            this to be restricted to years from 1970 through 2038.
        """"""
        if tz is None:
            return cls.from_clock_time(Clock().local_time(), UnixEpoch)
        else:
            return (
                DateTime.utc_now()
                .replace(tzinfo=timezone.utc).astimezone(tz)
                .date()
            )",795,811
utc_today,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Get the current date as UTC local date.,"def utc_today(cls) -> Date:
        """"""Get the current date as UTC local date.""""""
        return cls.from_clock_time(Clock().utc_time(), UnixEpoch)",814,816
from_timestamp,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,":class:`.Date` from a time stamp (seconds since unix epoch).

:param timestamp: the unix timestamp (seconds since unix epoch).
:param tz: timezone. Set to None to create a local :class:`.Date`.

:raises OverflowError: if the timestamp is out of the range of values
    supported by the platform C localtime() function. Its common for
    this to be restricted to years from 1970 through 2038.","def from_timestamp(
        cls, timestamp: float, tz: t.Optional[_tzinfo] = None
    ) -> Date:
        """""":class:`.Date` from a time stamp (seconds since unix epoch).

        :param timestamp: the unix timestamp (seconds since unix epoch).
        :param tz: timezone. Set to None to create a local :class:`.Date`.

        :raises OverflowError: if the timestamp is out of the range of values
            supported by the platform C localtime() function. Its common for
            this to be restricted to years from 1970 through 2038.
        """"""
        return cls.from_native(datetime.fromtimestamp(timestamp, tz))",819,831
utc_from_timestamp,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,":class:`.Date` from a time stamp (seconds since unix epoch).

:returns: the `Date` as local date `Date` in UTC.","def utc_from_timestamp(cls, timestamp: float) -> Date:
        """""":class:`.Date` from a time stamp (seconds since unix epoch).

        :returns: the `Date` as local date `Date` in UTC.
        """"""
        return cls.from_clock_time((timestamp, 0), UnixEpoch)",834,839
from_ordinal,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The :class:`.Date` that corresponds to the proleptic Gregorian ordinal.

`0001-01-01` has ordinal 1 and `9999-12-31` has ordinal 3,652,059.
Values outside of this range trigger a :exc:`ValueError`.
The corresponding instance method for the reverse date-to-ordinal
transformation is :meth:`.to_ordinal`.
The ordinal 0 has a special semantic and will return :attr:`ZeroDate`.

:raises ValueError: if the ordinal is outside the range [0, 3652059]
    (both values included).","def from_ordinal(cls, ordinal: int) -> Date:
        """"""
        The :class:`.Date` that corresponds to the proleptic Gregorian ordinal.

        `0001-01-01` has ordinal 1 and `9999-12-31` has ordinal 3,652,059.
        Values outside of this range trigger a :exc:`ValueError`.
        The corresponding instance method for the reverse date-to-ordinal
        transformation is :meth:`.to_ordinal`.
        The ordinal 0 has a special semantic and will return :attr:`ZeroDate`.

        :raises ValueError: if the ordinal is outside the range [0, 3652059]
            (both values included).
        """"""
        if ordinal == 0:
            return ZeroDate
        elif ordinal < 0 or ordinal > 3652059:
            raise ValueError(""Ordinal out of range (0..3652059)"")
        d = datetime.fromordinal(ordinal)
        year, month, day = _normalize_day(d.year, d.month, d.day)
        return cls.__new(ordinal, year, month, day)",842,861
parse,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Parse a string to produce a :class:`.Date`.

Accepted formats:
    'Y-M-D'

:param s: the string to be parsed.

:raises ValueError: if the string could not be parsed.","def parse(cls, s: str) -> Date:
        """"""Parse a string to produce a :class:`.Date`.

        Accepted formats:
            'Y-M-D'

        :param s: the string to be parsed.

        :raises ValueError: if the string could not be parsed.
        """"""
        try:
            numbers = list(map(int, s.split(""-"")))
        except (ValueError, AttributeError):
            raise ValueError(""Date string must be in format YYYY-MM-DD"")
        else:
            if len(numbers) == 3:
                return cls(*numbers)
            raise ValueError(""Date string must be in format YYYY-MM-DD"")",864,881
from_iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Parse a ISO formatted Date string.

Accepted formats:
    'YYYY-MM-DD'

:param s: the string to be parsed.

:raises ValueError: if the string could not be parsed.","def from_iso_format(cls, s: str) -> Date:
        """"""Parse a ISO formatted Date string.

        Accepted formats:
            'YYYY-MM-DD'

        :param s: the string to be parsed.

        :raises ValueError: if the string could not be parsed.
        """"""
        m = DATE_ISO_PATTERN.match(s)
        if m:
            year = int(m.group(1))
            month = int(m.group(2))
            day = int(m.group(3))
            return cls(year, month, day)
        raise ValueError(""Date string must be in format YYYY-MM-DD"")",884,900
from_native,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert from a native Python `datetime.date` value.

:param d: the date to convert.","def from_native(cls, d: date) -> Date:
        """"""Convert from a native Python `datetime.date` value.

        :param d: the date to convert.
        """"""
        return Date.from_ordinal(d.toordinal())",903,908
from_clock_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert from a ClockTime relative to a given epoch.

:param clock_time: the clock time as :class:`.ClockTime` or as tuple of
    (seconds, nanoseconds)
:param epoch: the epoch to which `clock_time` is relative","def from_clock_time(
        cls,
        clock_time: t.Union[ClockTime, t.Tuple[float, int]],
        epoch: DateTime
    ) -> Date:
        """"""Convert from a ClockTime relative to a given epoch.

        :param clock_time: the clock time as :class:`.ClockTime` or as tuple of
            (seconds, nanoseconds)
        :param epoch: the epoch to which `clock_time` is relative
        """"""
        try:
            clock_time = ClockTime(*clock_time)
        except (TypeError, ValueError):
            raise ValueError(""Clock time must be a 2-tuple of (s, ns)"")
        else:
            ordinal = clock_time.seconds // 86400
            return Date.from_ordinal(ordinal + epoch.date().to_ordinal())",911,928
is_leap_year,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Indicates whether or not `year` is a leap year.

:param year: the year to look up

:raises ValueError: if `year` is out of range:
    :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`","def is_leap_year(cls, year: int) -> bool:
        """"""Indicates whether or not `year` is a leap year.

        :param year: the year to look up

        :raises ValueError: if `year` is out of range:
            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`
        """"""
        if year < MIN_YEAR or year > MAX_YEAR:
            raise ValueError(""Year out of range (%d..%d)"" % (MIN_YEAR, MAX_YEAR))
        return IS_LEAP_YEAR[year]",931,941
days_in_year,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return the number of days in `year`.

:param year: the year to look up

:raises ValueError: if `year` is out of range:
    :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`","def days_in_year(cls, year: int) -> int:
        """"""Return the number of days in `year`.

        :param year: the year to look up

        :raises ValueError: if `year` is out of range:
            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`
        """"""
        if year < MIN_YEAR or year > MAX_YEAR:
            raise ValueError(""Year out of range (%d..%d)"" % (MIN_YEAR, MAX_YEAR))
        return DAYS_IN_YEAR[year]",944,954
days_in_month,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return the number of days in `month` of `year`.

:param year: the year to look up
:param month: the month to look up

:raises ValueError: if `year` or `month` is out of range:
    :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`;
    1 <= year <= 12","def days_in_month(cls, year: int, month: int) -> int:
        """"""Return the number of days in `month` of `year`.

        :param year: the year to look up
        :param month: the month to look up

        :raises ValueError: if `year` or `month` is out of range:
            :attr:`MIN_YEAR` <= year <= :attr:`MAX_YEAR`;
            1 <= year <= 12
        """"""
        if year < MIN_YEAR or year > MAX_YEAR:
            raise ValueError(""Year out of range (%d..%d)"" % (MIN_YEAR, MAX_YEAR))
        if month < 1 or month > 12:
            raise ValueError(""Month out of range (1..12)"")
        return DAYS_IN_MONTH[(year, month)]",957,971
year,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The year of the date.

:type: int","def year(self) -> int:
        """"""The year of the date.

        :type: int
        """"""
        return self.__year",1024,1029
month,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The month of the date.

:type: int","def month(self) -> int:
        """"""The month of the date.

        :type: int
        """"""
        return self.__month",1032,1037
day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The day of the date.

:type: int","def day(self) -> int:
        """"""The day of the date.

        :type: int
        """"""
        if self.__day == 0:
            return 0
        if self.__day >= 1:
            return self.__day
        return self.days_in_month(self.__year, self.__month) + self.__day + 1",1040,1049
year_month_day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"3-tuple of (year, month, day) describing the date.
        ","def year_month_day(self) -> t.Tuple[int, int, int]:
        """"""3-tuple of (year, month, day) describing the date.
        """"""
        return self.year, self.month, self.day",1052,1055
year_week_day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"3-tuple of (year, week_of_year, day_of_week) describing the date.

`day_of_week` will be 1 for Monday and 7 for Sunday.","def year_week_day(self) -> t.Tuple[int, int, int]:
        """"""3-tuple of (year, week_of_year, day_of_week) describing the date.

        `day_of_week` will be 1 for Monday and 7 for Sunday.
        """"""
        ordinal = self.__ordinal
        year = self.__year

        def day_of_week(o):
            return ((o - 1) % 7) + 1

        def iso_week_1(y):
            j4 = Date(y, 1, 4)
            return j4 + Duration(days=(1 - day_of_week(j4.to_ordinal())))

        if ordinal >= Date(year, 12, 29).to_ordinal():
            week1 = iso_week_1(year + 1)
            if ordinal < week1.to_ordinal():
                week1 = iso_week_1(year)
            else:
                year += 1
        else:
            week1 = iso_week_1(year)
            if ordinal < week1.to_ordinal():
                year -= 1
                week1 = iso_week_1(year)
        return (year, int((ordinal - week1.to_ordinal()) / 7 + 1),
                day_of_week(ordinal))",1058,1085
year_day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"2-tuple of (year, day_of_the_year) describing the date.

This is the number of the day relative to the start of the year,
with `1 Jan` corresponding to `1`.","def year_day(self) -> t.Tuple[int, int]:
        """"""2-tuple of (year, day_of_the_year) describing the date.

        This is the number of the day relative to the start of the year,
        with `1 Jan` corresponding to `1`.
        """"""
        return (self.__year,
                self.toordinal() - Date(self.__year, 1, 1).toordinal() + 1)",1088,1095
__eq__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``==`` comparison with :class:`.Date` or :class:`datetime.date`.,"def __eq__(self, other: object) -> bool:
        """"""``==`` comparison with :class:`.Date` or :class:`datetime.date`.""""""
        if isinstance(other, (Date, date)):
            return self.toordinal() == other.toordinal()
        return False",1103,1107
__ne__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``!=`` comparison with :class:`.Date` or :class:`datetime.date`.,"def __ne__(self, other: object) -> bool:
        """"""``!=`` comparison with :class:`.Date` or :class:`datetime.date`.""""""
        return not self.__eq__(other)",1109,1111
__lt__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``<`` comparison with :class:`.Date` or :class:`datetime.date`.,"def __lt__(self, other: t.Union[Date, date]) -> bool:
        """"""``<`` comparison with :class:`.Date` or :class:`datetime.date`.""""""
        if isinstance(other, (Date, date)):
            return self.toordinal() < other.toordinal()
        raise TypeError(""'<' not supported between instances of 'Date' and %r"" % type(other).__name__)",1113,1117
__le__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``<=`` comparison with :class:`.Date` or :class:`datetime.date`.,"def __le__(self, other: t.Union[Date, date]) -> bool:
        """"""``<=`` comparison with :class:`.Date` or :class:`datetime.date`.""""""
        if isinstance(other, (Date, date)):
            return self.toordinal() <= other.toordinal()
        raise TypeError(""'<=' not supported between instances of 'Date' and %r"" % type(other).__name__)",1119,1123
__ge__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``>=`` comparison with :class:`.Date` or :class:`datetime.date`.,"def __ge__(self, other: t.Union[Date, date]) -> bool:
        """"""``>=`` comparison with :class:`.Date` or :class:`datetime.date`.""""""
        if isinstance(other, (Date, date)):
            return self.toordinal() >= other.toordinal()
        raise TypeError(""'>=' not supported between instances of 'Date' and %r"" % type(other).__name__)",1125,1129
__gt__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``>`` comparison with :class:`.Date` or :class:`datetime.date`.,"def __gt__(self, other: t.Union[Date, date]) -> bool:
        """"""``>`` comparison with :class:`.Date` or :class:`datetime.date`.""""""
        if isinstance(other, (Date, date)):
            return self.toordinal() > other.toordinal()
        raise TypeError(""'>' not supported between instances of 'Date' and %r"" % type(other).__name__)",1131,1135
__add__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Add a :class:`.Duration`.

:raises ValueError: if the added duration has a time component.","def __add__(self, other: Duration) -> Date:  # type: ignore[override]
        """"""Add a :class:`.Duration`.

        :raises ValueError: if the added duration has a time component.
        """"""
        def add_months(d, months):
            overflow_years, month = divmod(months + d.__month - 1, 12)
            d.__year += overflow_years
            d.__month = month + 1

        def add_days(d, days):
            assert 1 <= d.__day <= 28 or -28 <= d.__day <= -1
            if d.__day >= 1:
                new_days = d.__day + days
                if 1 <= new_days <= 27:
                    d.__day = new_days
                    return
            d0 = Date.from_ordinal(d.__ordinal + days)
            d.__year, d.__month, d.__day = d0.__year, d0.__month, d0.__day

        if isinstance(other, Duration):
            if other.seconds or other.nanoseconds:
                raise ValueError(""Cannot add a Duration with seconds or ""
                                 ""nanoseconds to a Date"")
            if other.months == other.days == 0:
                return self
            new_date = self.replace()
            # Add days before months as the former sometimes
            # requires the current ordinal to be correct.
            if other.days:
                add_days(new_date, other.days)
            if other.months:
                add_months(new_date, other.months)
            new_date.__ordinal = self.__calc_ordinal(new_date.year, new_date.month, new_date.day)
            return new_date
        return NotImplemented",1137,1172
__sub__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Subtract a :class:`.Date` or :class:`.Duration`.

:returns: If a :class:`.Date` is subtracted, the time between the two
    dates is returned as :class:`.Duration`. If a :class:`.Duration` is
    subtracted, a new :class:`.Date` is returned.
:rtype: Date or Duration

:raises ValueError: if the added duration has a time component.","def __sub__(self, other):
        """"""Subtract a :class:`.Date` or :class:`.Duration`.

        :returns: If a :class:`.Date` is subtracted, the time between the two
            dates is returned as :class:`.Duration`. If a :class:`.Duration` is
            subtracted, a new :class:`.Date` is returned.
        :rtype: Date or Duration

        :raises ValueError: if the added duration has a time component.
        """"""
        if isinstance(other, (Date, date)):
            return Duration(days=(self.toordinal() - other.toordinal()))
        try:
            return self.__add__(-other)
        except TypeError:
            return NotImplemented",1182,1197
time_tuple,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Convert the date to :class:`time.struct_time`.,"def time_tuple(self) -> struct_time:
        """"""Convert the date to :class:`time.struct_time`.""""""
        _, _, day_of_week = self.year_week_day
        _, day_of_year = self.year_day
        return struct_time((self.year, self.month, self.day, 0, 0, 0, day_of_week - 1, day_of_year, -1))",1241,1245
to_ordinal,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The date's proleptic Gregorian ordinal.

The corresponding class method for the reverse ordinal-to-date
transformation is :meth:`.Date.from_ordinal`.","def to_ordinal(self) -> int:
        """"""The date's proleptic Gregorian ordinal.

        The corresponding class method for the reverse ordinal-to-date
        transformation is :meth:`.Date.from_ordinal`.
        """"""
        return self.__ordinal",1247,1253
to_clock_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert the date to :class:`ClockTime` relative to `epoch`.

:param epoch: the epoch to which the date is relative","def to_clock_time(self, epoch: t.Union[Date, DateTime]) -> ClockTime:
        """"""Convert the date to :class:`ClockTime` relative to `epoch`.

        :param epoch: the epoch to which the date is relative
        """"""
        try:
            return ClockTime(86400 * (self.to_ordinal() - epoch.to_ordinal()))
        except AttributeError:
            raise TypeError(""Epoch has no ordinal value"")",1255,1263
to_native,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert to a native Python :class:`datetime.date` value.
        ","def to_native(self) -> date:
        """"""Convert to a native Python :class:`datetime.date` value.
        """"""
        return date.fromordinal(self.to_ordinal())",1265,1268
weekday,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The day of the week where Monday is 0 and Sunday is 6.,"def weekday(self) -> int:
        """"""The day of the week where Monday is 0 and Sunday is 6.""""""
        return self.year_week_day[2] - 1",1270,1272
iso_weekday,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The day of the week where Monday is 1 and Sunday is 7.,"def iso_weekday(self) -> int:
        """"""The day of the week where Monday is 1 and Sunday is 7.""""""
        return self.year_week_day[2]",1274,1276
iso_calendar,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Alias for :attr:`.year_week_day`,"def iso_calendar(self) -> t.Tuple[int, int, int]:
        """"""Alias for :attr:`.year_week_day`""""""
        return self.year_week_day",1278,1280
iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Return the :class:`.Date` as ISO formatted string.,"def iso_format(self) -> str:
        """"""Return the :class:`.Date` as ISO formatted string.""""""
        if self.__ordinal == 0:
            return ""0000-00-00""
        return ""%04d-%02d-%02d"" % self.year_month_day",1282,1286
__getattr__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Map standard library attribute names to local attribute names,
for compatibility.","def __getattr__(self, name):
        """""" Map standard library attribute names to local attribute names,
        for compatibility.
        """"""
        try:
            return {
                ""isocalendar"": self.iso_calendar,
                ""isoformat"": self.iso_format,
                ""isoweekday"": self.iso_weekday,
                ""strftime"": self.__format__,
                ""toordinal"": self.to_ordinal,
                ""timetuple"": self.time_tuple,
            }[name]
        except KeyError:
            raise AttributeError(""Date has no attribute %r"" % name)",1307,1321
now,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the current time.

:param tz: optional timezone

:raises OverflowError: if the timestamp is out of the range of values
    supported by the platform C localtime() function. Its common for
    this to be restricted to years from 1970 through 2038.","def now(cls, tz: t.Optional[_tzinfo] = None) -> Time:
        """"""Get the current time.

        :param tz: optional timezone

        :raises OverflowError: if the timestamp is out of the range of values
            supported by the platform C localtime() function. Its common for
            this to be restricted to years from 1970 through 2038.
        """"""
        if tz is None:
            return cls.from_clock_time(Clock().local_time(), UnixEpoch)
        else:
            return (
                DateTime.utc_now()
                .replace(tzinfo=timezone.utc).astimezone(tz)
                .timetz()
            )",1433,1449
utc_now,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Get the current time as UTC local time.,"def utc_now(cls) -> Time:
        """"""Get the current time as UTC local time.""""""
        return cls.from_clock_time(Clock().utc_time(), UnixEpoch)",1452,1454
from_iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Parse a ISO formatted time string.

Accepted formats:
    Local times:
        'hh'
        'hh:mm'
        'hh:mm:ss'
        'hh:mm:ss.ssss...'
    Times with timezones (UTC offset):
        '<local time>+hh:mm'
        '<local time>+hh:mm:ss'
        '<local time>+hh:mm:ss.ssss....'
        '<local time>-hh:mm'
        '<local time>-hh:mm:ss'
        '<local time>-hh:mm:ss.ssss....'

        Where the UTC offset will only respect hours and minutes.
        Seconds and sub-seconds are ignored.

:param s: String to parse

:raises ValueError: if the string does not match the required format.","def from_iso_format(cls, s: str) -> Time:
        """"""Parse a ISO formatted time string.

        Accepted formats:
            Local times:
                'hh'
                'hh:mm'
                'hh:mm:ss'
                'hh:mm:ss.ssss...'
            Times with timezones (UTC offset):
                '<local time>+hh:mm'
                '<local time>+hh:mm:ss'
                '<local time>+hh:mm:ss.ssss....'
                '<local time>-hh:mm'
                '<local time>-hh:mm:ss'
                '<local time>-hh:mm:ss.ssss....'

                Where the UTC offset will only respect hours and minutes.
                Seconds and sub-seconds are ignored.

        :param s: String to parse

        :raises ValueError: if the string does not match the required format.
        """"""
        from pytz import FixedOffset  # type: ignore
        m = TIME_ISO_PATTERN.match(s)
        if m:
            hour = int(m.group(1))
            minute = int(m.group(3) or 0)
            second = int(m.group(6) or 0)
            nanosecond = m.group(7)
            if nanosecond:
                nanosecond = int(nanosecond[1:10].ljust(9, ""0""))
            else:
                nanosecond = 0
            if m.group(8) is None:
                return cls(hour, minute, second, nanosecond)
            else:
                offset_multiplier = 1 if m.group(9) == ""+"" else -1
                offset_hour = int(m.group(10))
                offset_minute = int(m.group(11))
                # pytz only supports offsets of minute resolution
                # so we can ignore this part
                # offset_second = float(m.group(13) or 0.0)
                offset = 60 * offset_hour + offset_minute
                return cls(hour, minute, second, nanosecond,
                           tzinfo=FixedOffset(offset_multiplier * offset))
        raise ValueError(""Time string is not in ISO format"")",1457,1504
from_ticks,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Create a time from ticks (nanoseconds since midnight).

:param ticks: nanoseconds since midnight
:param tz: optional timezone

:raises ValueError: if ticks is out of bounds
    (0 <= ticks < 86400000000000)

.. versionchanged:: 5.0
    The parameter ``ticks`` no longer accepts :class:`float` values
    but only :class:`int`. It's now nanoseconds since midnight instead
    of seconds.","def from_ticks(cls, ticks: int, tz: t.Optional[_tzinfo] = None) -> Time:
        """"""Create a time from ticks (nanoseconds since midnight).

        :param ticks: nanoseconds since midnight
        :param tz: optional timezone

        :raises ValueError: if ticks is out of bounds
            (0 <= ticks < 86400000000000)

        .. versionchanged:: 5.0
            The parameter ``ticks`` no longer accepts :class:`float` values
            but only :class:`int`. It's now nanoseconds since midnight instead
            of seconds.
        """"""
        if not isinstance(ticks, int):
            raise TypeError(""Ticks must be int"")
        if 0 <= ticks < 86400000000000:
            second, nanosecond = divmod(ticks, NANO_SECONDS)
            minute, second = divmod(second, 60)
            hour, minute = divmod(minute, 60)
            return cls.__unchecked_new(ticks, hour, minute, second, nanosecond,
                                       tz)
        raise ValueError(""Ticks out of range (0..86400000000000)"")",1507,1529
from_native,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert from a native Python :class:`datetime.time` value.

:param t: time to convert from","def from_native(cls, t: time) -> Time:
        """"""Convert from a native Python :class:`datetime.time` value.

        :param t: time to convert from
        """"""
        nanosecond = t.microsecond * 1000
        return Time(t.hour, t.minute, t.second, nanosecond, t.tzinfo)",1532,1538
from_clock_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert from a :class:`.ClockTime` relative to a given epoch.

This method, in contrast to most others of this package, assumes days of
exactly 24 hours.

:param clock_time: the clock time as :class:`.ClockTime` or as tuple of
    (seconds, nanoseconds)
:param epoch: the epoch to which `clock_time` is relative","def from_clock_time(
        cls,
        clock_time: t.Union[ClockTime, t.Tuple[float, int]],
        epoch: DateTime
    ) -> Time:
        """"""Convert from a :class:`.ClockTime` relative to a given epoch.

        This method, in contrast to most others of this package, assumes days of
        exactly 24 hours.

        :param clock_time: the clock time as :class:`.ClockTime` or as tuple of
            (seconds, nanoseconds)
        :param epoch: the epoch to which `clock_time` is relative
        """"""
        clock_time = ClockTime(*clock_time)
        ts = clock_time.seconds % 86400
        nanoseconds = int(NANO_SECONDS * ts + clock_time.nanoseconds)
        ticks = (epoch.time().ticks + nanoseconds) % (86400 * NANO_SECONDS)
        return Time.from_ticks(ticks)",1541,1559
ticks,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The total number of nanoseconds since midnight.

.. versionchanged:: 5.0
    The property's type changed from :class:`float` to :class:`int`.
    It's now nanoseconds since midnight instead of seconds.","def ticks(self) -> int:
        """"""The total number of nanoseconds since midnight.

        .. versionchanged:: 5.0
            The property's type changed from :class:`float` to :class:`int`.
            It's now nanoseconds since midnight instead of seconds.
        """"""
        return self.__ticks",1629,1636
hour,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The hours of the time.,"def hour(self) -> int:
        """"""The hours of the time.""""""
        return self.__hour",1639,1641
minute,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The minutes of the time.,"def minute(self) -> int:
        """"""The minutes of the time.""""""
        return self.__minute",1644,1646
second,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The seconds of the time.

.. versionchanged:: 4.4
    The property's type changed from :class:`float` to
    :class:`decimal.Decimal` to mitigate rounding issues.

.. versionchanged:: 5.0
    The  property's type changed from :class:`decimal.Decimal` to
    :class:`int`. It does not longer cary sub-second information.
    Use `attr:`nanosecond` instead.","def second(self) -> int:
        """"""The seconds of the time.

        .. versionchanged:: 4.4
            The property's type changed from :class:`float` to
            :class:`decimal.Decimal` to mitigate rounding issues.

        .. versionchanged:: 5.0
            The  property's type changed from :class:`decimal.Decimal` to
            :class:`int`. It does not longer cary sub-second information.
            Use `attr:`nanosecond` instead.
        """"""
        return self.__second",1649,1661
nanosecond,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The nanoseconds of the time.,"def nanosecond(self) -> int:
        """"""The nanoseconds of the time.""""""
        return self.__nanosecond",1664,1666
hour_minute_second_nanosecond,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The time as a tuple of (hour, minute, second, nanosecond).","def hour_minute_second_nanosecond(self) -> t.Tuple[int, int, int, int]:
        """"""The time as a tuple of (hour, minute, second, nanosecond).""""""
        return self.__hour, self.__minute, self.__second, self.__nanosecond",1669,1671
tzinfo,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The timezone of this time.,"def tzinfo(self) -> t.Optional[_tzinfo]:
        """"""The timezone of this time.""""""
        return self.__tzinfo",1674,1676
__eq__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,`==` comparison with :class:`.Time` or :class:`datetime.time`.,"def __eq__(self, other: object) -> bool:
        """"""`==` comparison with :class:`.Time` or :class:`datetime.time`.""""""
        self_ticks, other_ticks = self._get_both_normalized_ticks(other,
                                                                  strict=False)
        if self_ticks is None:
            return False
        return self_ticks == other_ticks",1718,1724
__ne__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,`!=` comparison with :class:`.Time` or :class:`datetime.time`.,"def __ne__(self, other: object) -> bool:
        """"""`!=` comparison with :class:`.Time` or :class:`datetime.time`.""""""
        return not self.__eq__(other)",1726,1728
__lt__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,`<` comparison with :class:`.Time` or :class:`datetime.time`.,"def __lt__(self, other: t.Union[Time, time]) -> bool:
        """"""`<` comparison with :class:`.Time` or :class:`datetime.time`.""""""
        self_ticks, other_ticks = self._get_both_normalized_ticks(other)
        if self_ticks is None:
            return NotImplemented
        return self_ticks < other_ticks",1730,1735
__le__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,`<=` comparison with :class:`.Time` or :class:`datetime.time`.,"def __le__(self, other: t.Union[Time, time]) -> bool:
        """"""`<=` comparison with :class:`.Time` or :class:`datetime.time`.""""""
        self_ticks, other_ticks = self._get_both_normalized_ticks(other)
        if self_ticks is None:
            return NotImplemented
        return self_ticks <= other_ticks",1737,1742
__ge__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,`>=` comparison with :class:`.Time` or :class:`datetime.time`.,"def __ge__(self, other: t.Union[Time, time]) -> bool:
        """"""`>=` comparison with :class:`.Time` or :class:`datetime.time`.""""""
        self_ticks, other_ticks = self._get_both_normalized_ticks(other)
        if self_ticks is None:
            return NotImplemented
        return self_ticks >= other_ticks",1744,1749
__gt__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,`>` comparison with :class:`.Time` or :class:`datetime.time`.,"def __gt__(self, other: t.Union[Time, time]) -> bool:
        """"""`>` comparison with :class:`.Time` or :class:`datetime.time`.""""""
        self_ticks, other_ticks = self._get_both_normalized_ticks(other)
        if self_ticks is None:
            return NotImplemented
        return self_ticks > other_ticks",1751,1756
utc_offset,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return the UTC offset of this time.

:returns: None if this is a local time (:attr:`.tzinfo` is None), else
    returns `self.tzinfo.utcoffset(self)`.

:raises ValueError: if `self.tzinfo.utcoffset(self)` is not None and a
    :class:`timedelta` with a magnitude greater equal 1 day or that is
    not a whole number of minutes.
:raises TypeError: if `self.tzinfo.utcoffset(self)` does return anything but
    None or a :class:`datetime.timedelta`.","def utc_offset(self) -> t.Optional[timedelta]:
        """"""Return the UTC offset of this time.

        :returns: None if this is a local time (:attr:`.tzinfo` is None), else
            returns `self.tzinfo.utcoffset(self)`.

        :raises ValueError: if `self.tzinfo.utcoffset(self)` is not None and a
            :class:`timedelta` with a magnitude greater equal 1 day or that is
            not a whole number of minutes.
        :raises TypeError: if `self.tzinfo.utcoffset(self)` does return anything but
            None or a :class:`datetime.timedelta`.
        """"""
        return self._utc_offset()",1817,1829
dst,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the daylight saving time adjustment (DST).

:returns: None if this is a local time (:attr:`.tzinfo` is None), else
    returns `self.tzinfo.dst(self)`.

:raises ValueError: if `self.tzinfo.dst(self)` is not None and a
    :class:`timedelta` with a magnitude greater equal 1 day or that is
    not a whole number of minutes.
:raises TypeError: if `self.tzinfo.dst(self)` does return anything but
    None or a :class:`datetime.timedelta`.","def dst(self) -> t.Optional[timedelta]:
        """"""Get the daylight saving time adjustment (DST).

        :returns: None if this is a local time (:attr:`.tzinfo` is None), else
            returns `self.tzinfo.dst(self)`.

        :raises ValueError: if `self.tzinfo.dst(self)` is not None and a
            :class:`timedelta` with a magnitude greater equal 1 day or that is
            not a whole number of minutes.
        :raises TypeError: if `self.tzinfo.dst(self)` does return anything but
            None or a :class:`datetime.timedelta`.
        """"""
        if self.tzinfo is None:
            return None
        try:
            value = self.tzinfo.dst(self)  # type: ignore
        except TypeError:
            # For timezone implementations not compatible with the custom
            # datetime implementations, we can't do better than this.
            value = self.tzinfo.dst(self.to_native())  # type: ignore
        if value is None:
            return None
        if isinstance(value, timedelta):
            if value.days != 0:
                raise ValueError(""dst must be less than a day"")
            if value.seconds % 60 != 0 or value.microseconds != 0:
                raise ValueError(""dst must be a whole number of minutes"")
            return value
        raise TypeError(""dst must be a timedelta"")",1831,1859
tzname,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the name of the :class:`.Time`'s timezone.

:returns: None if the time is local (i.e., has no timezone), else return
    `self.tzinfo.tzname(self)`","def tzname(self) -> t.Optional[str]:
        """"""Get the name of the :class:`.Time`'s timezone.

        :returns: None if the time is local (i.e., has no timezone), else return
            `self.tzinfo.tzname(self)`
        """"""
        if self.tzinfo is None:
            return None
        try:
            return self.tzinfo.tzname(self)  # type: ignore
        except TypeError:
            # For timezone implementations not compatible with the custom
            # datetime implementations, we can't do better than this.
            return self.tzinfo.tzname(self.to_native())",1861,1874
to_clock_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Convert to :class:`.ClockTime`.,"def to_clock_time(self) -> ClockTime:
        """"""Convert to :class:`.ClockTime`.""""""
        seconds, nanoseconds = divmod(self.ticks, NANO_SECONDS)
        return ClockTime(seconds, nanoseconds)",1876,1879
to_native,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert to a native Python `datetime.time` value.

This conversion is lossy as the native time implementation only
supports a resolution of microseconds instead of nanoseconds.","def to_native(self) -> time:
        """"""Convert to a native Python `datetime.time` value.

        This conversion is lossy as the native time implementation only
        supports a resolution of microseconds instead of nanoseconds.
        """"""
        h, m, s, ns = self.hour_minute_second_nanosecond
        s = round_half_to_even(ns / 1000)
        tz = self.tzinfo
        return time(h, m, s, s, tz)",1881,1890
iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Return the :class:`.Time` as ISO formatted string.,"def iso_format(self) -> str:
        """"""Return the :class:`.Time` as ISO formatted string.""""""
        s = ""%02d:%02d:%02d.%09d"" % self.hour_minute_second_nanosecond
        offset = self.utc_offset()
        if offset is not None:
            s += ""%+03d:%02d"" % divmod(offset.total_seconds() // 60, 60)
        return s",1892,1898
__getattr__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Map standard library attribute names to local attribute names,
for compatibility.","def __getattr__(self, name):
        """"""Map standard library attribute names to local attribute names,
        for compatibility.
        """"""
        try:
            return {
                ""isoformat"": self.iso_format,
                ""utcoffset"": self.utc_offset,
            }[name]
        except KeyError:
            raise AttributeError(""Date has no attribute %r"" % name)",1923,1933
now,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the current date and time.

:param tz: timezone. Set to None to create a local :class:`.DateTime`.

:raises OverflowError: if the timestamp is out of the range of values
    supported by the platform C localtime() function. Its common for
    this to be restricted to years from 1970 through 2038.","def now(cls, tz: t.Optional[_tzinfo] = None) -> DateTime:
        """"""Get the current date and time.

        :param tz: timezone. Set to None to create a local :class:`.DateTime`.

        :raises OverflowError: if the timestamp is out of the range of values
            supported by the platform C localtime() function. Its common for
            this to be restricted to years from 1970 through 2038.
        """"""
        if tz is None:
            return cls.from_clock_time(Clock().local_time(), UnixEpoch)
        else:
            try:
                return tz.fromutc(  # type: ignore
                    cls.from_clock_time(  # type: ignore
                        Clock().utc_time(), UnixEpoch
                    ).replace(tzinfo=tz)
                )
            except TypeError:
                # For timezone implementations not compatible with the custom
                # datetime implementations, we can't do better than this.
                utc_now = cls.from_clock_time(
                    Clock().utc_time(), UnixEpoch
                )
                utc_now_native = utc_now.to_native()
                now_native = tz.fromutc(utc_now_native)
                now = cls.from_native(now_native)
                return now.replace(
                    nanosecond=(now.nanosecond
                                + utc_now.nanosecond
                                - utc_now_native.microsecond * 1000)
                )",2022,2053
utc_now,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Get the current date and time in UTC.,"def utc_now(cls) -> DateTime:
        """"""Get the current date and time in UTC.""""""
        return cls.from_clock_time(Clock().utc_time(), UnixEpoch)",2056,2058
from_iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Parse a ISO formatted date with time string.

:param s: String to parse

:raises ValueError: if the string does not match the ISO format.","def from_iso_format(cls, s) -> DateTime:
        """"""Parse a ISO formatted date with time string.

        :param s: String to parse

        :raises ValueError: if the string does not match the ISO format.
        """"""
        try:
            return cls.combine(Date.from_iso_format(s[0:10]),
                               Time.from_iso_format(s[11:]))
        except ValueError:
            raise ValueError(""DateTime string is not in ISO format"")",2061,2072
from_timestamp,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,":class:`.DateTime` from a time stamp (seconds since unix epoch).

:param timestamp: the unix timestamp (seconds since unix epoch).
:param tz: timezone. Set to None to create a local :class:`.DateTime`.

:raises OverflowError: if the timestamp is out of the range of values
    supported by the platform C localtime() function. Its common for
    this to be restricted to years from 1970 through 2038.","def from_timestamp(
        cls, timestamp: float, tz: t.Optional[_tzinfo] = None
    ) -> DateTime:
        """""":class:`.DateTime` from a time stamp (seconds since unix epoch).

        :param timestamp: the unix timestamp (seconds since unix epoch).
        :param tz: timezone. Set to None to create a local :class:`.DateTime`.

        :raises OverflowError: if the timestamp is out of the range of values
            supported by the platform C localtime() function. Its common for
            this to be restricted to years from 1970 through 2038.
        """"""
        if tz is None:
            return cls.from_clock_time(
                ClockTime(timestamp) + Clock().local_offset(), UnixEpoch
            )
        else:
            return (
                cls.utc_from_timestamp(timestamp)
                .replace(tzinfo=timezone.utc).astimezone(tz)
            )",2075,2095
utc_from_timestamp,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,":class:`.DateTime` from a time stamp (seconds since unix epoch).

Returns the `DateTime` as local date `DateTime` in UTC.","def utc_from_timestamp(cls, timestamp: float) -> DateTime:
        """""":class:`.DateTime` from a time stamp (seconds since unix epoch).

        Returns the `DateTime` as local date `DateTime` in UTC.
        """"""
        return cls.from_clock_time((timestamp, 0), UnixEpoch)",2098,2103
from_ordinal,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,":class:`.DateTime` from an ordinal.

For more info about ordinals see :meth:`.Date.from_ordinal`.","def from_ordinal(cls, ordinal: int) -> DateTime:
        """""":class:`.DateTime` from an ordinal.

        For more info about ordinals see :meth:`.Date.from_ordinal`.
        """"""
        return cls.combine(Date.from_ordinal(ordinal), Midnight)",2106,2111
combine,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Combine a :class:`.Date` and a :class:`.Time` to a :class:`DateTime`.

:param date: the date
:param time: the time

:raises AssertionError: if the parameter types don't match.","def combine(  # type: ignore[override]
        cls, date: Date, time: Time
    ) -> DateTime:
        """"""Combine a :class:`.Date` and a :class:`.Time` to a :class:`DateTime`.

        :param date: the date
        :param time: the time

        :raises AssertionError: if the parameter types don't match.
        """"""
        assert isinstance(date, Date)
        assert isinstance(time, Time)
        return cls._combine(date, time)",2114,2126
from_native,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert from a native Python :class:`datetime.datetime` value.

:param dt: the datetime to convert","def from_native(cls, dt: datetime) -> DateTime:
        """"""Convert from a native Python :class:`datetime.datetime` value.

        :param dt: the datetime to convert
        """"""
        return cls.combine(Date.from_native(dt.date()),
                           Time.from_native(dt.timetz()))",2140,2146
from_clock_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert from a :class:`ClockTime` relative to a given epoch.

:param clock_time: the clock time as :class:`.ClockTime` or as tuple of
    (seconds, nanoseconds)
:param epoch: the epoch to which `clock_time` is relative

:raises ValueError: if `clock_time` is invalid.","def from_clock_time(
        cls,
        clock_time: t.Union[ClockTime, t.Tuple[float, int]],
        epoch: DateTime
    ) -> DateTime:
        """"""Convert from a :class:`ClockTime` relative to a given epoch.

        :param clock_time: the clock time as :class:`.ClockTime` or as tuple of
            (seconds, nanoseconds)
        :param epoch: the epoch to which `clock_time` is relative

        :raises ValueError: if `clock_time` is invalid.
        """"""
        try:
            seconds, nanoseconds = ClockTime(*clock_time)
        except (TypeError, ValueError):
            raise ValueError(""Clock time must be a 2-tuple of (s, ns)"")
        else:
            ordinal, seconds = divmod(seconds, 86400)
            ticks = epoch.time().ticks + seconds * NANO_SECONDS + nanoseconds
            days, ticks = divmod(ticks, 86400 * NANO_SECONDS)
            ordinal += days
            date_ = Date.from_ordinal(ordinal + epoch.date().to_ordinal())
            time_ = Time.from_ticks(ticks)
            return cls.combine(date_, time_)",2149,2173
year,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The year of the :class:`.DateTime`.

See :attr:`.Date.year`.","def year(self) -> int:
        """"""The year of the :class:`.DateTime`.

        See :attr:`.Date.year`.
        """"""
        return self.__date.year",2225,2230
month,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The year of the :class:`.DateTime`.

See :attr:`.Date.year`.","def month(self) -> int:
        """"""The year of the :class:`.DateTime`.

        See :attr:`.Date.year`.""""""
        return self.__date.month",2233,2237
day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The day of the :class:`.DateTime`'s date.

See :attr:`.Date.day`.","def day(self) -> int:
        """"""The day of the :class:`.DateTime`'s date.

        See :attr:`.Date.day`.""""""
        return self.__date.day",2240,2244
year_month_day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The year_month_day of the :class:`.DateTime`'s date.

See :attr:`.Date.year_month_day`.","def year_month_day(self) -> t.Tuple[int, int, int]:
        """"""The year_month_day of the :class:`.DateTime`'s date.

        See :attr:`.Date.year_month_day`.""""""
        return self.__date.year_month_day",2247,2251
year_week_day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The year_week_day of the :class:`.DateTime`'s date.

See :attr:`.Date.year_week_day`.","def year_week_day(self) -> t.Tuple[int, int, int]:
        """"""The year_week_day of the :class:`.DateTime`'s date.

        See :attr:`.Date.year_week_day`.""""""
        return self.__date.year_week_day",2254,2258
year_day,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The year_day of the :class:`.DateTime`'s date.

See :attr:`.Date.year_day`.","def year_day(self) -> t.Tuple[int, int]:
        """"""The year_day of the :class:`.DateTime`'s date.

        See :attr:`.Date.year_day`.""""""
        return self.__date.year_day",2261,2265
hour,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The hour of the :class:`.DateTime`'s time.

See :attr:`.Time.hour`.","def hour(self) -> int:
        """"""The hour of the :class:`.DateTime`'s time.

        See :attr:`.Time.hour`.""""""
        return self.__time.hour",2268,2272
minute,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The minute of the :class:`.DateTime`'s time.

See :attr:`.Time.minute`.","def minute(self) -> int:
        """"""The minute of the :class:`.DateTime`'s time.

        See :attr:`.Time.minute`.""""""
        return self.__time.minute",2275,2279
second,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The second of the :class:`.DateTime`'s time.

See :attr:`.Time.second`.","def second(self) -> int:
        """"""The second of the :class:`.DateTime`'s time.

        See :attr:`.Time.second`.""""""
        return self.__time.second",2282,2286
nanosecond,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The nanosecond of the :class:`.DateTime`'s time.

See :attr:`.Time.nanosecond`.","def nanosecond(self) -> int:
        """"""The nanosecond of the :class:`.DateTime`'s time.

        See :attr:`.Time.nanosecond`.""""""
        return self.__time.nanosecond",2289,2293
tzinfo,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The tzinfo of the :class:`.DateTime`'s time.

See :attr:`.Time.tzinfo`.","def tzinfo(self) -> t.Optional[_tzinfo]:
        """"""The tzinfo of the :class:`.DateTime`'s time.

        See :attr:`.Time.tzinfo`.""""""
        return self.__time.tzinfo",2296,2300
hour_minute_second_nanosecond,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"The hour_minute_second_nanosecond of the :class:`.DateTime`'s time.

See :attr:`.Time.hour_minute_second_nanosecond`.","def hour_minute_second_nanosecond(self) -> t.Tuple[int, int, int, int]:
        """"""The hour_minute_second_nanosecond of the :class:`.DateTime`'s time.

        See :attr:`.Time.hour_minute_second_nanosecond`.""""""
        return self.__time.hour_minute_second_nanosecond",2303,2307
__eq__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``==`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.,"def __eq__(self, other: object) -> bool:
        """"""
        ``==`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.
        """"""
        if not isinstance(other, (datetime, DateTime)):
            return NotImplemented
        if self.utc_offset() == other.utcoffset():
            return self.date() == other.date() and self.time() == other.time()
        self_norm, other_norm = self._get_both_normalized(other, strict=False)
        if self_norm is None:
            return False
        return self_norm == other_norm",2345,2356
__ne__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``!=`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.,"def __ne__(self, other: object) -> bool:
        """"""
        ``!=`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.
        """"""
        return not self.__eq__(other)",2358,2362
__lt__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``<`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.,"def __lt__(  # type: ignore[override]
        self, other: datetime
    ) -> bool:
        """"""
        ``<`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.
        """"""
        if not isinstance(other, (datetime, DateTime)):
            return NotImplemented
        if self.utc_offset() == other.utcoffset():
            if self.date() == other.date():
                return self.time() < other.time()
            return self.date() < other.date()
        self_norm, other_norm = self._get_both_normalized(other)
        return (self_norm.date() < other_norm.date()
                or self_norm.time() < other_norm.time())",2364,2378
__le__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``<=`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.,"def __le__(  # type: ignore[override]
        self, other: t.Union[datetime, DateTime]
    ) -> bool:
        """"""
        ``<=`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.
        """"""
        if not isinstance(other, (datetime, DateTime)):
            return NotImplemented
        if self.utc_offset() == other.utcoffset():
            if self.date() == other.date():
                return self.time() <= other.time()
            return self.date() <= other.date()
        self_norm, other_norm = self._get_both_normalized(other)
        return self_norm <= other_norm",2380,2393
__ge__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``>=`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.,"def __ge__(  # type: ignore[override]
        self, other: t.Union[datetime, DateTime]
    ) -> bool:
        """"""
        ``>=`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.
        """"""
        if not isinstance(other, (datetime, DateTime)):
            return NotImplemented
        if self.utc_offset() == other.utcoffset():
            if self.date() == other.date():
                return self.time() >= other.time()
            return self.date() >= other.date()
        self_norm, other_norm = self._get_both_normalized(other)
        return self_norm >= other_norm",2395,2408
__gt__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,``>`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.,"def __gt__(  # type: ignore[override]
        self, other: t.Union[datetime, DateTime]
    ) -> bool:
        """"""
        ``>`` comparison with :class:`.DateTime` or :class:`datetime.datetime`.
        """"""
        if not isinstance(other, (datetime, DateTime)):
            return NotImplemented
        if self.utc_offset() == other.utcoffset():
            if self.date() == other.date():
                return self.time() > other.time()
            return self.date() > other.date()
        self_norm, other_norm = self._get_both_normalized(other)
        return (self_norm.date() > other_norm.date()
                or self_norm.time() > other_norm.time())",2410,2424
__add__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Add a :class:`datetime.timedelta`.,"def __add__(self, other: t.Union[timedelta, Duration]) -> DateTime:
        """"""Add a :class:`datetime.timedelta`.""""""
        if isinstance(other, Duration):
            t = (self.to_clock_time()
                 + ClockTime(other.seconds, other.nanoseconds))
            days, seconds = symmetric_divmod(t.seconds, 86400)
            date_ = self.date() + Duration(months=other.months,
                                           days=days + other.days)
            time_ = Time.from_ticks(seconds * NANO_SECONDS + t.nanoseconds)
            return self.combine(date_, time_).replace(tzinfo=self.tzinfo)
        if isinstance(other, timedelta):
            t = (self.to_clock_time()
                 + ClockTime(86400 * other.days + other.seconds,
                             other.microseconds * 1000))
            days, seconds = symmetric_divmod(t.seconds, 86400)
            date_ = Date.from_ordinal(days + 1)
            time_ = Time.from_ticks(round_half_to_even(
                seconds * NANO_SECONDS + t.nanoseconds
            ))
            return self.combine(date_, time_).replace(tzinfo=self.tzinfo)
        return NotImplemented",2426,2446
__sub__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Subtract a datetime/DateTime or a timedelta/Duration.

Subtracting a :class:`.DateTime` yields the duration between the two
as a :class:`.Duration`.

Subtracting a :class:`datetime.datetime` yields the duration between
the two as a :class:`datetime.timedelta`.

Subtracting a :class:`datetime.timedelta` or a :class:`.Duration`
yields the :class:`.DateTime` that's the given duration away.","def __sub__(self, other):
        """"""Subtract a datetime/DateTime or a timedelta/Duration.

        Subtracting a :class:`.DateTime` yields the duration between the two
        as a :class:`.Duration`.

        Subtracting a :class:`datetime.datetime` yields the duration between
        the two as a :class:`datetime.timedelta`.

        Subtracting a :class:`datetime.timedelta` or a :class:`.Duration`
        yields the :class:`.DateTime` that's the given duration away.
        """"""
        if isinstance(other, DateTime):
            self_month_ordinal = 12 * (self.year - 1) + self.month
            other_month_ordinal = 12 * (other.year - 1) + other.month
            months = self_month_ordinal - other_month_ordinal
            days = self.day - other.day
            t = self.time().to_clock_time() - other.time().to_clock_time()
            return Duration(months=months, days=days, seconds=t.seconds,
                            nanoseconds=t.nanoseconds)
        if isinstance(other, datetime):
            days = self.to_ordinal() - other.toordinal()
            t = (self.time().to_clock_time()
                 - ClockTime(
                       3600 * other.hour + 60 * other.minute + other.second,
                       other.microsecond * 1000
                    ))
            return timedelta(days=days, seconds=t.seconds,
                             microseconds=(t.nanoseconds // 1000))
        if isinstance(other, Duration):
            return self.__add__(-other)
        if isinstance(other, timedelta):
            return self.__add__(-other)
        return NotImplemented",2460,2493
date,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The date.,"def date(self) -> Date:
        """"""The date.""""""
        return self.__date",2507,2509
time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The time without timezone info.,"def time(self) -> Time:
        """"""The time without timezone info.""""""
        return self.__time.replace(tzinfo=None)",2511,2513
timetz,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,The time with timezone info.,"def timetz(self) -> Time:
        """"""The time with timezone info.""""""
        return self.__time",2515,2517
as_timezone,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert this :class:`.DateTime` to another timezone.

:param tz: the new timezone

:returns: the same object if ``tz`` is :data:``None``.
    Else, a new :class:`.DateTime` that's the same point in time but in
    a different timezone.","def as_timezone(self, tz: _tzinfo) -> DateTime:
        """"""Convert this :class:`.DateTime` to another timezone.

        :param tz: the new timezone

        :returns: the same object if ``tz`` is :data:``None``.
            Else, a new :class:`.DateTime` that's the same point in time but in
            a different timezone.
        """"""
        if self.tzinfo is None:
            return self
        offset = t.cast(timedelta, self.utcoffset())
        utc = (self - offset).replace(tzinfo=tz)
        try:
            return tz.fromutc(utc)  # type: ignore
        except TypeError:
            # For timezone implementations not compatible with the custom
            # datetime implementations, we can't do better than this.
            native_utc = utc.to_native()
            native_res = tz.fromutc(native_utc)
            res = self.from_native(native_res)
            return res.replace(
                nanosecond=(native_res.microsecond * 1000
                            + self.nanosecond % 1000)
            )",2547,2571
utc_offset,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the date times utc offset.

See :meth:`.Time.utc_offset`.","def utc_offset(self) -> t.Optional[timedelta]:
        """"""Get the date times utc offset.

        See :meth:`.Time.utc_offset`.
        """"""

        return self.__time._utc_offset(self)",2573,2579
dst,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the daylight saving time adjustment (DST).

See :meth:`.Time.dst`.","def dst(self) -> t.Optional[timedelta]:
        """"""Get the daylight saving time adjustment (DST).

        See :meth:`.Time.dst`.
        """"""
        return self.__time.dst()",2581,2586
tzname,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the timezone name.

See :meth:`.Time.tzname`.","def tzname(self) -> t.Optional[str]:
        """"""Get the timezone name.

        See :meth:`.Time.tzname`.
        """"""
        return self.__time.tzname()",2588,2593
to_ordinal,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the ordinal of the :class:`.DateTime`'s date.

See :meth:`.Date.to_ordinal`","def to_ordinal(self) -> int:
        """"""Get the ordinal of the :class:`.DateTime`'s date.

        See :meth:`.Date.to_ordinal`
        """"""
        return self.__date.to_ordinal()",2601,2606
to_clock_time,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,Convert to :class:`.ClockTime`.,"def to_clock_time(self) -> ClockTime:
        """"""Convert to :class:`.ClockTime`.""""""
        ordinal_seconds = 86400 * (self.__date.to_ordinal() - 1)
        time_seconds, nanoseconds = divmod(self.__time.ticks, NANO_SECONDS)
        return ClockTime(ordinal_seconds + time_seconds, nanoseconds)",2608,2612
to_native,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Convert to a native Python :class:`datetime.datetime` value.

This conversion is lossy as the native time implementation only supports
a resolution of microseconds instead of nanoseconds.","def to_native(self) -> datetime:
        """"""Convert to a native Python :class:`datetime.datetime` value.

        This conversion is lossy as the native time implementation only supports
        a resolution of microseconds instead of nanoseconds.
        """"""
        y, mo, d = self.year_month_day
        h, m, s, ns = self.hour_minute_second_nanosecond
        ms = int(ns / 1000)
        tz = self.tzinfo
        return datetime(y, mo, d, h, m, s, ms, tz)",2614,2624
weekday,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the weekday.

See :meth:`.Date.weekday`","def weekday(self) -> int:
        """"""Get the weekday.

        See :meth:`.Date.weekday`
        """"""
        return self.__date.weekday()",2626,2631
iso_weekday,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get the ISO weekday.

See :meth:`.Date.iso_weekday`","def iso_weekday(self) -> int:
        """"""Get the ISO weekday.

        See :meth:`.Date.iso_weekday`
        """"""
        return self.__date.iso_weekday()",2633,2638
iso_calendar,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Get date as ISO tuple.

See :meth:`.Date.iso_calendar`","def iso_calendar(self) -> t.Tuple[int, int, int]:
        """"""Get date as ISO tuple.

        See :meth:`.Date.iso_calendar`
        """"""
        return self.__date.iso_calendar()",2640,2645
iso_format,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return the :class:`.DateTime` as ISO formatted string.

This method joins `self.date().iso_format()` (see
:meth:`.Date.iso_format`) and `self.timetz().iso_format()` (see
:meth:`.Time.iso_format`) with `sep` in between.

:param sep: the separator between the formatted date and time.","def iso_format(self, sep: str = ""T"") -> str:
        """"""Return the :class:`.DateTime` as ISO formatted string.

        This method joins `self.date().iso_format()` (see
        :meth:`.Date.iso_format`) and `self.timetz().iso_format()` (see
        :meth:`.Time.iso_format`) with `sep` in between.

        :param sep: the separator between the formatted date and time.
        """"""
        s = ""%s%s%s"" % (self.date().iso_format(), sep,
                        self.timetz().iso_format())
        time_tz = self.timetz()
        offset = time_tz.utc_offset()
        if offset is not None:
            # the time component will have taken care of formatting the offset
            return s
        offset = self.utc_offset()
        if offset is not None:
            s += ""%+03d:%02d"" % divmod(offset.total_seconds() // 60, 60)
        return s",2647,2666
__getattr__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Map standard library attribute names to local attribute names,
for compatibility.","def __getattr__(self, name):
        """""" Map standard library attribute names to local attribute names,
        for compatibility.
        """"""
        try:
            return {
                ""astimezone"": self.as_timezone,
                ""isocalendar"": self.iso_calendar,
                ""isoformat"": self.iso_format,
                ""isoweekday"": self.iso_weekday,
                ""strftime"": self.__format__,
                ""toordinal"": self.to_ordinal,
                ""timetuple"": self.time_tuple,
                ""utcoffset"": self.utc_offset,
                ""utctimetuple"": self.utc_time_tuple,
            }[name]
        except KeyError:
            raise AttributeError(""DateTime has no attribute %r"" % name)",2695,2712
replace,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return a :class:`.Date` with one or more components replaced.

:Keyword Arguments:
   * **year** (:class:`typing.SupportsIndex`):
     overwrite the year - default: `self.year`
   * **month** (:class:`typing.SupportsIndex`):
     overwrite the month - default: `self.month`
   * **day** (:class:`typing.SupportsIndex`):
     overwrite the day - default: `self.day`","def replace(self, **kwargs) -> Date:
            """"""Return a :class:`.Date` with one or more components replaced.

            :Keyword Arguments:
               * **year** (:class:`typing.SupportsIndex`):
                 overwrite the year - default: `self.year`
               * **month** (:class:`typing.SupportsIndex`):
                 overwrite the month - default: `self.month`
               * **day** (:class:`typing.SupportsIndex`):
                 overwrite the day - default: `self.day`
            """"""
            return Date(int(kwargs.get(""year"", self.__year)),
                        int(kwargs.get(""month"", self.__month)),
                        int(kwargs.get(""day"", self.__day)))",1226,1239
replace,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return a :class:`.Time` with one or more components replaced.

:Keyword Arguments:
   * **hour** (:class:`typing.SupportsIndex`):
     overwrite the hour - default: `self.hour`
   * **minute** (:class:`typing.SupportsIndex`):
     overwrite the minute - default: `self.minute`
   * **second** (:class:`typing.SupportsIndex`):
     overwrite the second - default: `int(self.second)`
   * **nanosecond** (:class:`typing.SupportsIndex`):
     overwrite the nanosecond - default: `self.nanosecond`
   * **tzinfo** (:class:`datetime.tzinfo` or `None`):
     overwrite the timezone - default: `self.tzinfo`","def replace(self, **kwargs) -> Time:
            """"""Return a :class:`.Time` with one or more components replaced.

            :Keyword Arguments:
               * **hour** (:class:`typing.SupportsIndex`):
                 overwrite the hour - default: `self.hour`
               * **minute** (:class:`typing.SupportsIndex`):
                 overwrite the minute - default: `self.minute`
               * **second** (:class:`typing.SupportsIndex`):
                 overwrite the second - default: `int(self.second)`
               * **nanosecond** (:class:`typing.SupportsIndex`):
                 overwrite the nanosecond - default: `self.nanosecond`
               * **tzinfo** (:class:`datetime.tzinfo` or `None`):
                 overwrite the timezone - default: `self.tzinfo`
            """"""
            return Time(hour=int(kwargs.get(""hour"", self.__hour)),
                        minute=int(kwargs.get(""minute"", self.__minute)),
                        second=int(kwargs.get(""second"", self.__second)),
                        nanosecond=int(kwargs.get(""nanosecond"",
                                                  self.__nanosecond)),
                        tzinfo=kwargs.get(""tzinfo"", self.__tzinfo))",1775,1795
replace,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/__init__.py,"Return a ``DateTime`` with one or more components replaced.

See :meth:`.Date.replace` and :meth:`.Time.replace` for available
arguments.","def replace(self, **kwargs) -> DateTime:
            """"""Return a ``DateTime`` with one or more components replaced.

            See :meth:`.Date.replace` and :meth:`.Time.replace` for available
            arguments.
            """"""
            date_ = self.__date.replace(**kwargs)
            time_ = self.__time.replace(**kwargs)
            return self.combine(date_, time_)",2537,2545
nano_add,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/_arithmetic.py,"    >>> 0.7 + 0.2
    0.8999999999999999
    >>> -0.7 + 0.2
    -0.49999999999999994
    >>> nano_add(0.7, 0.2)
    0.9
    >>> nano_add(-0.7, 0.2)
    -0.5

:param x:
:param y:
:returns:","def nano_add(x, y):
    """"""

        >>> 0.7 + 0.2
        0.8999999999999999
        >>> -0.7 + 0.2
        -0.49999999999999994
        >>> nano_add(0.7, 0.2)
        0.9
        >>> nano_add(-0.7, 0.2)
        -0.5

    :param x:
    :param y:
    :returns:
    """"""
    return (int(1000000000 * x) + int(1000000000 * y)) / 1000000000",32,48
nano_div,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/_arithmetic.py,"    >>> 0.7 / 0.2
    3.4999999999999996
    >>> -0.7 / 0.2
    -3.4999999999999996
    >>> nano_div(0.7, 0.2)
    3.5
    >>> nano_div(-0.7, 0.2)
    -3.5

:param x:
:param y:
:returns:","def nano_div(x, y):
    """"""

        >>> 0.7 / 0.2
        3.4999999999999996
        >>> -0.7 / 0.2
        -3.4999999999999996
        >>> nano_div(0.7, 0.2)
        3.5
        >>> nano_div(-0.7, 0.2)
        -3.5

    :param x:
    :param y:
    :returns:
    """"""
    return float(1000000000 * x) / int(1000000000 * y)",51,67
nano_divmod,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/_arithmetic.py,"    >>> divmod(0.7, 0.2)
    (3.0, 0.09999999999999992)
    >>> nano_divmod(0.7, 0.2)
    (3, 0.1)

:param x:
:param y:
:returns:","def nano_divmod(x, y):
    """"""

        >>> divmod(0.7, 0.2)
        (3.0, 0.09999999999999992)
        >>> nano_divmod(0.7, 0.2)
        (3, 0.1)

    :param x:
    :param y:
    :returns:
    """"""
    number = type(x)
    nx = int(1000000000 * x)
    ny = int(1000000000 * y)
    q, r = divmod(nx, ny)
    return int(q), number(r / 1000000000)",70,86
round_half_to_even,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/time/_arithmetic.py,"    >>> round_half_to_even(3)
    3
    >>> round_half_to_even(3.2)
    3
    >>> round_half_to_even(3.5)
    4
    >>> round_half_to_even(3.7)
    4
    >>> round_half_to_even(4)
    4
    >>> round_half_to_even(4.2)
    4
    >>> round_half_to_even(4.5)
    4
    >>> round_half_to_even(4.7)
    5

:param n:
:returns:","def round_half_to_even(n):
    """"""

        >>> round_half_to_even(3)
        3
        >>> round_half_to_even(3.2)
        3
        >>> round_half_to_even(3.5)
        4
        >>> round_half_to_even(3.7)
        4
        >>> round_half_to_even(4)
        4
        >>> round_half_to_even(4.2)
        4
        >>> round_half_to_even(4.5)
        4
        >>> round_half_to_even(4.7)
        5

    :param n:
    :returns:
    """"""
    ten_n = 10 * n
    if ten_n == int(ten_n) and ten_n % 10 == 5:
        up = int(n + 0.5)
        down = int(n - 0.5)
        return up if up % 2 == 0 else down
    else:
        return int(round(n))",104,133
unit_of_work,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_work/query.py,"Decorator giving extra control over transaction function configuration.

This function is a decorator for transaction functions that allows extra
control over how the transaction is carried out.

For example, a timeout may be applied::

    from neo4j import unit_of_work


    @unit_of_work(timeout=100)
    def count_people_tx(tx):
        result = tx.run(""MATCH (a:Person) RETURN count(a) AS persons"")
        record = result.single()
        return record[""persons""]

:param metadata:
    a dictionary with metadata.
    Specified metadata will be attached to the executing transaction
    and visible in the output of ``SHOW TRANSACTIONS YIELD *``
    It will also get logged to the ``query.log``.
    This functionality makes it easier to tag transactions and is
    equivalent to the ``dbms.setTXMetaData`` procedure, see
    https://neo4j.com/docs/cypher-manual/current/clauses/transaction-clauses/#query-listing-transactions
    and https://neo4j.com/docs/operations-manual/current/reference/procedures/
    for reference.
:type metadata: typing.Dict[str, typing.Any] | None

:param timeout:
    the transaction timeout in seconds.
    Transactions that execute longer than the configured timeout will
    be terminated by the database.
    This functionality allows user code to limit query/transaction
    execution time.
    The specified timeout overrides the default timeout configured in
    the database using the ``db.transaction.timeout`` setting
    (``dbms.transaction.timeout`` before Neo4j 5.0).
    Values higher than ``db.transaction.timeout`` will be ignored and
    will fall back to the default for server versions between 4.2 and
    5.2 (inclusive).
    The value should not represent a negative duration.
    A ``0`` duration will make the transaction execute indefinitely.
    :data:`None` will use the default timeout configured on the server.
:type timeout: float | None

:rtype: typing.Callable[[T], T]","def unit_of_work(
    metadata: t.Optional[t.Dict[str, t.Any]] = None,
    timeout: t.Optional[float] = None
) -> t.Callable[[_T], _T]:
    """"""Decorator giving extra control over transaction function configuration.

    This function is a decorator for transaction functions that allows extra
    control over how the transaction is carried out.

    For example, a timeout may be applied::

        from neo4j import unit_of_work


        @unit_of_work(timeout=100)
        def count_people_tx(tx):
            result = tx.run(""MATCH (a:Person) RETURN count(a) AS persons"")
            record = result.single()
            return record[""persons""]

    :param metadata:
        a dictionary with metadata.
        Specified metadata will be attached to the executing transaction
        and visible in the output of ``SHOW TRANSACTIONS YIELD *``
        It will also get logged to the ``query.log``.
        This functionality makes it easier to tag transactions and is
        equivalent to the ``dbms.setTXMetaData`` procedure, see
        https://neo4j.com/docs/cypher-manual/current/clauses/transaction-clauses/#query-listing-transactions
        and https://neo4j.com/docs/operations-manual/current/reference/procedures/
        for reference.
    :type metadata: typing.Dict[str, typing.Any] | None

    :param timeout:
        the transaction timeout in seconds.
        Transactions that execute longer than the configured timeout will
        be terminated by the database.
        This functionality allows user code to limit query/transaction
        execution time.
        The specified timeout overrides the default timeout configured in
        the database using the ``db.transaction.timeout`` setting
        (``dbms.transaction.timeout`` before Neo4j 5.0).
        Values higher than ``db.transaction.timeout`` will be ignored and
        will fall back to the default for server versions between 4.2 and
        5.2 (inclusive).
        The value should not represent a negative duration.
        A ``0`` duration will make the transaction execute indefinitely.
        :data:`None` will use the default timeout configured on the server.
    :type timeout: float | None

    :rtype: typing.Callable[[T], T]
    """"""

    def wrapper(f):

        def wrapped(*args, **kwargs):
            return f(*args, **kwargs)

        wrapped.metadata = metadata
        wrapped.timeout = timeout
        return wrapped

    return wrapper",87,148
summary_notifications,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_work/summary.py,"The same as ``notifications`` but in a parsed, structured form.

.. seealso:: :attr:`.notifications`, :class:`.SummaryNotification`

.. versionadded:: 5.7","def summary_notifications(self) -> t.List[SummaryNotification]:
        """"""The same as ``notifications`` but in a parsed, structured form.

        .. seealso:: :attr:`.notifications`, :class:`.SummaryNotification`

        .. versionadded:: 5.7
        """"""
        if getattr(self, ""_summary_notifications"", None) is None:
            self._summary_notifications = [
                SummaryNotification._from_metadata(n)
                for n in self.notifications or ()
            ]
        return self._summary_notifications",113,125
contains_updates,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_work/summary.py,"True if any of the counters except for system_updates, are greater
than 0. Otherwise False.","def contains_updates(self) -> bool:
        """"""True if any of the counters except for system_updates, are greater
        than 0. Otherwise False.""""""
        if self._contains_updates is not None:
            return self._contains_updates
        return bool(
            self.nodes_created or self.nodes_deleted
            or self.relationships_created or self.relationships_deleted
            or self.properties_set or self.labels_added
            or self.labels_removed or self.indexes_added
            or self.indexes_removed or self.constraints_added
            or self.constraints_removed
        )",197,209
contains_system_updates,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_work/summary.py,"True if the system database was updated, otherwise False.","def contains_system_updates(self) -> bool:
        """"""True if the system database was updated, otherwise False.""""""
        if self._contains_system_updates is not None:
            return self._contains_system_updates
        return self.system_updates > 0",212,216
static,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/auth_management.py,"Create a static auth manager.

The manager will always return the auth info provided at its creation.

Example::

    # NOTE: this example is for illustration purposes only.
    #       The driver will automatically wrap static auth info in a
    #       static auth manager.

    import neo4j
    from neo4j.auth_management import AuthManagers


    auth = neo4j.basic_auth(""neo4j"", ""password"")

    with neo4j.GraphDatabase.driver(
        ""neo4j://example.com:7687"",
        auth=AuthManagers.static(auth)
        # auth=auth  # this is equivalent
    ) as driver:
        ...  # do stuff

:param auth: The auth to return.

:returns:
    An instance of an implementation of :class:`.AuthManager` that
    always returns the same auth.

.. versionadded:: 5.8

.. versionchanged:: 5.14 Stabilized from preview.","def static(auth: _TAuth) -> AuthManager:
        """"""Create a static auth manager.

        The manager will always return the auth info provided at its creation.

        Example::

            # NOTE: this example is for illustration purposes only.
            #       The driver will automatically wrap static auth info in a
            #       static auth manager.

            import neo4j
            from neo4j.auth_management import AuthManagers


            auth = neo4j.basic_auth(""neo4j"", ""password"")

            with neo4j.GraphDatabase.driver(
                ""neo4j://example.com:7687"",
                auth=AuthManagers.static(auth)
                # auth=auth  # this is equivalent
            ) as driver:
                ...  # do stuff

        :param auth: The auth to return.

        :returns:
            An instance of an implementation of :class:`.AuthManager` that
            always returns the same auth.

        .. versionadded:: 5.8

        .. versionchanged:: 5.14 Stabilized from preview.
        """"""
        return StaticAuthManager(auth)",126,160
basic,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/auth_management.py,"Create an auth manager handling basic auth password rotation.

This factory wraps the provider function in an auth manager
implementation that caches the provided auth info until the server
notifies the driver that the auth info has expired (by returning
an error that indicates that the password is invalid).

Note that this implies that the provider function will be called again
if it provides wrong auth info, potentially deferring failure due to a
wrong password or username.

.. warning::

    The provider function **must not** interact with the driver in any
    way as this can cause deadlocks and undefined behaviour.

    The provider function must only ever return auth information
    belonging to the same identity.
    Switching identities is undefined behavior.
    You may use :ref:`session-level authentication<session-auth-ref>`
    for such use-cases.

Example::

    import neo4j
    from neo4j.auth_management import (
        AuthManagers,
        ExpiringAuth,
    )


    def auth_provider():
        # some way of getting a token
        user, password = get_current_auth()
        return (user, password)


    with neo4j.GraphDatabase.driver(
        ""neo4j://example.com:7687"",
        auth=AuthManagers.basic(auth_provider)
    ) as driver:
        ...  # do stuff

:param provider:
    A callable that provides new auth info whenever the server notifies
    the driver that the previous auth info is invalid.

:returns:
    An instance of an implementation of :class:`.AuthManager` that
    returns auth info from the given provider and refreshes it, calling
    the provider again, when the auth info was rejected by the server.

.. versionadded:: 5.12

.. versionchanged:: 5.14 Stabilized from preview.","def basic(
        provider: t.Callable[[], t.Union[_TAuth]]
    ) -> AuthManager:
        """"""Create an auth manager handling basic auth password rotation.

        This factory wraps the provider function in an auth manager
        implementation that caches the provided auth info until the server
        notifies the driver that the auth info has expired (by returning
        an error that indicates that the password is invalid).

        Note that this implies that the provider function will be called again
        if it provides wrong auth info, potentially deferring failure due to a
        wrong password or username.

        .. warning::

            The provider function **must not** interact with the driver in any
            way as this can cause deadlocks and undefined behaviour.

            The provider function must only ever return auth information
            belonging to the same identity.
            Switching identities is undefined behavior.
            You may use :ref:`session-level authentication<session-auth-ref>`
            for such use-cases.

        Example::

            import neo4j
            from neo4j.auth_management import (
                AuthManagers,
                ExpiringAuth,
            )


            def auth_provider():
                # some way of getting a token
                user, password = get_current_auth()
                return (user, password)


            with neo4j.GraphDatabase.driver(
                ""neo4j://example.com:7687"",
                auth=AuthManagers.basic(auth_provider)
            ) as driver:
                ...  # do stuff

        :param provider:
            A callable that provides new auth info whenever the server notifies
            the driver that the previous auth info is invalid.

        :returns:
            An instance of an implementation of :class:`.AuthManager` that
            returns auth info from the given provider and refreshes it, calling
            the provider again, when the auth info was rejected by the server.

        .. versionadded:: 5.12

        .. versionchanged:: 5.14 Stabilized from preview.
        """"""
        handled_codes = frozenset((""Neo.ClientError.Security.Unauthorized"",))

        def wrapped_provider() -> ExpiringAuth:
            return ExpiringAuth(provider())

        return Neo4jAuthTokenManager(wrapped_provider, handled_codes)",163,227
bearer,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/auth_management.py,"Create an auth manager for potentially expiring bearer auth tokens.

This factory wraps the provider function in an auth manager
implementation that caches the provided auth info until either the
:attr:`.ExpiringAuth.expires_at` exceeded or the server notified the
driver that the auth info has expired (by returning an error that
indicates that the bearer auth token has expired).

.. warning::

    The provider function **must not** interact with the driver in any
    way as this can cause deadlocks and undefined behaviour.

    The provider function must only ever return auth information
    belonging to the same identity.
    Switching identities is undefined behavior.
    You may use :ref:`session-level authentication<session-auth-ref>`
    for such use-cases.

Example::

    import neo4j
    from neo4j.auth_management import (
        AuthManagers,
        ExpiringAuth,
    )


    def auth_provider():
        # some way of getting a token
        sso_token = get_sso_token()
        # assume we know our tokens expire every 60 seconds
        expires_in = 60

        return ExpiringAuth(
            auth=neo4j.bearer_auth(sso_token),
            # Include a little buffer so that we fetch a new token
            # *before* the old one expires
            expires_in=expires_in - 10
        )


    with neo4j.GraphDatabase.driver(
        ""neo4j://example.com:7687"",
        auth=AuthManagers.bearer(auth_provider)
    ) as driver:
        ...  # do stuff

:param provider:
    A callable that provides a :class:`.ExpiringAuth` instance.

:returns:
    An instance of an implementation of :class:`.AuthManager` that
    returns auth info from the given provider and refreshes it, calling
    the provider again, when the auth info expires (either because it's
    reached its expiry time or because the server flagged it as
    expired).

.. versionadded:: 5.12

.. versionchanged:: 5.14 Stabilized from preview.","def bearer(
        provider: t.Callable[[], t.Union[ExpiringAuth]]
    ) -> AuthManager:
        """"""Create an auth manager for potentially expiring bearer auth tokens.

        This factory wraps the provider function in an auth manager
        implementation that caches the provided auth info until either the
        :attr:`.ExpiringAuth.expires_at` exceeded or the server notified the
        driver that the auth info has expired (by returning an error that
        indicates that the bearer auth token has expired).

        .. warning::

            The provider function **must not** interact with the driver in any
            way as this can cause deadlocks and undefined behaviour.

            The provider function must only ever return auth information
            belonging to the same identity.
            Switching identities is undefined behavior.
            You may use :ref:`session-level authentication<session-auth-ref>`
            for such use-cases.

        Example::

            import neo4j
            from neo4j.auth_management import (
                AuthManagers,
                ExpiringAuth,
            )


            def auth_provider():
                # some way of getting a token
                sso_token = get_sso_token()
                # assume we know our tokens expire every 60 seconds
                expires_in = 60

                return ExpiringAuth(
                    auth=neo4j.bearer_auth(sso_token),
                    # Include a little buffer so that we fetch a new token
                    # *before* the old one expires
                    expires_in=expires_in - 10
                )


            with neo4j.GraphDatabase.driver(
                ""neo4j://example.com:7687"",
                auth=AuthManagers.bearer(auth_provider)
            ) as driver:
                ...  # do stuff

        :param provider:
            A callable that provides a :class:`.ExpiringAuth` instance.

        :returns:
            An instance of an implementation of :class:`.AuthManager` that
            returns auth info from the given provider and refreshes it, calling
            the provider again, when the auth info expires (either because it's
            reached its expiry time or because the server flagged it as
            expired).

        .. versionadded:: 5.12

        .. versionchanged:: 5.14 Stabilized from preview.
        """"""
        handled_codes = frozenset((
            ""Neo.ClientError.Security.TokenExpired"",
            ""Neo.ClientError.Security.Unauthorized"",
        ))
        return Neo4jAuthTokenManager(provider, handled_codes)",230,299
update_certificate,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/auth_management.py,Update the certificate to use for new connections.,"def update_certificate(self, cert: ClientCertificate) -> None:
        """"""
        Update the certificate to use for new connections.
        """"""
        with self._lock:
            self._cert = cert",383,388
static,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/auth_management.py,"Create a static client certificate provider.

The provider simply makes the driver use the given certificate for all
connections.","def static(cert: ClientCertificate) -> ClientCertificateProvider:
        """"""
        Create a static client certificate provider.

        The provider simply makes the driver use the given certificate for all
        connections.
        """"""
        return _StaticClientCertificateProvider(cert)",403,410
rotating,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/auth_management.py,"Create certificate provider that allows for rotating certificates.

.. seealso:: :class:`.RotatingClientCertificateProvider`","def rotating(
        initial_cert: ClientCertificate
    ) -> RotatingClientCertificateProvider:
        """"""
        Create certificate provider that allows for rotating certificates.

        .. seealso:: :class:`.RotatingClientCertificateProvider`
        """"""
        return RotatingClientCertificateProvider(initial_cert)",414,422
bookmark_manager,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Create a :class:`.BookmarkManager` with default implementation.

Basic usage example to configure sessions with the built-in bookmark
manager implementation so that all work is automatically causally
chained (i.e., all reads can observe all previous writes even in a
clustered setup)::

    import neo4j


    # omitting closing the driver for brevity
    driver = neo4j.GraphDatabase.driver(...)
    bookmark_manager = neo4j.GraphDatabase.bookmark_manager(...)

    with driver.session(
        bookmark_manager=bookmark_manager
    ) as session1:
        with driver.session(
            bookmark_manager=bookmark_manager,
            access_mode=neo4j.READ_ACCESS
        ) as session2:
            result1 = session1.run(""<WRITE_QUERY>"")
            result1.consume()
            # READ_QUERY is guaranteed to see what WRITE_QUERY wrote.
            result2 = session2.run(""<READ_QUERY>"")
            result2.consume()

This is a very contrived example, and in this particular case, having
both queries in the same session has the exact same effect and might
even be more performant. However, when dealing with sessions spanning
multiple threads, Tasks, processes, or even hosts, the bookmark
manager can come in handy as sessions are not safe to be used
concurrently.

:param initial_bookmarks:
    The initial set of bookmarks. The returned bookmark manager will
    use this to initialize its internal bookmarks.
:param bookmarks_supplier:
    Function which will be called every time the default bookmark
    manager's method :meth:`.BookmarkManager.get_bookmarks`
    gets called.
    The function takes no arguments and must return a
    :class:`.Bookmarks` object. The result of ``bookmarks_supplier``
    will then be concatenated with the internal set of bookmarks and
    used to configure the session in creation. It will, however, not
    update the internal set of bookmarks.
:param bookmarks_consumer:
    Function which will be called whenever the set of bookmarks
    handled by the bookmark manager gets updated with the new
    internal bookmark set. It will receive the new set of bookmarks
    as a :class:`.Bookmarks` object and return :data:`None`.

:returns: A default implementation of :class:`.BookmarkManager`.

.. versionadded:: 5.0

.. versionchanged:: 5.3
    The bookmark manager no longer tracks bookmarks per database.
    This effectively changes the signature of almost all bookmark
    manager related methods:

    * ``initial_bookmarks`` is no longer a mapping from database name
      to bookmarks but plain bookmarks.
    * ``bookmarks_supplier`` no longer receives the database name as
      an argument.
    * ``bookmarks_consumer`` no longer receives the database name as
      an argument.

.. versionchanged:: 5.8 Stabilized from experimental.","def bookmark_manager(
        cls,
        initial_bookmarks: t.Union[None, Bookmarks, t.Iterable[str]] = None,
        bookmarks_supplier: t.Optional[_TBmSupplier] = None,
        bookmarks_consumer: t.Optional[_TBmConsumer] = None
    ) -> BookmarkManager:
        """"""Create a :class:`.BookmarkManager` with default implementation.

        Basic usage example to configure sessions with the built-in bookmark
        manager implementation so that all work is automatically causally
        chained (i.e., all reads can observe all previous writes even in a
        clustered setup)::

            import neo4j


            # omitting closing the driver for brevity
            driver = neo4j.GraphDatabase.driver(...)
            bookmark_manager = neo4j.GraphDatabase.bookmark_manager(...)

            with driver.session(
                bookmark_manager=bookmark_manager
            ) as session1:
                with driver.session(
                    bookmark_manager=bookmark_manager,
                    access_mode=neo4j.READ_ACCESS
                ) as session2:
                    result1 = session1.run(""<WRITE_QUERY>"")
                    result1.consume()
                    # READ_QUERY is guaranteed to see what WRITE_QUERY wrote.
                    result2 = session2.run(""<READ_QUERY>"")
                    result2.consume()

        This is a very contrived example, and in this particular case, having
        both queries in the same session has the exact same effect and might
        even be more performant. However, when dealing with sessions spanning
        multiple threads, Tasks, processes, or even hosts, the bookmark
        manager can come in handy as sessions are not safe to be used
        concurrently.

        :param initial_bookmarks:
            The initial set of bookmarks. The returned bookmark manager will
            use this to initialize its internal bookmarks.
        :param bookmarks_supplier:
            Function which will be called every time the default bookmark
            manager's method :meth:`.BookmarkManager.get_bookmarks`
            gets called.
            The function takes no arguments and must return a
            :class:`.Bookmarks` object. The result of ``bookmarks_supplier``
            will then be concatenated with the internal set of bookmarks and
            used to configure the session in creation. It will, however, not
            update the internal set of bookmarks.
        :param bookmarks_consumer:
            Function which will be called whenever the set of bookmarks
            handled by the bookmark manager gets updated with the new
            internal bookmark set. It will receive the new set of bookmarks
            as a :class:`.Bookmarks` object and return :data:`None`.

        :returns: A default implementation of :class:`.BookmarkManager`.

        .. versionadded:: 5.0

        .. versionchanged:: 5.3
            The bookmark manager no longer tracks bookmarks per database.
            This effectively changes the signature of almost all bookmark
            manager related methods:

            * ``initial_bookmarks`` is no longer a mapping from database name
              to bookmarks but plain bookmarks.
            * ``bookmarks_supplier`` no longer receives the database name as
              an argument.
            * ``bookmarks_consumer`` no longer receives the database name as
              an argument.

        .. versionchanged:: 5.8 Stabilized from experimental.
        """"""
        return Neo4jBookmarkManager(
            initial_bookmarks=initial_bookmarks,
            bookmarks_supplier=bookmarks_supplier,
            bookmarks_consumer=bookmarks_consumer
        )",314,394
bolt_driver,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Create a driver for direct Bolt server access that uses
socket I/O and thread-based concurrency.","def bolt_driver(cls, target, **config):
        """""" Create a driver for direct Bolt server access that uses
        socket I/O and thread-based concurrency.
        """"""
        from .._exceptions import (
            BoltHandshakeError,
            BoltSecurityError,
        )

        try:
            return BoltDriver.open(target, **config)
        except (BoltHandshakeError, BoltSecurityError) as error:
            from ..exceptions import ServiceUnavailable
            raise ServiceUnavailable(str(error)) from error",397,410
neo4j_driver,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Create a driver for routing-capable Neo4j service access
that uses socket I/O and thread-based concurrency.","def neo4j_driver(cls, *targets, routing_context=None, **config):
        """""" Create a driver for routing-capable Neo4j service access
        that uses socket I/O and thread-based concurrency.
        """"""

        # TODO: 6.0 - adjust signature to only take one target
        if len(targets) > 1:
            deprecation_warn(
                ""Creating a routing driver with multiple targets is ""
                ""deprecated. The driver only uses the first target anyway. ""
                ""The method signature will change in a future release."",
            )

        from .._exceptions import (
            BoltHandshakeError,
            BoltSecurityError,
        )

        try:
            return Neo4jDriver.open(*targets, routing_context=routing_context, **config)
        except (BoltHandshakeError, BoltSecurityError) as error:
            from ..exceptions import ServiceUnavailable
            raise ServiceUnavailable(str(error)) from error",413,435
parse_target,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Parse a target string to produce an address.
        ","def parse_target(cls, target):
        """""" Parse a target string to produce an address.
        """"""
        if not target:
            target = cls.default_target
        address = Address.parse(target, default_host=cls.default_host,
                                default_port=cls.default_port)
        return address",453,460
parse_targets,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Parse a sequence of target strings to produce an address
list.","def parse_targets(cls, *targets):
        """""" Parse a sequence of target strings to produce an address
        list.
        """"""
        targets = "" "".join(targets)
        if not targets:
            targets = cls.default_targets
        addresses = Address.parse_list(targets, default_host=cls.default_host, default_port=cls.default_port)
        return addresses",478,486
encrypted,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,Indicate whether the driver was configured to use encryption.,"def encrypted(self) -> bool:
        """"""Indicate whether the driver was configured to use encryption.""""""
        return bool(self._pool.pool_config.encrypted)",546,548
close,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Shut down, closing any open connections in the pool.
        ","def close(self) -> None:
        """""" Shut down, closing any open connections in the pool.
        """"""
        # TODO: 6.0 - NOOP if already closed
        # if self._closed:
        #     return
        try:
            self._pool.close()
        except asyncio.CancelledError:
            self._closed = True
            raise
        self._closed = True",613,624
execute_query,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Execute a query in a transaction function and return all results.

This method is a handy wrapper for lower-level driver APIs like
sessions, transactions, and transaction functions. It is intended
for simple use cases where there is no need for managing all possible
options.

The internal usage of transaction functions provides a retry-mechanism
for appropriate errors. Furthermore, this means that queries using
``CALL {} IN TRANSACTIONS`` or the older ``USING PERIODIC COMMIT``
will not work (use :meth:`Session.run` for these).

The method is roughly equivalent to::

    def execute_query(
        query_, parameters_, routing_, database_, impersonated_user_,
        bookmark_manager_, auth_, result_transformer_, **kwargs
    ):
        @unit_of_work(query_.metadata, query_.timeout)
        def work(tx):
            result = tx.run(query_.text, parameters_, **kwargs)
            return result_transformer_(result)

        with driver.session(
            database=database_,
            impersonated_user=impersonated_user_,
            bookmark_manager=bookmark_manager_,
            auth=auth_,
        ) as session:
            if routing_ == RoutingControl.WRITE:
                return session.execute_write(work)
            elif routing_ == RoutingControl.READ:
                return session.execute_read(work)

Usage example::

    from typing import List

    import neo4j


    def example(driver: neo4j.Driver) -> List[str]:
        """"""Get the name of all 42 year-olds.""""""
        records, summary, keys = driver.execute_query(
            ""MATCH (p:Person {age: $age}) RETURN p.name"",
            {""age"": 42},
            routing_=neo4j.RoutingControl.READ,  # or just ""r""
            database_=""neo4j"",
        )
        assert keys == [""p.name""]  # not needed, just for illustration
        # log_summary(summary)  # log some metadata
        return [str(record[""p.name""]) for record in records]
        # or: return [str(record[0]) for record in records]
        # or even: return list(map(lambda r: str(r[0]), records))

Another example::

    import neo4j


    def example(driver: neo4j.Driver) -> int:
        """"""Call all young people ""My dear"" and get their count.""""""
        record = driver.execute_query(
            ""MATCH (p:Person) WHERE p.age <= $age ""
            ""SET p.nickname = 'My dear' ""
            ""RETURN count(*)"",
            # optional routing parameter, as write is default
            # routing_=neo4j.RoutingControl.WRITE,  # or just ""w"",
            database_=""neo4j"",
            result_transformer_=neo4j.Result.single,
            age=15,
        )
        assert record is not None  # for typechecking and illustration
        count = record[0]
        assert isinstance(count, int)
        return count

:param query_:
    Cypher query to execute.
    Use a :class:`.Query` object to pass a query with additional
    transaction configuration.
:type query_: typing.LiteralString | Query
:param parameters_: parameters to use in the query
:type parameters_: typing.Optional[typing.Dict[str, typing.Any]]
:param routing_:
    Whether to route the query to a reader (follower/read replica) or
    a writer (leader) in the cluster. Default is to route to a writer.
:type routing_: RoutingControl
:param database_:
    Database to execute the query against.

    None (default) uses the database configured on the server side.

    .. Note::
        It is recommended to always specify the database explicitly
        when possible. This allows the driver to work more efficiently,
        as it will not have to resolve the default database first.

    See also the Session config :ref:`database-ref`.
:type database_: typing.Optional[str]
:param impersonated_user_:
    Name of the user to impersonate.

    This means that all query will be executed in the security context
    of the impersonated user. For this, the user for which the
    :class:`Driver` has been created needs to have the appropriate
    permissions.

    See also the Session config :ref:`impersonated-user-ref`.
:type impersonated_user_: typing.Optional[str]
:param auth_:
    Authentication information to use for this query.

    By default, the driver configuration is used.

    See also the Session config :ref:`session-auth-ref`.
:type auth_: typing.Tuple[typing.Any, typing.Any] | Auth | None
:param result_transformer_:
    A function that gets passed the :class:`neo4j.Result` object
    resulting from the query and converts it to a different type. The
    result of the transformer function is returned by this method.

    .. warning::

        The transformer function must **not** return the
        :class:`neo4j.Result` itself.

    .. warning::

        N.B. the driver might retry the underlying transaction so the
        transformer might get invoked more than once (with different
        :class:`neo4j.Result` objects).
        Therefore, it needs to be idempotent (i.e., have the same
        effect, regardless if called once or many times).

    Example transformer that checks that exactly one record is in the
    result stream, then returns the record and the result summary::

        from typing import Tuple

        import neo4j


        def transformer(
            result: neo4j.Result
        ) -> Tuple[neo4j.Record, neo4j.ResultSummary]:
            record = result.single(strict=True)
            summary = result.consume()
            return record, summary

    Note that methods of :class:`neo4j.Result` that don't take
    mandatory arguments can be used directly as transformer functions.
    For example::

        import neo4j


        def example(driver: neo4j.Driver) -> neo4j.Record::
            record = driver.execute_query(
                ""SOME QUERY"",
                result_transformer_=neo4j.Result.single
            )


        # is equivalent to:


        def transformer(result: neo4j.Result) -> neo4j.Record:
            return result.single()


        def example(driver: neo4j.Driver) -> neo4j.Record::
            record = driver.execute_query(
                ""SOME QUERY"",
                result_transformer_=transformer
            )

:type result_transformer_:
    typing.Callable[[Result], typing.Union[T]]
:param bookmark_manager_:
    Specify a bookmark manager to use.

    If present, the bookmark manager is used to keep the query causally
    consistent with all work executed using the same bookmark manager.

    Defaults to the driver's :attr:`.execute_query_bookmark_manager`.

    Pass :data:`None` to disable causal consistency.
:type bookmark_manager_: BookmarkManager | BookmarkManager | None
:param kwargs: additional keyword parameters. None of these can end
    with a single underscore. This is to avoid collisions with the
    keyword configuration parameters of this method. If you need to
    pass such a parameter, use the ``parameters_`` parameter instead.
    Parameters passed as kwargs take precedence over those passed in
    ``parameters_``.
:type kwargs: typing.Any

:returns: the result of the ``result_transformer_``
:rtype: T

.. versionadded:: 5.5

.. versionchanged:: 5.8

    * Added ``auth_`` parameter in preview.
    * Stabilized from experimental.

.. versionchanged:: 5.14
    Stabilized ``auth_`` parameter from preview.

.. versionchanged:: 5.15
    The ``query_`` parameter now also accepts a :class:`.Query` object
    instead of only :class:`str`.","def execute_query(
        self,
        query_: t.Union[te.LiteralString, Query],
        parameters_: t.Optional[t.Dict[str, t.Any]] = None,
        routing_: T_RoutingControl = RoutingControl.WRITE,
        database_: t.Optional[str] = None,
        impersonated_user_: t.Optional[str] = None,
        bookmark_manager_: t.Union[
            BookmarkManager, BookmarkManager, None,
            te.Literal[_DefaultEnum.default]
        ] = _default,
        auth_: _TAuth = None,
        result_transformer_: t.Callable[
            [Result], t.Union[t.Any]
        ] = Result.to_eager_result,
        **kwargs: t.Any
    ) -> t.Any:
        """"""Execute a query in a transaction function and return all results.

        This method is a handy wrapper for lower-level driver APIs like
        sessions, transactions, and transaction functions. It is intended
        for simple use cases where there is no need for managing all possible
        options.

        The internal usage of transaction functions provides a retry-mechanism
        for appropriate errors. Furthermore, this means that queries using
        ``CALL {} IN TRANSACTIONS`` or the older ``USING PERIODIC COMMIT``
        will not work (use :meth:`Session.run` for these).

        The method is roughly equivalent to::

            def execute_query(
                query_, parameters_, routing_, database_, impersonated_user_,
                bookmark_manager_, auth_, result_transformer_, **kwargs
            ):
                @unit_of_work(query_.metadata, query_.timeout)
                def work(tx):
                    result = tx.run(query_.text, parameters_, **kwargs)
                    return result_transformer_(result)

                with driver.session(
                    database=database_,
                    impersonated_user=impersonated_user_,
                    bookmark_manager=bookmark_manager_,
                    auth=auth_,
                ) as session:
                    if routing_ == RoutingControl.WRITE:
                        return session.execute_write(work)
                    elif routing_ == RoutingControl.READ:
                        return session.execute_read(work)

        Usage example::

            from typing import List

            import neo4j


            def example(driver: neo4j.Driver) -> List[str]:
                \""""""Get the name of all 42 year-olds.\""""""
                records, summary, keys = driver.execute_query(
                    ""MATCH (p:Person {age: $age}) RETURN p.name"",
                    {""age"": 42},
                    routing_=neo4j.RoutingControl.READ,  # or just ""r""
                    database_=""neo4j"",
                )
                assert keys == [""p.name""]  # not needed, just for illustration
                # log_summary(summary)  # log some metadata
                return [str(record[""p.name""]) for record in records]
                # or: return [str(record[0]) for record in records]
                # or even: return list(map(lambda r: str(r[0]), records))

        Another example::

            import neo4j


            def example(driver: neo4j.Driver) -> int:
                \""""""Call all young people ""My dear"" and get their count.\""""""
                record = driver.execute_query(
                    ""MATCH (p:Person) WHERE p.age <= $age ""
                    ""SET p.nickname = 'My dear' ""
                    ""RETURN count(*)"",
                    # optional routing parameter, as write is default
                    # routing_=neo4j.RoutingControl.WRITE,  # or just ""w"",
                    database_=""neo4j"",
                    result_transformer_=neo4j.Result.single,
                    age=15,
                )
                assert record is not None  # for typechecking and illustration
                count = record[0]
                assert isinstance(count, int)
                return count

        :param query_:
            Cypher query to execute.
            Use a :class:`.Query` object to pass a query with additional
            transaction configuration.
        :type query_: typing.LiteralString | Query
        :param parameters_: parameters to use in the query
        :type parameters_: typing.Optional[typing.Dict[str, typing.Any]]
        :param routing_:
            Whether to route the query to a reader (follower/read replica) or
            a writer (leader) in the cluster. Default is to route to a writer.
        :type routing_: RoutingControl
        :param database_:
            Database to execute the query against.

            None (default) uses the database configured on the server side.

            .. Note::
                It is recommended to always specify the database explicitly
                when possible. This allows the driver to work more efficiently,
                as it will not have to resolve the default database first.

            See also the Session config :ref:`database-ref`.
        :type database_: typing.Optional[str]
        :param impersonated_user_:
            Name of the user to impersonate.

            This means that all query will be executed in the security context
            of the impersonated user. For this, the user for which the
            :class:`Driver` has been created needs to have the appropriate
            permissions.

            See also the Session config :ref:`impersonated-user-ref`.
        :type impersonated_user_: typing.Optional[str]
        :param auth_:
            Authentication information to use for this query.

            By default, the driver configuration is used.

            See also the Session config :ref:`session-auth-ref`.
        :type auth_: typing.Tuple[typing.Any, typing.Any] | Auth | None
        :param result_transformer_:
            A function that gets passed the :class:`neo4j.Result` object
            resulting from the query and converts it to a different type. The
            result of the transformer function is returned by this method.

            .. warning::

                The transformer function must **not** return the
                :class:`neo4j.Result` itself.

            .. warning::

                N.B. the driver might retry the underlying transaction so the
                transformer might get invoked more than once (with different
                :class:`neo4j.Result` objects).
                Therefore, it needs to be idempotent (i.e., have the same
                effect, regardless if called once or many times).

            Example transformer that checks that exactly one record is in the
            result stream, then returns the record and the result summary::

                from typing import Tuple

                import neo4j


                def transformer(
                    result: neo4j.Result
                ) -> Tuple[neo4j.Record, neo4j.ResultSummary]:
                    record = result.single(strict=True)
                    summary = result.consume()
                    return record, summary

            Note that methods of :class:`neo4j.Result` that don't take
            mandatory arguments can be used directly as transformer functions.
            For example::

                import neo4j


                def example(driver: neo4j.Driver) -> neo4j.Record::
                    record = driver.execute_query(
                        ""SOME QUERY"",
                        result_transformer_=neo4j.Result.single
                    )


                # is equivalent to:


                def transformer(result: neo4j.Result) -> neo4j.Record:
                    return result.single()


                def example(driver: neo4j.Driver) -> neo4j.Record::
                    record = driver.execute_query(
                        ""SOME QUERY"",
                        result_transformer_=transformer
                    )

        :type result_transformer_:
            typing.Callable[[Result], typing.Union[T]]
        :param bookmark_manager_:
            Specify a bookmark manager to use.

            If present, the bookmark manager is used to keep the query causally
            consistent with all work executed using the same bookmark manager.

            Defaults to the driver's :attr:`.execute_query_bookmark_manager`.

            Pass :data:`None` to disable causal consistency.
        :type bookmark_manager_: BookmarkManager | BookmarkManager | None
        :param kwargs: additional keyword parameters. None of these can end
            with a single underscore. This is to avoid collisions with the
            keyword configuration parameters of this method. If you need to
            pass such a parameter, use the ``parameters_`` parameter instead.
            Parameters passed as kwargs take precedence over those passed in
            ``parameters_``.
        :type kwargs: typing.Any

        :returns: the result of the ``result_transformer_``
        :rtype: T

        .. versionadded:: 5.5

        .. versionchanged:: 5.8

            * Added ``auth_`` parameter in preview.
            * Stabilized from experimental.

        .. versionchanged:: 5.14
            Stabilized ``auth_`` parameter from preview.

        .. versionchanged:: 5.15
            The ``query_`` parameter now also accepts a :class:`.Query` object
            instead of only :class:`str`.
        """"""
        self._check_state()
        invalid_kwargs = [k for k in kwargs if
                          k[-2:-1] != ""_"" and k[-1:] == ""_""]
        if invalid_kwargs:
            raise ValueError(
                ""keyword parameters must not end with a single '_'. Found: %r""
                ""\nYou either misspelled an existing configuration parameter ""
                ""or tried to send a query parameter that is reserved. In the ""
                ""latter case, use the `parameters_` dictionary instead.""
                % invalid_kwargs
            )
        if isinstance(query_, Query):
            timeout = query_.timeout
            metadata = query_.metadata
            query_str = query_.text
            work = unit_of_work(metadata, timeout)(_work)
        else:
            query_str = query_
            work = _work
        parameters = dict(parameters_ or {}, **kwargs)

        if bookmark_manager_ is _default:
            bookmark_manager_ = self._query_bookmark_manager
        assert bookmark_manager_ is not _default

        session_config = self._read_session_config(
            {
                ""database"": database_,
                ""impersonated_user"": impersonated_user_,
                ""bookmark_manager"": bookmark_manager_,
                ""auth"": auth_,
            }
        )
        session = self._session(session_config)
        with session:
            if routing_ == RoutingControl.WRITE:
                access_mode = WRITE_ACCESS
            elif routing_ == RoutingControl.READ:
                access_mode = READ_ACCESS
            else:
                raise ValueError(""Invalid routing control value: %r""
                                 % routing_)
            with session._pipelined_begin:
                return session._run_transaction(
                    access_mode, TelemetryAPI.DRIVER,
                    work, (query_str, parameters, result_transformer_), {}
                )",665,942
execute_query_bookmark_manager,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"The driver's default query bookmark manager.

This is the default :class:`.BookmarkManager` used by
:meth:`.execute_query`. This can be used to causally chain
:meth:`.execute_query` calls and sessions. Example::

    def example(driver: neo4j.Driver) -> None:
        driver.execute_query(""<QUERY 1>"")
        with driver.session(
            bookmark_manager=driver.execute_query_bookmark_manager
        ) as session:
            # every query inside this session will be causally chained
            # (i.e., can read what was written by <QUERY 1>)
            session.run(""<QUERY 2>"")
        # subsequent execute_query calls will be causally chained
        # (i.e., can read what was written by <QUERY 2>)
        driver.execute_query(""<QUERY 3>"")

.. versionadded:: 5.5

.. versionchanged:: 5.8

    * Renamed from ``query_bookmark_manager`` to
      ``execute_query_bookmark_manager``.
    * Stabilized from experimental.","def execute_query_bookmark_manager(self) -> BookmarkManager:
        """"""The driver's default query bookmark manager.

        This is the default :class:`.BookmarkManager` used by
        :meth:`.execute_query`. This can be used to causally chain
        :meth:`.execute_query` calls and sessions. Example::

            def example(driver: neo4j.Driver) -> None:
                driver.execute_query(""<QUERY 1>"")
                with driver.session(
                    bookmark_manager=driver.execute_query_bookmark_manager
                ) as session:
                    # every query inside this session will be causally chained
                    # (i.e., can read what was written by <QUERY 1>)
                    session.run(""<QUERY 2>"")
                # subsequent execute_query calls will be causally chained
                # (i.e., can read what was written by <QUERY 2>)
                driver.execute_query(""<QUERY 3>"")

        .. versionadded:: 5.5

        .. versionchanged:: 5.8

            * Renamed from ``query_bookmark_manager`` to
              ``execute_query_bookmark_manager``.
            * Stabilized from experimental.
        """"""
        return self._query_bookmark_manager",945,972
supports_multi_db,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Check if the server or cluster supports multi-databases.

:returns: Returns true if the server or cluster the driver connects to
    supports multi-databases, otherwise false.

.. note::
    Feature support query based solely on the Bolt protocol version.
    The feature might still be disabled on the server side even if this
    function return :data:`True`. It just guarantees that the driver
    won't throw a :exc:`.ConfigurationError` when trying to use this
    driver feature.","def supports_multi_db(self) -> bool:
        """""" Check if the server or cluster supports multi-databases.

        :returns: Returns true if the server or cluster the driver connects to
            supports multi-databases, otherwise false.

        .. note::
            Feature support query based solely on the Bolt protocol version.
            The feature might still be disabled on the server side even if this
            function return :data:`True`. It just guarantees that the driver
            won't throw a :exc:`.ConfigurationError` when trying to use this
            driver feature.
        """"""
        self._check_state()
        session_config = self._read_session_config({})
        with self._session(session_config) as session:
            session._connect(READ_ACCESS)
            assert session._connection
            return session._connection.supports_multiple_databases",1119,1137
supports_session_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Check if the remote supports connection re-authentication.

:returns: Returns true if the server or cluster the driver connects to
    supports re-authentication of existing connections, otherwise
    false.

.. note::
    Feature support query based solely on the Bolt protocol version.
    The feature might still be disabled on the server side even if this
    function return :data:`True`. It just guarantees that the driver
    won't throw a :exc:`.ConfigurationError` when trying to use this
    driver feature.

.. versionadded:: 5.8","def supports_session_auth(self) -> bool:
        """"""Check if the remote supports connection re-authentication.

        :returns: Returns true if the server or cluster the driver connects to
            supports re-authentication of existing connections, otherwise
            false.

        .. note::
            Feature support query based solely on the Bolt protocol version.
            The feature might still be disabled on the server side even if this
            function return :data:`True`. It just guarantees that the driver
            won't throw a :exc:`.ConfigurationError` when trying to use this
            driver feature.

        .. versionadded:: 5.8
        """"""
        self._check_state()
        session_config = self._read_session_config({})
        with self._session(session_config) as session:
            session._connect(READ_ACCESS)
            assert session._connection
            return session._connection.supports_re_auth",1230,1251
open,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,":param target:
:param auth:
:param config: The values that can be specified are found in :class: `neo4j.PoolConfig` and :class: `neo4j.WorkspaceConfig`

:returns:
:rtype: :class: `neo4j.BoltDriver`","def open(cls, target, **config):
        """"""
        :param target:
        :param auth:
        :param config: The values that can be specified are found in :class: `neo4j.PoolConfig` and :class: `neo4j.WorkspaceConfig`

        :returns:
        :rtype: :class: `neo4j.BoltDriver`
        """"""
        from .io import BoltPool
        address = cls.parse_target(target)
        pool_config, default_workspace_config = Config.consume_chain(config, PoolConfig, WorkspaceConfig)
        pool = BoltPool.open(address, pool_config=pool_config, workspace_config=default_workspace_config)
        return cls(pool, default_workspace_config)",1281,1294
driver,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Create a driver.

:param uri: the connection URI for the driver,
    see :ref:`uri-ref` for available URIs.
:param auth: the authentication details,
    see :ref:`auth-ref` for available authentication details.
:param config: driver configuration key-word arguments,
    see :ref:`driver-configuration-ref` for available
    key-word arguments.","def driver(
            cls,
            uri: str,
            *,
            auth: t.Union[_TAuth, AuthManager] = None,
            **config
        ) -> Driver:
            """"""Create a driver.

            :param uri: the connection URI for the driver,
                see :ref:`uri-ref` for available URIs.
            :param auth: the authentication details,
                see :ref:`auth-ref` for available authentication details.
            :param config: driver configuration key-word arguments,
                see :ref:`driver-configuration-ref` for available
                key-word arguments.
            """"""

            driver_type, security_type, parsed = parse_neo4j_uri(uri)

            if not isinstance(auth, AuthManager):
                auth = AuthManagers.static(auth)
            config[""auth""] = auth

            client_certificate = config.get(""client_certificate"")
            if isinstance(client_certificate, ClientCertificate):
                # using internal class until public factory is GA:
                # AsyncClientCertificateProviders.static
                config[""client_certificate""] = \
                    _StaticClientCertificateProvider(client_certificate)
            if client_certificate is not None:
                preview_warn(""Mutual TLS is a preview feature."",
                             stack_level=2)

            # TODO: 6.0 - remove ""trust"" config option
            if ""trust"" in config.keys():
                if config[""trust""] not in (
                    TRUST_ALL_CERTIFICATES,
                    TRUST_SYSTEM_CA_SIGNED_CERTIFICATES
                ):
                    raise ConfigurationError(
                        ""The config setting `trust` values are {!r}""
                        .format(
                            [
                                TRUST_ALL_CERTIFICATES,
                                TRUST_SYSTEM_CA_SIGNED_CERTIFICATES,
                            ]
                        )
                    )

            if (""trusted_certificates"" in config.keys()
                and not isinstance(config[""trusted_certificates""],
                                   TrustStore)):
                raise ConfigurationError(
                    'The config setting ""trusted_certificates"" must be of '
                    ""type neo4j.TrustAll, neo4j.TrustCustomCAs, or""
                    ""neo4j.TrustSystemCAs but was {}"".format(
                        type(config[""trusted_certificates""])
                    )
                )

            if (security_type in (SECURITY_TYPE_SELF_SIGNED_CERTIFICATE,
                                  SECURITY_TYPE_SECURE)
                and (""encrypted"" in config
                     or ""trust"" in config
                     or ""trusted_certificates"" in config
                     or ""ssl_context"" in config)):

                # TODO: 6.0 - remove ""trust"" from error message
                raise ConfigurationError(
                    'The config settings ""encrypted"", ""trust"", '
                    '""trusted_certificates"", and ""ssl_context"" can only be '
                    ""used with the URI schemes {!r}. Use the other URI ""
                    ""schemes {!r} for setting encryption settings.""
                    .format(
                        [
                            URI_SCHEME_BOLT,
                            URI_SCHEME_NEO4J,
                        ],
                        [
                            URI_SCHEME_BOLT_SELF_SIGNED_CERTIFICATE,
                            URI_SCHEME_BOLT_SECURE,
                            URI_SCHEME_NEO4J_SELF_SIGNED_CERTIFICATE,
                            URI_SCHEME_NEO4J_SECURE,
                        ]
                    )
                )

            if security_type == SECURITY_TYPE_SECURE:
                config[""encrypted""] = True
            elif security_type == SECURITY_TYPE_SELF_SIGNED_CERTIFICATE:
                config[""encrypted""] = True
                config[""trusted_certificates""] = TrustAll()
            if ""warn_notification_severity"" in config:
                preview_warn(""notification warnings are a preview feature."",
                             stack_level=2)
            _normalize_notifications_config(config, driver_level=True)
            liveness_check_timeout = config.get(""liveness_check_timeout"")
            if (
                liveness_check_timeout is not None
                and liveness_check_timeout < 0
            ):
                raise ConfigurationError(
                    'The config setting ""liveness_check_timeout"" must be '
                    ""greater than or equal to 0 but was ""
                    f""{liveness_check_timeout}.""
                )

            assert driver_type in (DRIVER_BOLT, DRIVER_NEO4J)
            if driver_type == DRIVER_BOLT:
                if parse_routing_context(parsed.query):
                    deprecation_warn(
                        'Creating a direct driver (""bolt://"" scheme) with '
                        ""routing context (URI parameters) is deprecated. They ""
                        ""will be ignored. This will raise an error in a ""
                        'future release. Given URI ""{}""'.format(uri),
                        stack_level=2
                    )
                    # TODO: 6.0 - raise instead of warning
                    # raise ValueError(
                    #     'Routing parameters are not supported with scheme '
                    #     '""bolt"". Given URI ""{}"".'.format(uri)
                    # )
                return cls.bolt_driver(parsed.netloc, **config)
            # else driver_type == DRIVER_NEO4J
            routing_context = parse_routing_context(parsed.query)
            return cls.neo4j_driver(parsed.netloc,
                                    routing_context=routing_context, **config)",184,311
session,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Create a session, see :ref:`session-construction-ref`

:param config: session configuration key-word arguments,
    see :ref:`session-configuration-ref` for available
    key-word arguments.

:returns: new :class:`neo4j.Session` object","def session(self, **config) -> Session:
            """"""Create a session, see :ref:`session-construction-ref`

            :param config: session configuration key-word arguments,
                see :ref:`session-configuration-ref` for available
                key-word arguments.

            :returns: new :class:`neo4j.Session` object
            """"""
            if ""warn_notification_severity"" in config:
                # Would work just fine, but we don't want to introduce yet
                # another undocumented/unsupported config option.
                del config[""warn_notification_severity""]
            self._check_state()
            session_config = self._read_session_config(config)
            return self._session(session_config)",582,597
verify_connectivity,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Verify that the driver can establish a connection to the server.

This verifies if the driver can establish a reading connection to a
remote server or a cluster. Some data will be exchanged.

.. note::
    Even if this method raises an exception, the driver still needs
    to be closed via :meth:`close` to free up all resources.

:param config: accepts the same configuration key-word arguments as
    :meth:`session`.

    .. warning::
        All configuration key-word arguments are experimental.
        They might be changed or removed in any future version
        without prior notice.

:raises Exception: if the driver cannot connect to the remote.
    Use the exception to further understand the cause of the
    connectivity problem.

.. versionchanged:: 5.0
    The undocumented return value has been removed.
    If you need information about the remote server, use
    :meth:`get_server_info` instead.","def verify_connectivity(self, **config) -> None:
            """"""Verify that the driver can establish a connection to the server.

            This verifies if the driver can establish a reading connection to a
            remote server or a cluster. Some data will be exchanged.

            .. note::
                Even if this method raises an exception, the driver still needs
                to be closed via :meth:`close` to free up all resources.

            :param config: accepts the same configuration key-word arguments as
                :meth:`session`.

                .. warning::
                    All configuration key-word arguments are experimental.
                    They might be changed or removed in any future version
                    without prior notice.

            :raises Exception: if the driver cannot connect to the remote.
                Use the exception to further understand the cause of the
                connectivity problem.

            .. versionchanged:: 5.0
                The undocumented return value has been removed.
                If you need information about the remote server, use
                :meth:`get_server_info` instead.
            """"""
            self._check_state()
            if config:
                experimental_warn(
                    ""All configuration key-word arguments to ""
                    ""verify_connectivity() are experimental. They might be ""
                    ""changed or removed in any future version without prior ""
                    ""notice.""
                )
            session_config = self._read_session_config(config)
            self._get_server_info(session_config)",1008,1044
get_server_info,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Get information about the connected Neo4j server.

Try to establish a working read connection to the remote server or
a member of a cluster and exchange some data. Then return the
contacted server's information.

In a cluster, there is no guarantee about which server will be
contacted.

.. note::
    Even if this method raises an exception, the driver still needs
    to be closed via :meth:`close` to free up all resources.

:param config: accepts the same configuration key-word arguments as
    :meth:`session`.

    .. warning::
        All configuration key-word arguments are experimental.
        They might be changed or removed in any future version
        without prior notice.

:raises Exception: if the driver cannot connect to the remote.
    Use the exception to further understand the cause of the
    connectivity problem.

.. versionadded:: 5.0","def get_server_info(self, **config) -> ServerInfo:
            """"""Get information about the connected Neo4j server.

            Try to establish a working read connection to the remote server or
            a member of a cluster and exchange some data. Then return the
            contacted server's information.

            In a cluster, there is no guarantee about which server will be
            contacted.

            .. note::
                Even if this method raises an exception, the driver still needs
                to be closed via :meth:`close` to free up all resources.

            :param config: accepts the same configuration key-word arguments as
                :meth:`session`.

                .. warning::
                    All configuration key-word arguments are experimental.
                    They might be changed or removed in any future version
                    without prior notice.

            :raises Exception: if the driver cannot connect to the remote.
                Use the exception to further understand the cause of the
                connectivity problem.

            .. versionadded:: 5.0
            """"""
            self._check_state()
            if config:
                experimental_warn(
                    ""All configuration key-word arguments to ""
                    ""get_server_info() are experimental. They might be ""
                    ""changed or removed in any future version without prior ""
                    ""notice.""
                )
            session_config = self._read_session_config(config)
            return self._get_server_info(session_config)",1080,1117
verify_authentication,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/driver.py,"Verify that the authentication information is valid.

Like :meth:`.verify_connectivity`, but for checking authentication.

Try to establish a working read connection to the remote server or
a member of a cluster and exchange some data. In a cluster, there
is no guarantee about which server will be contacted. If the data
exchange is successful and the authentication information is valid,
:data:`True` is returned. Otherwise, the error will be matched
against a list of known authentication errors. If the error is on
that list, :data:`False` is returned indicating that the
authentication information is invalid. Otherwise, the error is
re-raised.

:param auth: authentication information to verify.
    Same as the session config :ref:`auth-ref`.
:param config: accepts the same configuration key-word arguments as
    :meth:`session`.

    .. warning::
        All configuration key-word arguments (except ``auth``) are
        experimental. They might be changed or removed in any
        future version without prior notice.

:raises Exception: if the driver cannot connect to the remote.
    Use the exception to further understand the cause of the
    connectivity problem.

.. versionadded:: 5.8

.. versionchanged:: 5.14 Stabilized from experimental.","def verify_authentication(
            self,
            auth: t.Union[Auth, t.Tuple[t.Any, t.Any], None] = None,
            **config
        ) -> bool:
            """"""Verify that the authentication information is valid.

            Like :meth:`.verify_connectivity`, but for checking authentication.

            Try to establish a working read connection to the remote server or
            a member of a cluster and exchange some data. In a cluster, there
            is no guarantee about which server will be contacted. If the data
            exchange is successful and the authentication information is valid,
            :data:`True` is returned. Otherwise, the error will be matched
            against a list of known authentication errors. If the error is on
            that list, :data:`False` is returned indicating that the
            authentication information is invalid. Otherwise, the error is
            re-raised.

            :param auth: authentication information to verify.
                Same as the session config :ref:`auth-ref`.
            :param config: accepts the same configuration key-word arguments as
                :meth:`session`.

                .. warning::
                    All configuration key-word arguments (except ``auth``) are
                    experimental. They might be changed or removed in any
                    future version without prior notice.

            :raises Exception: if the driver cannot connect to the remote.
                Use the exception to further understand the cause of the
                connectivity problem.

            .. versionadded:: 5.8

            .. versionchanged:: 5.14 Stabilized from experimental.
            """"""
            self._check_state()
            if config:
                experimental_warn(
                    ""All configuration key-word arguments but auth to ""
                    ""verify_authentication() are experimental. They might be ""
                    ""changed or removed in any future version without prior ""
                    ""notice.""
                )
            if ""database"" not in config:
                config[""database""] = ""system""
            session_config = self._read_session_config(config)
            session_config = SessionConfig(session_config, {""auth"": auth})
            with self._session(session_config) as session:
                try:
                    session._verify_authentication()
                except Neo4jError as exc:
                    if exc.code in (
                        ""Neo.ClientError.Security.CredentialsExpired"",
                        ""Neo.ClientError.Security.Forbidden"",
                        ""Neo.ClientError.Security.TokenExpired"",
                        ""Neo.ClientError.Security.Unauthorized"",
                    ):
                        return False
                    raise
            return True",1167,1228
_acquire,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Acquire a connection to a given address from the pool.
The address supplied should always be an IP address, not
a host name.

This method is thread safe.","def _acquire(
        self, address, auth, deadline, liveness_check_timeout
    ):
        """""" Acquire a connection to a given address from the pool.
        The address supplied should always be an IP address, not
        a host name.

        This method is thread safe.
        """"""
        if auth is None:
            auth = AcquireAuth(None)
        force_auth = auth.force_auth
        auth = auth.auth
        if liveness_check_timeout is None:
            liveness_check_timeout = self.pool_config.liveness_check_timeout

        def health_check(connection_, deadline_):
            if (connection_.closed()
                    or connection_.defunct()
                    or connection_.stale()):
                return False
            if liveness_check_timeout is not None:
                if connection_.is_idle_for(liveness_check_timeout):
                    with connection_deadline(connection_, deadline_):
                        try:
                            log.debug(""[#%04X]  _: <POOL> liveness check"",
                                      connection_.local_port)
                            connection_.reset()
                        except (OSError, ServiceUnavailable, SessionExpired):
                            return False
            return True

        while True:
            # try to find a free connection in the pool
            connection = self._acquire_from_pool_checked(
                address, health_check, deadline
            )
            if connection:
                log.debug(""[#%04X]  _: <POOL> picked existing connection %s"",
                          connection.local_port, connection.connection_id)
                try:
                    self._re_auth_connection(
                        connection, auth, force_auth
                    )
                except ConfigurationError:
                    if auth:
                        # protocol version lacks support for re-auth
                        # => session auth token is not supported
                        raise
                    # expiring tokens supported by flushing the pool
                    # => give up this connection
                    log.debug(""[#%04X]  _: <POOL> backwards compatible ""
                              ""auth token refresh: purge connection"",
                              connection.local_port)
                    connection.close()
                    self.release(connection)
                    continue
                log.debug(""[#%04X]  _: <POOL> handing out existing connection"",
                          connection.local_port)
                return connection
            # all connections in pool are in-use
            with self.lock:
                connection_creator = self._acquire_new_later(
                    address, auth, deadline,
                )
                if connection_creator:
                    break

                # failed to obtain a connection from pool because the
                # pool is full and no free connection in the pool
                timeout = deadline.to_timeout()
                if (
                    timeout == 0  # deadline expired
                    or not self.cond.wait(timeout)
                ):
                    log.debug(""[#0000]  _: <POOL> acquisition timed out"")
                    raise ClientError(
                        ""failed to obtain a connection from the pool within ""
                        ""{!r}s (timeout)"".format(deadline.original_timeout)
                    )
        log.debug(""[#0000]  _: <POOL> trying to hand out new connection"")
        return connection_creator()",232,313
acquire,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Acquire a connection to a server that can satisfy a set of parameters.

:param access_mode:
:param timeout: timeout for the core acquisition
    (excluding potential preparation like fetching routing tables).
:param database:
:param bookmarks:
:param auth:
:param liveness_check_timeout:","def acquire(
        self, access_mode, timeout, database, bookmarks, auth: AcquireAuth,
        liveness_check_timeout
    ):
        """""" Acquire a connection to a server that can satisfy a set of parameters.

        :param access_mode:
        :param timeout: timeout for the core acquisition
            (excluding potential preparation like fetching routing tables).
        :param database:
        :param bookmarks:
        :param auth:
        :param liveness_check_timeout:
        """"""
        ...",316,330
kill_and_release,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Release connections back into the pool after closing them.

This method is thread safe.","def kill_and_release(self, *connections):
        """""" Release connections back into the pool after closing them.

        This method is thread safe.
        """"""
        for connection in connections:
            if not (connection.defunct()
                    or connection.closed()):
                log.debug(
                    ""[#%04X]  _: <POOL> killing connection on release %s"",
                    connection.local_port, connection.connection_id
                )
                connection.kill()
        with self.lock:
            for connection in connections:
                connection.in_use = False
            self.cond.notify_all()",332,348
release,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Release connections back into the pool.

This method is thread safe.","def release(self, *connections):
        """""" Release connections back into the pool.

        This method is thread safe.
        """"""
        cancelled = None
        for connection in connections:
            if not (connection.defunct()
                    or connection.closed()
                    or connection.is_reset):
                if cancelled is not None:
                    log.debug(
                        ""[#%04X]  _: <POOL> kill unclean connection %s"",
                        connection.local_port, connection.connection_id
                    )
                    connection.kill()
                    continue
                try:
                    log.debug(
                        ""[#%04X]  _: <POOL> release unclean connection %s"",
                        connection.local_port, connection.connection_id
                    )
                    connection.reset()
                except (Neo4jError, DriverError, BoltError) as exc:
                    log.debug(""[#%04X]  _: <POOL> failed to reset connection ""
                              ""on release: %r"", connection.local_port, exc)
                except asyncio.CancelledError as exc:
                    log.debug(""[#%04X]  _: <POOL> cancelled reset connection ""
                              ""on release: %r"", connection.local_port, exc)
                    cancelled = exc
                    connection.kill()
        with self.lock:
            for connection in connections:
                connection.in_use = False
                log.debug(
                    ""[#%04X]  _: <POOL> released %s"",
                    connection.local_port, connection.connection_id
                )
            self.cond.notify_all()
        if cancelled is not None:
            raise cancelled",350,390
in_use_connection_count,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Count the number of connections currently in use to a given
address.","def in_use_connection_count(self, address):
        """""" Count the number of connections currently in use to a given
        address.
        """"""
        with self.lock:
            connections = self.connections.get(address, ())
            return sum(connection.in_use for connection in connections)",392,398
deactivate,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Deactivate an address from the connection pool, if present, closing
all idle connection to that address","def deactivate(self, address):
        """""" Deactivate an address from the connection pool, if present, closing
        all idle connection to that address
        """"""
        with self.lock:
            try:
                connections = self.connections[address]
            except KeyError:  # already removed from the connection pool
                return
            closable_connections = [
                conn for conn in connections if not conn.in_use
            ]
            # First remove all connections in question, then try to close them.
            # If closing of a connection fails, we will end up in this method
            # again.
            for conn in closable_connections:
                connections.remove(conn)
            if not self.connections[address]:
                del self.connections[address]

        self._close_connections(closable_connections)",423,443
close,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Close all connections and empty the pool.
This method is thread safe.","def close(self):
        """""" Close all connections and empty the pool.
        This method is thread safe.
        """"""
        log.debug(""[#0000]  _: <POOL> close"")
        try:
            connections = []
            with self.lock:
                for address in list(self.connections):
                    for connection in self.connections.pop(address, ()):
                        connections.append(connection)
            self._close_connections(connections)
        except TypeError:
            pass",469,482
open,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Create a new BoltPool

:param address:
:param pool_config:
:param workspace_config:
:returns: BoltPool","def open(cls, address, *, pool_config, workspace_config):
        """"""Create a new BoltPool

        :param address:
        :param pool_config:
        :param workspace_config:
        :returns: BoltPool
        """"""

        def opener(addr, auth_manager, deadline):
            return Bolt.open(
                addr, auth_manager=auth_manager, deadline=deadline,
                routing_context=None, pool_config=pool_config
            )

        pool = cls(opener, pool_config, workspace_config, address)
        log.debug(""[#0000]  _: <POOL> created, direct address %r"", address)
        return pool",490,507
open,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Create a new Neo4jPool

:param addresses: one or more address as positional argument
:param pool_config:
:param workspace_config:
:param routing_context:
:returns: Neo4jPool","def open(cls, *addresses, pool_config, workspace_config,
             routing_context=None):
        """"""Create a new Neo4jPool

        :param addresses: one or more address as positional argument
        :param pool_config:
        :param workspace_config:
        :param routing_context:
        :returns: Neo4jPool
        """"""

        address = addresses[0]
        if routing_context is None:
            routing_context = {}
        elif ""address"" in routing_context:
            raise ConfigurationError(""The key 'address' is reserved for routing context."")
        routing_context[""address""] = str(address)

        def opener(addr, auth_manager, deadline):
            return Bolt.open(
                addr, auth_manager=auth_manager, deadline=deadline,
                routing_context=routing_context, pool_config=pool_config
            )

        pool = cls(opener, pool_config, workspace_config, address)
        log.debug(""[#0000]  _: <POOL> created, routing address %r"", address)
        return pool",538,564
__init__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,":param opener:
:param pool_config:
:param workspace_config:
:param address:","def __init__(self, opener, pool_config, workspace_config, address):
        """"""

        :param opener:
        :param pool_config:
        :param workspace_config:
        :param address:
        """"""
        super().__init__(opener, pool_config, workspace_config)
        # Each database have a routing table, the default database is a special case.
        self.address = address
        self.routing_tables = {}
        self.refresh_lock = RLock()
        self.is_direct_pool = False",566,579
__repr__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"The representation shows the initial routing addresses.

:returns: The representation
:rtype: str","def __repr__(self):
        """""" The representation shows the initial routing addresses.

        :returns: The representation
        :rtype: str
        """"""
        return ""<{} address={!r}>"".format(self.__class__.__name__,
                                          self.address)",581,588
fetch_routing_info,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Fetch raw routing info from a given router address.

:param address: router address
:param database: the database name to get routing table for
:param imp_user: the user to impersonate while fetching the routing
                 table
:type imp_user: str or None
:param bookmarks: iterable of bookmark values after which the routing
                  info should be fetched
:param auth: auth
:param acquisition_timeout: connection acquisition timeout

:returns: list of routing records, or None if no connection
    could be established or if no readers or writers are present
:raise ServiceUnavailable: if the server does not support
    routing, or if routing support is broken or outdated","def fetch_routing_info(
        self, address, database, imp_user, bookmarks, auth, acquisition_timeout
    ):
        """""" Fetch raw routing info from a given router address.

        :param address: router address
        :param database: the database name to get routing table for
        :param imp_user: the user to impersonate while fetching the routing
                         table
        :type imp_user: str or None
        :param bookmarks: iterable of bookmark values after which the routing
                          info should be fetched
        :param auth: auth
        :param acquisition_timeout: connection acquisition timeout

        :returns: list of routing records, or None if no connection
            could be established or if no readers or writers are present
        :raise ServiceUnavailable: if the server does not support
            routing, or if routing support is broken or outdated
        """"""
        deadline = Deadline.from_timeout_or_deadline(acquisition_timeout)
        log.debug(""[#0000]  _: <POOL> _acquire router connection, ""
                  ""database=%r, address=%r"", database, address)
        if auth:
            auth = copy(auth)
            auth.force_auth = False
        cx = self._acquire(address, auth, deadline, None)
        try:
            routing_table = cx.route(
                database=database or self.workspace_config.database,
                imp_user=imp_user or self.workspace_config.impersonated_user,
                bookmarks=bookmarks
            )
        finally:
            self.release(cx)
        return routing_table",599,634
fetch_routing_table,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Fetch a routing table from a given router address.

:param address: router address
:param acquisition_timeout: connection acquisition timeout
:param database: the database name
:type: str
:param imp_user: the user to impersonate while fetching the routing
                 table
:type imp_user: str or None
:param bookmarks: bookmarks used when fetching routing table
:param auth: auth

:returns: a new RoutingTable instance or None if the given router is
         currently unable to provide routing information","def fetch_routing_table(
        self, *, address, acquisition_timeout, database, imp_user,
        bookmarks, auth
    ):
        """""" Fetch a routing table from a given router address.

        :param address: router address
        :param acquisition_timeout: connection acquisition timeout
        :param database: the database name
        :type: str
        :param imp_user: the user to impersonate while fetching the routing
                         table
        :type imp_user: str or None
        :param bookmarks: bookmarks used when fetching routing table
        :param auth: auth

        :returns: a new RoutingTable instance or None if the given router is
                 currently unable to provide routing information
        """"""
        new_routing_info = None
        try:
            new_routing_info = self.fetch_routing_info(
                address, database, imp_user, bookmarks, auth,
                acquisition_timeout
            )
        except Neo4jError as e:
            # checks if the code is an error that is caused by the client. In
            # this case there is no sense in trying to fetch a RT from another
            # router. Hence, the driver should fail fast during discovery.
            if e._is_fatal_during_discovery():
                raise
        except (ServiceUnavailable, SessionExpired):
            pass
        if not new_routing_info:
            log.debug(""[#0000]  _: <POOL> failed to fetch routing info ""
                      ""from %r"", address)
            return None
        else:
            servers = new_routing_info[0][""servers""]
            ttl = new_routing_info[0][""ttl""]
            database = new_routing_info[0].get(""db"", database)
            new_routing_table = RoutingTable.parse_routing_info(
                database=database, servers=servers, ttl=ttl
            )

        # Parse routing info and count the number of each type of server
        num_routers = len(new_routing_table.routers)
        num_readers = len(new_routing_table.readers)

        # num_writers = len(new_routing_table.writers)
        # If no writers are available. This likely indicates a temporary state,
        # such as leader switching, so we should not signal an error.

        # No routers
        if num_routers == 0:
            log.debug(""[#0000]  _: <POOL> no routing servers returned from ""
                      ""server %s"", address)
            return None

        # No readers
        if num_readers == 0:
            log.debug(""[#0000]  _: <POOL> no read servers returned from ""
                      ""server %s"", address)
            return None

        # At least one of each is fine, so return this table
        return new_routing_table",636,702
_update_routing_table_from,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Try to update routing tables with the given routers.

:returns: True if the routing table is successfully updated,
otherwise False","def _update_routing_table_from(
        self, *routers, database, imp_user, bookmarks, auth,
        acquisition_timeout, database_callback
    ):
        """""" Try to update routing tables with the given routers.

        :returns: True if the routing table is successfully updated,
        otherwise False
        """"""
        if routers:
            log.debug(""[#0000]  _: <POOL> attempting to update routing ""
                      ""table from {}"".format("", "".join(map(repr, routers))))
        for router in routers:
            for address in NetworkUtil.resolve_address(
                router, resolver=self.pool_config.resolver
            ):
                new_routing_table = self.fetch_routing_table(
                    address=address, acquisition_timeout=acquisition_timeout,
                    database=database, imp_user=imp_user, bookmarks=bookmarks,
                    auth=auth
                )
                if new_routing_table is not None:
                    new_database = new_routing_table.database
                    old_routing_table = self.get_or_create_routing_table(
                        new_database
                    )
                    old_routing_table.update(new_routing_table)
                    log.debug(
                        ""[#0000]  _: <POOL> update routing table from ""
                        ""address=%r (%r)"",
                        address, self.routing_tables[new_database]
                    )
                    if callable(database_callback):
                        database_callback(new_database)
                    return True
            self.deactivate(router)
        return False",704,740
update_routing_table,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Update the routing table from the first router able to provide
valid routing information.

:param database: The database name
:param imp_user: the user to impersonate while fetching the routing
                 table
:type imp_user: str or None
:param bookmarks: bookmarks used when fetching routing table
:param auth: auth
:param acquisition_timeout: connection acquisition timeout
:param database_callback: A callback function that will be called with
    the database name as only argument when a new routing table has been
    acquired. This database name might different from `database` if that
    was None and the underlying protocol supports reporting back the
    actual database.

:raise neo4j.exceptions.ServiceUnavailable:","def update_routing_table(
        self, *, database, imp_user, bookmarks, auth=None,
        acquisition_timeout=None, database_callback=None
    ):
        """""" Update the routing table from the first router able to provide
        valid routing information.

        :param database: The database name
        :param imp_user: the user to impersonate while fetching the routing
                         table
        :type imp_user: str or None
        :param bookmarks: bookmarks used when fetching routing table
        :param auth: auth
        :param acquisition_timeout: connection acquisition timeout
        :param database_callback: A callback function that will be called with
            the database name as only argument when a new routing table has been
            acquired. This database name might different from `database` if that
            was None and the underlying protocol supports reporting back the
            actual database.

        :raise neo4j.exceptions.ServiceUnavailable:
        """"""
        with self.refresh_lock:
            routing_table = self.get_or_create_routing_table(database)
            # copied because it can be modified
            existing_routers = set(routing_table.routers)

            prefer_initial_routing_address = \
                self.routing_tables[database].initialized_without_writers

            if prefer_initial_routing_address:
                # TODO: Test this state
                if self._update_routing_table_from(
                    self.address, database=database,
                    imp_user=imp_user, bookmarks=bookmarks, auth=auth,
                    acquisition_timeout=acquisition_timeout,
                    database_callback=database_callback
                ):
                    # Why is only the first initial routing address used?
                    return
            if self._update_routing_table_from(
                *(existing_routers - {self.address}), database=database,
                imp_user=imp_user, bookmarks=bookmarks, auth=auth,
                acquisition_timeout=acquisition_timeout,
                database_callback=database_callback
            ):
                return

            if not prefer_initial_routing_address:
                if self._update_routing_table_from(
                    self.address, database=database,
                    imp_user=imp_user, bookmarks=bookmarks, auth=auth,
                    acquisition_timeout=acquisition_timeout,
                    database_callback=database_callback
                ):
                    # Why is only the first initial routing address used?
                    return

            # None of the routers have been successful, so just fail
            log.error(""Unable to retrieve routing information"")
            raise ServiceUnavailable(""Unable to retrieve routing information"")",742,802
ensure_routing_table_is_fresh,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Update the routing table if stale.

This method performs two freshness checks, before and after acquiring
the refresh lock. If the routing table is already fresh on entry, the
method exits immediately; otherwise, the refresh lock is acquired and
the second freshness check that follows determines whether an update
is still required.

This method is thread-safe.

:returns: `True` if an update was required, `False` otherwise.","def ensure_routing_table_is_fresh(
        self, *, access_mode, database, imp_user, bookmarks, auth=None,
        acquisition_timeout=None, database_callback=None
    ):
        """""" Update the routing table if stale.

        This method performs two freshness checks, before and after acquiring
        the refresh lock. If the routing table is already fresh on entry, the
        method exits immediately; otherwise, the refresh lock is acquired and
        the second freshness check that follows determines whether an update
        is still required.

        This method is thread-safe.

        :returns: `True` if an update was required, `False` otherwise.
        """"""
        from ...api import READ_ACCESS
        with self.refresh_lock:
            for database_ in list(self.routing_tables.keys()):
                # Remove unused databases in the routing table
                # Remove the routing table after a timeout = TTL + 30s
                log.debug(""[#0000]  _: <POOL> routing aged?, database=%s"",
                          database_)
                routing_table = self.routing_tables[database_]
                if routing_table.should_be_purged_from_memory():
                    log.debug(""[#0000]  _: <POOL> dropping routing table for ""
                              ""database=%s"", database_)
                    del self.routing_tables[database_]

            routing_table = self.get_or_create_routing_table(database)
            if routing_table.is_fresh(readonly=(access_mode == READ_ACCESS)):
                # table is still valid
                log.debug(""[#0000]  _: <POOL> using existing routing table %r"",
                          routing_table)
                return False

            self.update_routing_table(
                database=database, imp_user=imp_user, bookmarks=bookmarks,
                auth=auth, acquisition_timeout=acquisition_timeout,
                database_callback=database_callback
            )
            self.update_connection_pool(database=database)

            return True",816,859
deactivate,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Deactivate an address from the connection pool,
if present, remove from the routing table and also closing
all idle connections to that address.","def deactivate(self, address):
        """""" Deactivate an address from the connection pool,
        if present, remove from the routing table and also closing
        all idle connections to that address.
        """"""
        log.debug(""[#0000]  _: <POOL> deactivating address %r"", address)
        # We use `discard` instead of `remove` here since the former
        # will not fail if the address has already been removed.
        with self.refresh_lock:
            for database in self.routing_tables.keys():
                self.routing_tables[database].routers.discard(address)
                self.routing_tables[database].readers.discard(address)
                self.routing_tables[database].writers.discard(address)
        log.debug(""[#0000]  _: <POOL> table=%r"", self.routing_tables)
        super(Neo4jPool, self).deactivate(address)",938,952
on_write_failure,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_pool.py,"Remove a writer address from the routing table, if present.
        ","def on_write_failure(self, address, database):
        """""" Remove a writer address from the routing table, if present.
        """"""
        log.debug(""[#0000]  _: <POOL> removing writer %r for database %r"",
                  address, database)
        with self.refresh_lock:
            table = self.routing_tables.get(database)
            if table is not None:
                table.writers.discard(address)
        log.debug(""[#0000]  _: <POOL> table=%r"", self.routing_tables)",954,963
check_supported_server_product,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_common.py,"Checks that a server product is supported by the driver by
looking at the server agent string.

:param agent: server agent string to check for validity

:raises UnsupportedServerProduct: if the product is not supported","def check_supported_server_product(agent):
    """""" Checks that a server product is supported by the driver by
    looking at the server agent string.

    :param agent: server agent string to check for validity

    :raises UnsupportedServerProduct: if the product is not supported
    """"""
    if not agent.startswith(""Neo4j/""):
        raise UnsupportedServerProduct(agent)",308,317
__init__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_common.py,":param connection the connection object to warp
:type connection Bolt
:param on_error the function to be called when a method of
    connection raises of of the caught errors.
:type on_error callable","def __init__(self, connection, on_error):
        """"""
        :param connection the connection object to warp
        :type connection Bolt
        :param on_error the function to be called when a method of
            connection raises of of the caught errors.
        :type on_error callable
        """"""
        self.__connection = connection
        self.__on_error = on_error",159,168
on_records,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_common.py,"Called when one or more RECORD messages have been received.
        ","def on_records(self, records):
        """""" Called when one or more RECORD messages have been received.
        """"""
        handler = self.handlers.get(""on_records"")
        Util.callback(handler, records)",218,222
on_success,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_common.py,"Called when a SUCCESS message has been received.
        ","def on_success(self, metadata):
        """""" Called when a SUCCESS message has been received.
        """"""
        handler = self.handlers.get(""on_success"")
        Util.callback(handler, metadata)

        if not metadata.get(""has_more""):
            handler = self.handlers.get(""on_summary"")
            Util.callback(handler)",224,232
on_failure,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_common.py,"Called when a FAILURE message has been received.
        ","def on_failure(self, metadata):
        """""" Called when a FAILURE message has been received.
        """"""
        try:
            self.connection.reset()
        except (SessionExpired, ServiceUnavailable):
            pass
        handler = self.handlers.get(""on_failure"")
        Util.callback(handler, metadata)
        handler = self.handlers.get(""on_summary"")
        Util.callback(handler)
        raise Neo4jError.hydrate(**metadata)",234,245
on_ignored,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_common.py,"Called when an IGNORED message has been received.
        ","def on_ignored(self, metadata=None):
        """""" Called when an IGNORED message has been received.
        """"""
        handler = self.handlers.get(""on_ignored"")
        Util.callback(handler, metadata)
        handler = self.handlers.get(""on_summary"")
        Util.callback(handler)",247,253
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt3.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        self.assert_re_auth_support()",220,222
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt3.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        self.assert_re_auth_support()",224,226
reset,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt3.py,"Reset the connection.

Add a RESET message to the outgoing queue, send it and consume all
remaining messages.","def reset(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Reset the connection.

        Add a RESET message to the outgoing queue, send it and consume all
        remaining messages.
        """"""
        log.debug(""[#%04X]  C: RESET"", self.local_port)
        response = ResetResponse(self, ""reset"", hydration_hooks)
        self._append(b""\x0F"", response=response,
                     dehydration_hooks=dehydration_hooks)
        self.send_all()
        self.fetch_all()",394,405
_process_message,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt3.py,"Process at most one message from the server, if available.

:returns: 2-tuple of number of detail messages and number of summary
         messages fetched","def _process_message(self, tag, fields):
        """""" Process at most one message from the server, if available.

        :returns: 2-tuple of number of detail messages and number of summary
                 messages fetched
        """"""
        details = []
        summary_signature = summary_metadata = None
        if tag == b""\x71"":  # RECORD
            details = fields
        elif fields:
            summary_signature = tag
            summary_metadata = fields[0]
        else:
            summary_signature = tag

        if details:
            log.debug(""[#%04X]  S: RECORD * %d"", self.local_port, len(details))  # Do not log any data
            self.responses[0].on_records(details)

        if summary_signature is None:
            return len(details), 0

        response = self.responses.popleft()
        response.complete = True
        if summary_signature == b""\x70"":
            log.debug(""[#%04X]  S: SUCCESS %r"", self.local_port, summary_metadata)
            self._server_state_manager.transition(response.message,
                                                  summary_metadata)
            response.on_success(summary_metadata or {})
        elif summary_signature == b""\x7E"":
            log.debug(""[#%04X]  S: IGNORED"", self.local_port)
            response.on_ignored(summary_metadata or {})
        elif summary_signature == b""\x7F"":
            log.debug(""[#%04X]  S: FAILURE %r"", self.local_port, summary_metadata)
            self._server_state_manager.state = BoltStates.FAILED
            try:
                response.on_failure(summary_metadata or {})
            except (ServiceUnavailable, DatabaseUnavailable):
                if self.pool:
                    self.pool.deactivate(address=self.unresolved_address)
                raise
            except (NotALeader, ForbiddenOnReadOnlyDatabase):
                if self.pool:
                    self.pool.on_write_failure(
                        address=self.unresolved_address,
                        database=self.last_database,
                    )
                raise
            except Neo4jError as e:
                self.pool.on_neo4j_error(e, self)
                raise
        else:
            raise BoltProtocolError(""Unexpected response message with signature %02X"" % summary_signature, address=self.unresolved_address)

        return len(details), 1",411,466
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt4.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        self.assert_re_auth_support()",141,143
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt4.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        self.assert_re_auth_support()",145,147
reset,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt4.py,"Reset the connection.

Add a RESET message to the outgoing queue, send it and consume all
remaining messages.","def reset(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Reset the connection.

        Add a RESET message to the outgoing queue, send it and consume all
        remaining messages.
        """"""
        log.debug(""[#%04X]  C: RESET"", self.local_port)
        response = ResetResponse(self, ""reset"", hydration_hooks)
        self._append(b""\x0F"", response=response,
                     dehydration_hooks=dehydration_hooks)
        self.send_all()
        self.fetch_all()",314,325
_process_message,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt4.py,"Process at most one message from the server, if available.

:returns: 2-tuple of number of detail messages and number of summary
         messages fetched","def _process_message(self, tag, fields):
        """""" Process at most one message from the server, if available.

        :returns: 2-tuple of number of detail messages and number of summary
                 messages fetched
        """"""
        details = []
        summary_signature = summary_metadata = None
        if tag == b""\x71"":  # RECORD
            details = fields
        elif fields:
            summary_signature = tag
            summary_metadata = fields[0]
        else:
            summary_signature = tag

        if details:
            log.debug(""[#%04X]  S: RECORD * %d"", self.local_port, len(details))  # Do not log any data
            self.responses[0].on_records(details)

        if summary_signature is None:
            return len(details), 0

        response = self.responses.popleft()
        response.complete = True
        if summary_signature == b""\x70"":
            log.debug(""[#%04X]  S: SUCCESS %r"", self.local_port, summary_metadata)
            self._server_state_manager.transition(response.message,
                                                  summary_metadata)
            response.on_success(summary_metadata or {})
        elif summary_signature == b""\x7E"":
            log.debug(""[#%04X]  S: IGNORED"", self.local_port)
            response.on_ignored(summary_metadata or {})
        elif summary_signature == b""\x7F"":
            log.debug(""[#%04X]  S: FAILURE %r"", self.local_port, summary_metadata)
            self._server_state_manager.state = BoltStates.FAILED
            try:
                response.on_failure(summary_metadata or {})
            except (ServiceUnavailable, DatabaseUnavailable):
                if self.pool:
                    self.pool.deactivate(address=self.unresolved_address)
                raise
            except (NotALeader, ForbiddenOnReadOnlyDatabase):
                if self.pool:
                    self.pool.on_write_failure(
                        address=self.unresolved_address,
                        database=self.last_database
                    )
                raise
            except Neo4jError as e:
                if self.pool:
                    self.pool.on_neo4j_error(e, self)
                raise
        else:
            raise BoltProtocolError(""Unexpected response message with signature ""
                                    ""%02X"" % ord(summary_signature), self.unresolved_address)

        return len(details), 1",331,388
get_base_headers,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt4.py,"Bolt 4.1 passes the routing context, originally taken from
the URI, into the connection initialisation message. This
enables server-side routing to propagate the same behaviour
through its driver.","def get_base_headers(self):
        """""" Bolt 4.1 passes the routing context, originally taken from
        the URI, into the connection initialisation message. This
        enables server-side routing to propagate the same behaviour
        through its driver.
        """"""
        headers = {
            ""user_agent"": self.user_agent,
        }
        if self.routing_context is not None:
            headers[""routing""] = self.routing_context
        return headers",399,410
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt5.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        self.assert_re_auth_support()",163,165
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt5.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        self.assert_re_auth_support()",167,169
reset,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt5.py,"Reset the connection.

Add a RESET message to the outgoing queue, send it and consume all
remaining messages.","def reset(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Reset the connection.

        Add a RESET message to the outgoing queue, send it and consume all
        remaining messages.
        """"""
        log.debug(""[#%04X]  C: RESET"", self.local_port)
        response = ResetResponse(self, ""reset"", hydration_hooks)
        self._append(b""\x0F"", response=response,
                     dehydration_hooks=dehydration_hooks)
        self.send_all()
        self.fetch_all()",312,323
_process_message,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt5.py,"Process at most one message from the server, if available.

:returns: 2-tuple of number of detail messages and number of summary
         messages fetched","def _process_message(self, tag, fields):
        """"""Process at most one message from the server, if available.

        :returns: 2-tuple of number of detail messages and number of summary
                 messages fetched
        """"""
        details = []
        summary_signature = summary_metadata = None
        if tag == b""\x71"":  # RECORD
            details = fields
        elif fields:
            summary_signature = tag
            summary_metadata = fields[0]
        else:
            summary_signature = tag

        if details:
            # Do not log any data
            log.debug(""[#%04X]  S: RECORD * %d"", self.local_port, len(details))
            self.responses[0].on_records(details)

        if summary_signature is None:
            return len(details), 0

        response = self.responses.popleft()
        response.complete = True
        if summary_signature == b""\x70"":
            log.debug(""[#%04X]  S: SUCCESS %r"", self.local_port,
                      summary_metadata)
            self._server_state_manager.transition(response.message,
                                                  summary_metadata)
            response.on_success(summary_metadata or {})
        elif summary_signature == b""\x7E"":
            log.debug(""[#%04X]  S: IGNORED"", self.local_port)
            response.on_ignored(summary_metadata or {})
        elif summary_signature == b""\x7F"":
            log.debug(""[#%04X]  S: FAILURE %r"", self.local_port,
                      summary_metadata)
            self._server_state_manager.state = self.bolt_states.FAILED
            try:
                response.on_failure(summary_metadata or {})
            except (ServiceUnavailable, DatabaseUnavailable):
                if self.pool:
                    self.pool.deactivate(address=self.unresolved_address)
                raise
            except (NotALeader, ForbiddenOnReadOnlyDatabase):
                if self.pool:
                    self.pool.on_write_failure(
                        address=self.unresolved_address,
                        database=self.last_database
                    )
                raise
            except Neo4jError as e:
                if self.pool:
                    self.pool.on_neo4j_error(e, self)
                raise
        else:
            raise BoltProtocolError(
                ""Unexpected response message with signature %02X"" % ord(
                    summary_signature
                ), self.unresolved_address
            )

        return len(details), 1",329,392
tx_timeout_as_ms,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Round transaction timeout to milliseconds.

Values in (0, 1], else values are rounded using the built-in round()
function (round n.5 values to nearest even).

:param timeout: timeout in seconds (must be >= 0)

:returns: timeout in milliseconds (rounded)

:raise ValueError: if timeout is negative","def tx_timeout_as_ms(timeout: float) -> int:
    """"""Round transaction timeout to milliseconds.

    Values in (0, 1], else values are rounded using the built-in round()
    function (round n.5 values to nearest even).

    :param timeout: timeout in seconds (must be >= 0)

    :returns: timeout in milliseconds (rounded)

    :raise ValueError: if timeout is negative
    """"""
    try:
        timeout = float(timeout)
    except (TypeError, ValueError) as e:
        err_type = type(e)
        msg = ""Timeout must be specified as a number of seconds""
        raise err_type(msg) from None
    if timeout < 0:
        raise ValueError(""Timeout must be a positive number or 0."")
    ms = int(round(1000 * timeout))
    if ms == 0 and timeout > 0:
        # Special case for 0 < timeout < 0.5 ms.
        # This would be rounded to 0 ms, but the server interprets this as
        # infinite timeout. So we round to the smallest possible timeout: 1 ms.
        ms = 1
    return ms",993,1019
supports_multiple_results,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Boolean flag to indicate if the connection version supports multiple
queries to be buffered on the server side (True) or if all results need
to be eagerly pulled before sending the next RUN (False).","def supports_multiple_results(self):
        """""" Boolean flag to indicate if the connection version supports multiple
        queries to be buffered on the server side (True) or if all results need
        to be eagerly pulled before sending the next RUN (False).
        """"""
        pass",213,218
supports_multiple_databases,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Boolean flag to indicate if the connection version supports multiple
databases.","def supports_multiple_databases(self):
        """""" Boolean flag to indicate if the connection version supports multiple
        databases.
        """"""
        pass",222,226
supports_re_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,Whether the connection version supports re-authentication.,"def supports_re_auth(self):
        """"""Whether the connection version supports re-authentication.""""""
        pass",230,232
supports_notification_filtering,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,Whether the connection version supports re-authentication.,"def supports_notification_filtering(self):
        """"""Whether the connection version supports re-authentication.""""""
        pass",244,246
protocol_handlers,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Return a dictionary of available Bolt protocol handlers,
keyed by version tuple. If an explicit protocol version is
provided, the dictionary will contain either zero or one items,
depending on whether that version is supported. If no protocol
version is provided, all available versions will be returned.

:param protocol_version: tuple identifying a specific protocol
    version (e.g. (3, 5)) or None
:returns: dictionary of version tuple to handler class for all
    relevant and supported protocol versions
:raise TypeError: if protocol version is not passed in a tuple","def protocol_handlers(cls, protocol_version=None):
        """""" Return a dictionary of available Bolt protocol handlers,
        keyed by version tuple. If an explicit protocol version is
        provided, the dictionary will contain either zero or one items,
        depending on whether that version is supported. If no protocol
        version is provided, all available versions will be returned.

        :param protocol_version: tuple identifying a specific protocol
            version (e.g. (3, 5)) or None
        :returns: dictionary of version tuple to handler class for all
            relevant and supported protocol versions
        :raise TypeError: if protocol version is not passed in a tuple
        """"""

        # Carry out Bolt subclass imports locally to avoid circular dependency issues.
        from ._bolt3 import Bolt3
        from ._bolt4 import (
            Bolt4x1,
            Bolt4x2,
            Bolt4x3,
            Bolt4x4,
        )
        from ._bolt5 import (
            Bolt5x0,
            Bolt5x1,
            Bolt5x2,
            Bolt5x3,
            Bolt5x4,
        )

        handlers = {
            Bolt3.PROTOCOL_VERSION: Bolt3,
            # 4.0 unsupported because no space left in the handshake
            Bolt4x1.PROTOCOL_VERSION: Bolt4x1,
            Bolt4x2.PROTOCOL_VERSION: Bolt4x2,
            Bolt4x3.PROTOCOL_VERSION: Bolt4x3,
            Bolt4x4.PROTOCOL_VERSION: Bolt4x4,
            Bolt5x0.PROTOCOL_VERSION: Bolt5x0,
            Bolt5x1.PROTOCOL_VERSION: Bolt5x1,
            Bolt5x2.PROTOCOL_VERSION: Bolt5x2,
            Bolt5x3.PROTOCOL_VERSION: Bolt5x3,
            Bolt5x4.PROTOCOL_VERSION: Bolt5x4,
        }

        if protocol_version is None:
            return handlers

        if not isinstance(protocol_version, tuple):
            raise TypeError(""Protocol version must be specified as a tuple"")

        if protocol_version in handlers:
            return {protocol_version: handlers[protocol_version]}

        return {}",258,311
version_list,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Return a list of supported protocol versions in order of
preference. The number of protocol versions (or ranges)
returned is limited to four.","def version_list(cls, versions, limit=4):
        """""" Return a list of supported protocol versions in order of
        preference. The number of protocol versions (or ranges)
        returned is limited to four.
        """"""
        # In fact, 4.3 is the fist version to support ranges. However, the
        # range support got backported to 4.2. But even if the server is too
        # old to have the backport, negotiating BOLT 4.1 is no problem as it's
        # equivalent to 4.2
        first_with_range_support = Version(4, 2)
        result = []
        for version in versions:
            if (result
                    and version >= first_with_range_support
                    and result[-1][0] == version[0]
                    and result[-1][1][1] == version[1] + 1):
                # can use range to encompass this version
                result[-1][1][1] = version[1]
                continue
            result.append(Version(version[0], [version[1], version[1]]))
            if len(result) == 4:
                break
        return result",314,336
get_handshake,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Return the supported Bolt versions as bytes.
The length is 16 bytes as specified in the Bolt version negotiation.
:returns: bytes","def get_handshake(cls):
        """""" Return the supported Bolt versions as bytes.
        The length is 16 bytes as specified in the Bolt version negotiation.
        :returns: bytes
        """"""
        supported_versions = sorted(cls.protocol_handlers().keys(), reverse=True)
        offered_versions = cls.version_list(supported_versions)
        return b"""".join(version.to_bytes() for version in offered_versions).ljust(16, b""\x00"")",339,346
ping,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Attempt to establish a Bolt connection, returning the
agreed Bolt protocol version if successful.","def ping(cls, address, *, deadline=None, pool_config=None):
        """""" Attempt to establish a Bolt connection, returning the
        agreed Bolt protocol version if successful.
        """"""
        if pool_config is None:
            pool_config = PoolConfig()
        if deadline is None:
            deadline = Deadline(None)

        try:
            s, protocol_version, handshake, data = \
                BoltSocket.connect(
                    address,
                    tcp_timeout=pool_config.connection_timeout,
                    deadline=deadline,
                    custom_resolver=pool_config.resolver,
                    ssl_context=pool_config.get_ssl_context(),
                    keep_alive=pool_config.keep_alive,
                )
        except (ServiceUnavailable, SessionExpired, BoltHandshakeError):
            return None
        else:
            BoltSocket.close_socket(s)
            return protocol_version",349,372
open,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Open a new Bolt connection to a given server address.

:param address:
:param auth_manager:
:param deadline: how long to wait for the connection to be established
:param routing_context: dict containing routing context
:param pool_config:

:returns: connected Bolt instance

:raise BoltHandshakeError:
    raised if the Bolt Protocol can not negotiate a protocol version.
:raise ServiceUnavailable: raised if there was a connection issue.","def open(
        cls, address, *, auth_manager=None, deadline=None,
        routing_context=None, pool_config=None
    ):
        """"""Open a new Bolt connection to a given server address.

        :param address:
        :param auth_manager:
        :param deadline: how long to wait for the connection to be established
        :param routing_context: dict containing routing context
        :param pool_config:

        :returns: connected Bolt instance

        :raise BoltHandshakeError:
            raised if the Bolt Protocol can not negotiate a protocol version.
        :raise ServiceUnavailable: raised if there was a connection issue.
        """"""

        if pool_config is None:
            pool_config = PoolConfig()
        if deadline is None:
            deadline = Deadline(None)

        s, protocol_version, handshake, data = \
            BoltSocket.connect(
                address,
                tcp_timeout=pool_config.connection_timeout,
                deadline=deadline,
                custom_resolver=pool_config.resolver,
                ssl_context=pool_config.get_ssl_context(),
                keep_alive=pool_config.keep_alive,
            )

        pool_config.protocol_version = protocol_version

        # Carry out Bolt subclass imports locally to avoid circular dependency
        # issues.
        if protocol_version == (5, 4):
            from ._bolt5 import Bolt5x4
            bolt_cls = Bolt5x4
        elif protocol_version == (5, 3):
            from ._bolt5 import Bolt5x3
            bolt_cls = Bolt5x3
        elif protocol_version == (5, 2):
            from ._bolt5 import Bolt5x2
            bolt_cls = Bolt5x2
        elif protocol_version == (5, 1):
            from ._bolt5 import Bolt5x1
            bolt_cls = Bolt5x1
        elif protocol_version == (5, 0):
            from ._bolt5 import Bolt5x0
            bolt_cls = Bolt5x0
        elif protocol_version == (4, 4):
            from ._bolt4 import Bolt4x4
            bolt_cls = Bolt4x4
        elif protocol_version == (4, 3):
            from ._bolt4 import Bolt4x3
            bolt_cls = Bolt4x3
        elif protocol_version == (4, 2):
            from ._bolt4 import Bolt4x2
            bolt_cls = Bolt4x2
        elif protocol_version == (4, 1):
            from ._bolt4 import Bolt4x1
            bolt_cls = Bolt4x1
        # Implementation for 4.0 exists, but there was no space left in the
        # handshake to offer this version to the server. Hence, the server
        # should never request us to speak bolt 4.0.
        # elif protocol_version == (4, 0):
        #     from ._bolt4 import AsyncBolt4x0
        #     bolt_cls = AsyncBolt4x0
        elif protocol_version == (3, 0):
            from ._bolt3 import Bolt3
            bolt_cls = Bolt3
        else:
            log.debug(""[#%04X]  C: <CLOSE>"", s.getsockname()[1])
            BoltSocket.close_socket(s)

            supported_versions = cls.protocol_handlers().keys()
            raise BoltHandshakeError(
                ""The neo4j server does not support communication with this ""
                ""driver. This driver has support for Bolt protocols ""
                ""{}."".format(tuple(map(str, supported_versions))),
                address=address, request_data=handshake, response_data=data
            )

        try:
            auth = Util.callback(auth_manager.get_auth)
        except asyncio.CancelledError as e:
            log.debug(""[#%04X]  C: <KILL> open auth manager failed: %r"",
                      s.getsockname()[1], e)
            s.kill()
            raise
        except Exception as e:
            log.debug(""[#%04X]  C: <CLOSE> open auth manager failed: %r"",
                      s.getsockname()[1], e)
            s.close()
            raise

        connection = bolt_cls(
            address, s, pool_config.max_connection_lifetime, auth=auth,
            auth_manager=auth_manager, user_agent=pool_config.user_agent,
            routing_context=routing_context,
            notifications_min_severity=pool_config.notifications_min_severity,
            notifications_disabled_categories=
                pool_config.notifications_disabled_categories,
            telemetry_disabled=pool_config.telemetry_disabled,
        )

        try:
            connection.socket.set_deadline(deadline)
            try:
                connection.hello()
            finally:
                connection.socket.set_deadline(None)
        except (
            Exception,
            # Python 3.8+: CancelledError is a subclass of BaseException
            asyncio.CancelledError,
        ) as e:
            log.debug(""[#%04X]  C: <OPEN FAILED> %r"", connection.local_port, e)
            connection.kill()
            raise

        return connection",376,500
hello,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a HELLO message to the outgoing queue, sends it and consumes
 all remaining messages.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def hello(self, dehydration_hooks=None, hydration_hooks=None):
        """""" Appends a HELLO message to the outgoing queue, sends it and consumes
         all remaining messages.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",513,526
logon,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,Append a LOGON message to the outgoing queue.,"def logon(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGON message to the outgoing queue.""""""
        pass",529,531
logoff,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,Append a LOGOFF message to the outgoing queue.,"def logoff(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a LOGOFF message to the outgoing queue.""""""
        pass",534,536
mark_unauthenticated,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,Mark the connection as unauthenticated.,"def mark_unauthenticated(self):
        """"""Mark the connection as unauthenticated.""""""
        self.auth_dict = {}",538,540
re_auth,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Append LOGON, LOGOFF to the outgoing queue.

If auth is the same as the current auth, this method does nothing.

:returns: whether the auth was changed","def re_auth(
        self, auth, auth_manager, force=False,
        dehydration_hooks=None, hydration_hooks=None,
    ):
        """"""Append LOGON, LOGOFF to the outgoing queue.

        If auth is the same as the current auth, this method does nothing.

        :returns: whether the auth was changed
        """"""
        new_auth_dict = self._to_auth_dict(auth)
        if not force and new_auth_dict == self.auth_dict:
            self.auth_manager = auth_manager
            self.auth = auth
            return False
        self.logoff(dehydration_hooks=dehydration_hooks,
                     hydration_hooks=hydration_hooks)
        self.auth_dict = new_auth_dict
        self.auth_manager = auth_manager
        self.auth = auth
        self.logon(dehydration_hooks=dehydration_hooks,
                    hydration_hooks=hydration_hooks)
        return True",542,564
route,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Fetch a routing table from the server for the given
`database`. For Bolt 4.3 and above, this appends a ROUTE
message; for earlier versions, a procedure call is made via
the regular Cypher execution mechanism. In all cases, this is
sent to the network, and a response is fetched.

:param database: database for which to fetch a routing table
    Requires Bolt 4.0+.
:param imp_user: the user to impersonate
    Requires Bolt 4.4+.
:param bookmarks: iterable of bookmark values after which this
                  transaction should begin
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def route(
        self, database=None, imp_user=None, bookmarks=None,
        dehydration_hooks=None, hydration_hooks=None
    ):
        """""" Fetch a routing table from the server for the given
        `database`. For Bolt 4.3 and above, this appends a ROUTE
        message; for earlier versions, a procedure call is made via
        the regular Cypher execution mechanism. In all cases, this is
        sent to the network, and a response is fetched.

        :param database: database for which to fetch a routing table
            Requires Bolt 4.0+.
        :param imp_user: the user to impersonate
            Requires Bolt 4.4+.
        :param bookmarks: iterable of bookmark values after which this
                          transaction should begin
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",567,592
telemetry,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Send telemetry information about the API usage to the server.

:param api: the API used.
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def telemetry(self, api: TelemetryAPI, dehydration_hooks=None,
                  hydration_hooks=None, **handlers) -> None:
        """"""Send telemetry information about the API usage to the server.

        :param api: the API used.
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",595,609
run,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a RUN message to the output queue.

:param query: Cypher query string
:param parameters: dictionary of Cypher parameters
:param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
:param bookmarks: iterable of bookmark values after which this transaction should begin
:param metadata: custom metadata dictionary to attach to the transaction
:param timeout: timeout for transaction execution (seconds)
:param db: name of the database against which to begin the transaction
    Requires Bolt 4.0+.
:param imp_user: the user to impersonate
    Requires Bolt 4.4+.
:param notifications_min_severity:
    minimum severity of notifications to be received.
    Requires Bolt 5.2+.
:param notifications_disabled_categories:
    list of notification categories to be disabled.
    Requires Bolt 5.2+.
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object","def run(self, query, parameters=None, mode=None, bookmarks=None,
            metadata=None, timeout=None, db=None, imp_user=None,
            notifications_min_severity=None,
            notifications_disabled_categories=None, dehydration_hooks=None,
            hydration_hooks=None, **handlers):
        """""" Appends a RUN message to the output queue.

        :param query: Cypher query string
        :param parameters: dictionary of Cypher parameters
        :param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
        :param bookmarks: iterable of bookmark values after which this transaction should begin
        :param metadata: custom metadata dictionary to attach to the transaction
        :param timeout: timeout for transaction execution (seconds)
        :param db: name of the database against which to begin the transaction
            Requires Bolt 4.0+.
        :param imp_user: the user to impersonate
            Requires Bolt 4.4+.
        :param notifications_min_severity:
            minimum severity of notifications to be received.
            Requires Bolt 5.2+.
        :param notifications_disabled_categories:
            list of notification categories to be disabled.
            Requires Bolt 5.2+.
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        """"""
        pass",612,645
discard,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a DISCARD message to the output queue.

:param n: number of records to discard, default = -1 (ALL)
:param qid: query ID to discard for, default = -1 (last query)
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object","def discard(self, n=-1, qid=-1, dehydration_hooks=None,
                hydration_hooks=None, **handlers):
        """""" Appends a DISCARD message to the output queue.

        :param n: number of records to discard, default = -1 (ALL)
        :param qid: query ID to discard for, default = -1 (last query)
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        """"""
        pass",648,664
pull,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a PULL message to the output queue.

:param n: number of records to pull, default = -1 (ALL)
:param qid: query ID to pull for, default = -1 (last query)
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object","def pull(self, n=-1, qid=-1, dehydration_hooks=None, hydration_hooks=None,
             **handlers):
        """""" Appends a PULL message to the output queue.

        :param n: number of records to pull, default = -1 (ALL)
        :param qid: query ID to pull for, default = -1 (last query)
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        """"""
        pass",667,683
begin,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a BEGIN message to the output queue.

:param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
:param bookmarks: iterable of bookmark values after which this transaction should begin
:param metadata: custom metadata dictionary to attach to the transaction
:param timeout: timeout for transaction execution (seconds)
:param db: name of the database against which to begin the transaction
    Requires Bolt 4.0+.
:param imp_user: the user to impersonate
    Requires Bolt 4.4+
:param notifications_min_severity:
    minimum severity of notifications to be received.
    Requires Bolt 5.2+.
:param notifications_disabled_categories:
    list of notification categories to be disabled.
    Requires Bolt 5.2+.
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.
:param handlers: handler functions passed into the returned Response object
:returns: Response object","def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,
              db=None, imp_user=None, notifications_min_severity=None,
              notifications_disabled_categories=None, dehydration_hooks=None,
              hydration_hooks=None, **handlers):
        """""" Appends a BEGIN message to the output queue.

        :param mode: access mode for routing - ""READ"" or ""WRITE"" (default)
        :param bookmarks: iterable of bookmark values after which this transaction should begin
        :param metadata: custom metadata dictionary to attach to the transaction
        :param timeout: timeout for transaction execution (seconds)
        :param db: name of the database against which to begin the transaction
            Requires Bolt 4.0+.
        :param imp_user: the user to impersonate
            Requires Bolt 4.4+
        :param notifications_min_severity:
            minimum severity of notifications to be received.
            Requires Bolt 5.2+.
        :param notifications_disabled_categories:
            list of notification categories to be disabled.
            Requires Bolt 5.2+.
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        :param handlers: handler functions passed into the returned Response object
        :returns: Response object
        """"""
        pass",686,717
commit,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a COMMIT message to the output queue.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def commit(self, dehydration_hooks=None, hydration_hooks=None, **handlers):
        """""" Appends a COMMIT message to the output queue.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",720,732
rollback,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a ROLLBACK message to the output queue.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def rollback(self, dehydration_hooks=None, hydration_hooks=None, **handlers):
        """""" Appends a ROLLBACK message to the output queue.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.""""""
        pass",735,746
reset,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a RESET message to the outgoing queue, sends it and consumes
 all remaining messages.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def reset(self, dehydration_hooks=None, hydration_hooks=None):
        """""" Appends a RESET message to the outgoing queue, sends it and consumes
         all remaining messages.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",749,762
goodbye,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Append a GOODBYE message to the outgoing queue.

:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.
:param hydration_hooks:
    Hooks to hydrate types (mapping from type (class) to
    dehydration function). Dehydration functions receive the value of
    type understood by packstream and are free to return anything.","def goodbye(self, dehydration_hooks=None, hydration_hooks=None):
        """"""Append a GOODBYE message to the outgoing queue.

        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        :param hydration_hooks:
            Hooks to hydrate types (mapping from type (class) to
            dehydration function). Dehydration functions receive the value of
            type understood by packstream and are free to return anything.
        """"""
        pass",765,777
_append,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Appends a message to the outgoing queue.

:param signature: the signature of the message
:param fields: the fields of the message as a tuple
:param response: a response object to handle callbacks
:param dehydration_hooks:
    Hooks to dehydrate types (dict from type (class) to dehydration
    function). Dehydration functions receive the value and returns an
    object of type understood by packstream.","def _append(self, signature, fields=(), response=None,
                dehydration_hooks=None):
        """""" Appends a message to the outgoing queue.

        :param signature: the signature of the message
        :param fields: the fields of the message as a tuple
        :param response: a response object to handle callbacks
        :param dehydration_hooks:
            Hooks to dehydrate types (dict from type (class) to dehydration
            function). Dehydration functions receive the value and returns an
            object of type understood by packstream.
        """"""
        self.outbox.append_message(signature, fields, dehydration_hooks)
        self.responses.append(response)
        if response:
            self._get_client_state_manager().transition(response.message)",782,797
send_all,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Send all queued messages to the server.
        ","def send_all(self):
        """""" Send all queued messages to the server.
        """"""
        if self.closed():
            raise ServiceUnavailable(
                ""Failed to write to closed connection {!r} ({!r})"".format(
                    self.unresolved_address, self.server_info.address
                )
            )
        if self.defunct():
            raise ServiceUnavailable(
                ""Failed to write to defunct connection {!r} ({!r})"".format(
                    self.unresolved_address, self.server_info.address
                )
            )

        self._send_all()",803,819
_process_message,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Receive at most one message from the server, if available.

:returns: 2-tuple of number of detail messages and number of summary
         messages fetched","def _process_message(self, tag, fields):
        """""" Receive at most one message from the server, if available.

        :returns: 2-tuple of number of detail messages and number of summary
                 messages fetched
        """"""
        pass",822,828
fetch_all,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Fetch all outstanding messages.

:returns: 2-tuple of number of detail messages and number of summary
         messages fetched","def fetch_all(self):
        """""" Fetch all outstanding messages.

        :returns: 2-tuple of number of detail messages and number of summary
                 messages fetched
        """"""
        detail_count = summary_count = 0
        while not self._closed and self.responses:
            response = self.responses[0]
            while not response.complete:
                detail_delta, summary_delta = self.fetch_message()
                detail_count += detail_delta
                summary_count += summary_delta
        return detail_count, summary_count",854,867
close,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,Close the connection.,"def close(self):
        """"""Close the connection.""""""
        if self._closed or self._closing:
            return
        self._closing = True
        if not self._defunct:
            self.goodbye()
            try:
                self._send_all()
            except (OSError, BoltError, DriverError) as exc:
                log.debug(""[#%04X]  _: <CONNECTION> ignoring failed close %r"",
                          self.local_port, exc)
        log.debug(""[#%04X]  C: <CLOSE>"", self.local_port)
        try:
            self.socket.close()
        except OSError:
            pass
        finally:
            self._closed = True",939,957
kill,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Close the socket most violently. No flush, no goodbye, no mercy.","def kill(self):
        """"""Close the socket most violently. No flush, no goodbye, no mercy.""""""
        if self._closed:
            return
        log.debug(""[#%04X]  C: <KILL>"", self.local_port)
        self._closing = True
        try:
            self.socket.kill()
        except OSError as exc:
            log.debug(""[#%04X]  _: <CONNECTION> ignoring failed kill %r"",
                      self.local_port, exc)
        finally:
            self._closed = True",959,971
is_idle_for,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/io/_bolt.py,"Check if connection has been idle for at least the given timeout.

:param timeout: timeout in seconds
:type timeout: float

:rtype: bool","def is_idle_for(self, timeout):
        """"""Check if connection has been idle for at least the given timeout.

        :param timeout: timeout in seconds
        :type timeout: float

        :rtype: bool
        """"""
        return monotonic() - self.idle_since > timeout",979,987
run,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/transaction.py,"Run a Cypher query within the context of this transaction.

Cypher is typically expressed as a query template plus a
set of named parameters. In Python, parameters may be expressed
through a dictionary of parameters, through individual parameter
arguments, or as a mixture of both. For example, the `run`
queries below are all equivalent::

    query = ""CREATE (a:Person { name: $name, age: $age })""
    result = tx.run(query, {""name"": ""Alice"", ""age"": 33})
    result = tx.run(query, {""name"": ""Alice""}, age=33)
    result = tx.run(query, name=""Alice"", age=33)

Parameter values can be of any type supported by the Neo4j type
system. In Python, this includes :class:`bool`, :class:`int`,
:class:`str`, :class:`list` and :class:`dict`. Note however that
:class:`list` properties must be homogenous.

:param query: cypher query
:type query: typing.LiteralString
:param parameters: dictionary of parameters
:type parameters: typing.Dict[str, typing.Any] | None
:param kwparameters: additional keyword parameters.
    These take precedence over parameters passed as ``parameters``.
:type kwparameters: typing.Any

:raise TransactionError: if the transaction is already closed

:returns: a new :class:`neo4j.Result` object","def run(
        self,
        query: te.LiteralString,
        parameters: t.Optional[t.Dict[str, t.Any]] = None,
        **kwparameters: t.Any
    ) -> Result:
        """"""Run a Cypher query within the context of this transaction.

        Cypher is typically expressed as a query template plus a
        set of named parameters. In Python, parameters may be expressed
        through a dictionary of parameters, through individual parameter
        arguments, or as a mixture of both. For example, the `run`
        queries below are all equivalent::

            query = ""CREATE (a:Person { name: $name, age: $age })""
            result = tx.run(query, {""name"": ""Alice"", ""age"": 33})
            result = tx.run(query, {""name"": ""Alice""}, age=33)
            result = tx.run(query, name=""Alice"", age=33)

        Parameter values can be of any type supported by the Neo4j type
        system. In Python, this includes :class:`bool`, :class:`int`,
        :class:`str`, :class:`list` and :class:`dict`. Note however that
        :class:`list` properties must be homogenous.

        :param query: cypher query
        :type query: typing.LiteralString
        :param parameters: dictionary of parameters
        :type parameters: typing.Dict[str, typing.Any] | None
        :param kwparameters: additional keyword parameters.
            These take precedence over parameters passed as ``parameters``.
        :type kwparameters: typing.Any

        :raise TransactionError: if the transaction is already closed

        :returns: a new :class:`neo4j.Result` object
        """"""
        if isinstance(query, Query):
            raise ValueError(""Query object is only supported for session.run"")

        if self._closed_flag:
            raise TransactionError(self, ""Transaction closed"")
        if self._last_error:
            raise TransactionError(self,
                                   ""Transaction failed"") from self._last_error

        if (self._results
                and self._connection.supports_multiple_results is False):
            # Bolt 3 Support
            # Buffer up all records for the previous Result because it does not
            # have any qid to fetch in batches.
            self._results[-1]._buffer_all()

        result = Result(
            self._connection, self._fetch_size,
            self._warn_notification_severity,
            self._result_on_closed_handler, self._error_handler
        )
        self._results.append(result)

        parameters = dict(parameters or {}, **kwparameters)
        result._tx_ready_run(query, parameters)

        return result",112,174
commit,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/transaction.py,"Commit the transaction and close it.

Marks this transaction as successful and closes in order to trigger a
COMMIT.

:raise TransactionError: if the transaction is already closed","def commit(self) -> None:
        """"""Commit the transaction and close it.

        Marks this transaction as successful and closes in order to trigger a
        COMMIT.

        :raise TransactionError: if the transaction is already closed
        """"""
        return self._commit()",264,272
rollback,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/transaction.py,"Rollback the transaction and close it.

Marks the transaction as unsuccessful and closes in order to trigger
a ROLLBACK.

:raise TransactionError: if the transaction is already closed","def rollback(self) -> None:
        """"""Rollback the transaction and close it.

        Marks the transaction as unsuccessful and closes in order to trigger
        a ROLLBACK.

        :raise TransactionError: if the transaction is already closed
        """"""
        return self._rollback()",274,282
close,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/transaction.py,"Close this transaction, triggering a ROLLBACK if not closed.","def close(self) -> None:
        """"""Close this transaction, triggering a ROLLBACK if not closed.""""""
        return self._close()",284,286
closed,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/transaction.py,"Indicate whether the transaction has been closed or cancelled.

:returns:
    :data:`True` if closed or cancelled, :data:`False` otherwise.
:rtype: bool","def closed(self) -> bool:
        """"""Indicate whether the transaction has been closed or cancelled.

        :returns:
            :data:`True` if closed or cancelled, :data:`False` otherwise.
        :rtype: bool
        """"""
        return self._closed()",288,295
cancel,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/transaction.py,"Cancel this transaction.

If the transaction is already closed, this method does nothing.
Else, it will close the connection without ROLLBACK or COMMIT in
a non-blocking manner.

The primary purpose of this function is to handle
:class:`asyncio.CancelledError`.

::

    tx = session.begin_transaction()
    try:
        ...  # do some work
    except asyncio.CancelledError:
        tx.cancel()
        raise","def cancel(self) -> None:
            """"""Cancel this transaction.

            If the transaction is already closed, this method does nothing.
            Else, it will close the connection without ROLLBACK or COMMIT in
            a non-blocking manner.

            The primary purpose of this function is to handle
            :class:`asyncio.CancelledError`.

            ::

                tx = session.begin_transaction()
                try:
                    ...  # do some work
                except asyncio.CancelledError:
                    tx.cancel()
                    raise

            """"""
            return self._cancel()",298,318
close,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Close the session.

This will release any borrowed resources, such as connections, and will
roll back any outstanding transactions.","def close(self) -> None:
        """"""Close the session.

        This will release any borrowed resources, such as connections, and will
        roll back any outstanding transactions.
        """"""
        if self._closed:
            return
        if self._connection:
            if self._auto_result:
                if self._state_failed is False:
                    try:
                        self._auto_result.consume()
                        self._update_bookmark(
                            self._auto_result._bookmark
                        )
                    except Exception as error:
                        # TODO: Investigate potential non graceful close states
                        self._auto_result = None
                        self._state_failed = True

            if self._transaction:
                if self._transaction._closed() is False:
                    # roll back the transaction if it is not closed
                    self._transaction._rollback()
                self._transaction = None

            try:
                if self._connection:
                    self._connection.send_all()
                    self._connection.fetch_all()
                    # TODO: Investigate potential non graceful close states
            except Neo4jError:
                pass
            except TransactionError:
                pass
            except ServiceUnavailable:
                pass
            except SessionExpired:
                pass
            finally:
                self._disconnect()

            self._state_failed = False
        self._closed = True",183,227
run,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Run a Cypher query within an auto-commit transaction.

The query is sent and the result header received
immediately but the :class:`neo4j.Result` content is
fetched lazily as consumed by the client application.

If a query is executed before a previous
:class:`neo4j.Result` in the same :class:`.Session` has
been fully consumed, the first result will be fully fetched
and buffered. Note therefore that the generally recommended
pattern of usage is to fully consume one result before
executing a subsequent query. If two results need to be
consumed in parallel, multiple :class:`.Session` objects
can be used as an alternative to result buffering.

For more usage details, see :meth:`.Transaction.run`.

:param query: cypher query
:type query: typing.LiteralString | Query
:param parameters: dictionary of parameters
:type parameters: typing.Dict[str, typing.Any] | None
:param kwargs: additional keyword parameters.
    These take precedence over parameters passed as ``parameters``.
:type kwargs: typing.Any

:returns: a new :class:`neo4j.Result` object

:raises SessionError: if the session has been closed.","def run(
        self,
        query: t.Union[te.LiteralString, Query],
        parameters: t.Optional[t.Dict[str, t.Any]] = None,
        **kwargs: t.Any
    ) -> Result:
        """"""Run a Cypher query within an auto-commit transaction.

        The query is sent and the result header received
        immediately but the :class:`neo4j.Result` content is
        fetched lazily as consumed by the client application.

        If a query is executed before a previous
        :class:`neo4j.Result` in the same :class:`.Session` has
        been fully consumed, the first result will be fully fetched
        and buffered. Note therefore that the generally recommended
        pattern of usage is to fully consume one result before
        executing a subsequent query. If two results need to be
        consumed in parallel, multiple :class:`.Session` objects
        can be used as an alternative to result buffering.

        For more usage details, see :meth:`.Transaction.run`.

        :param query: cypher query
        :type query: typing.LiteralString | Query
        :param parameters: dictionary of parameters
        :type parameters: typing.Dict[str, typing.Any] | None
        :param kwargs: additional keyword parameters.
            These take precedence over parameters passed as ``parameters``.
        :type kwargs: typing.Any

        :returns: a new :class:`neo4j.Result` object

        :raises SessionError: if the session has been closed.
        """"""
        self._check_state()
        if not query:
            raise ValueError(""Cannot run an empty query"")
        if not isinstance(query, (str, Query)):
            raise TypeError(""query must be a string or a Query instance"")

        if self._transaction:
            raise ClientError(""Explicit Transaction must be handled explicitly"")

        if self._auto_result:
            # This will buffer upp all records for the previous auto-commit tx
            self._auto_result._buffer_all()

        if not self._connection:
            self._connect(self._config.default_access_mode)
            assert self._connection is not None
        cx = self._connection

        cx.telemetry(TelemetryAPI.AUTO_COMMIT)
        self._auto_result = Result(
            cx, self._config.fetch_size,
            self._config.warn_notification_severity,
            self._result_closed, self._result_error,
        )
        bookmarks = self._get_bookmarks()
        parameters = dict(parameters or {}, **kwargs)
        self._auto_result._run(
            query, parameters, self._config.database,
            self._config.impersonated_user, self._config.default_access_mode,
            bookmarks, self._config.notifications_min_severity,
            self._config.notifications_disabled_categories,
        )

        return self._auto_result",253,321
last_bookmark,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Get the bookmark received following the last completed transaction.

Note: For auto-commit transactions (:meth:`Session.run`), this will
trigger :meth:`Result.consume` for the current result.

.. warning::
    This method can lead to unexpected behaviour if the session has not
    yet successfully completed a transaction.

:returns: last bookmark

.. deprecated:: 5.0
    :meth:`last_bookmark` will be removed in version 6.0.
    Use :meth:`last_bookmarks` instead.","def last_bookmark(self) -> t.Optional[str]:
        """"""Get the bookmark received following the last completed transaction.

        Note: For auto-commit transactions (:meth:`Session.run`), this will
        trigger :meth:`Result.consume` for the current result.

        .. warning::
            This method can lead to unexpected behaviour if the session has not
            yet successfully completed a transaction.

        :returns: last bookmark

        .. deprecated:: 5.0
            :meth:`last_bookmark` will be removed in version 6.0.
            Use :meth:`last_bookmarks` instead.
        """"""
        # The set of bookmarks to be passed into the next transaction.

        if self._auto_result:
            self._auto_result.consume()

        if self._transaction and self._transaction._closed():
            self._update_bookmark(self._transaction._bookmark)
            self._transaction = None

        if self._bookmarks:
            return self._bookmarks[-1]
        return None",328,355
last_bookmarks,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Return most recent bookmarks of the session.

Bookmarks can be used to causally chain sessions. For example,
if a session (``session1``) wrote something, that another session
(``session2``) needs to read, use
``session2 = driver.session(bookmarks=session1.last_bookmarks())`` to
achieve this.

Combine the bookmarks of multiple sessions like so::

    bookmarks1 = session1.last_bookmarks()
    bookmarks2 = session2.last_bookmarks()
    session3 = driver.session(bookmarks=bookmarks1 + bookmarks2)

A session automatically manages bookmarks, so this method is rarely
needed. If you need causal consistency, try to run the relevant queries
in the same session.

""Most recent bookmarks"" are either the bookmarks passed to the session
on creation, or the last bookmark the session received after committing
a transaction to the server.

Note: For auto-commit transactions (:meth:`Session.run`), this will
trigger :meth:`Result.consume` for the current result.

:returns: the session's last known bookmarks","def last_bookmarks(self) -> Bookmarks:
        """"""Return most recent bookmarks of the session.

        Bookmarks can be used to causally chain sessions. For example,
        if a session (``session1``) wrote something, that another session
        (``session2``) needs to read, use
        ``session2 = driver.session(bookmarks=session1.last_bookmarks())`` to
        achieve this.

        Combine the bookmarks of multiple sessions like so::

            bookmarks1 = session1.last_bookmarks()
            bookmarks2 = session2.last_bookmarks()
            session3 = driver.session(bookmarks=bookmarks1 + bookmarks2)

        A session automatically manages bookmarks, so this method is rarely
        needed. If you need causal consistency, try to run the relevant queries
        in the same session.

        ""Most recent bookmarks"" are either the bookmarks passed to the session
        on creation, or the last bookmark the session received after committing
        a transaction to the server.

        Note: For auto-commit transactions (:meth:`Session.run`), this will
        trigger :meth:`Result.consume` for the current result.

        :returns: the session's last known bookmarks
        """"""
        # The set of bookmarks to be passed into the next transaction.

        if self._auto_result:
            self._auto_result.consume()

        if self._transaction and self._transaction._closed():
            self._update_bookmark(self._transaction._bookmark)
            self._transaction = None

        return Bookmarks.from_raw_values(self._bookmarks)",358,395
begin_transaction,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Begin a new unmanaged transaction.

Creates a new :class:`.Transaction` within this session.
At most one transaction may exist in a session at any point in time.
To maintain multiple concurrent transactions, use multiple concurrent
sessions.

Note: For auto-commit transactions (:meth:`.Session.run`), this
will trigger a :meth:`.Result.consume` for the current result.

:param metadata:
    a dictionary with metadata.
    Specified metadata will be attached to the executing transaction
    and visible in the output of ``SHOW TRANSACTIONS YIELD *``
    It will also get logged to the ``query.log``.
    This functionality makes it easier to tag transactions and is
    equivalent to the ``dbms.setTXMetaData`` procedure, see
    https://neo4j.com/docs/cypher-manual/current/clauses/transaction-clauses/#query-listing-transactions
    and https://neo4j.com/docs/operations-manual/current/reference/procedures/
    for reference.

:param timeout:
    the transaction timeout in seconds.
    Transactions that execute longer than the configured timeout will
    be terminated by the database.
    This functionality allows user code to limit query/transaction
    execution time.
    The specified timeout overrides the default timeout configured in
    the database using the ``db.transaction.timeout`` setting
    (``dbms.transaction.timeout`` before Neo4j 5.0).
    Values higher than ``db.transaction.timeout`` will be ignored and
    will fall back to the default for server versions between 4.2 and
    5.2 (inclusive).
    The value should not represent a negative duration.
    A ``0`` duration will make the transaction execute indefinitely.
    :data:`None` will use the default timeout configured on the server.

:returns: A new transaction instance.

:raises TransactionError: if a transaction is already open.
:raises SessionError: if the session has been closed.","def begin_transaction(
        self,
        metadata: t.Optional[t.Dict[str, t.Any]] = None,
        timeout: t.Optional[float] = None
    ) -> Transaction:
        """"""Begin a new unmanaged transaction.

        Creates a new :class:`.Transaction` within this session.
        At most one transaction may exist in a session at any point in time.
        To maintain multiple concurrent transactions, use multiple concurrent
        sessions.

        Note: For auto-commit transactions (:meth:`.Session.run`), this
        will trigger a :meth:`.Result.consume` for the current result.

        :param metadata:
            a dictionary with metadata.
            Specified metadata will be attached to the executing transaction
            and visible in the output of ``SHOW TRANSACTIONS YIELD *``
            It will also get logged to the ``query.log``.
            This functionality makes it easier to tag transactions and is
            equivalent to the ``dbms.setTXMetaData`` procedure, see
            https://neo4j.com/docs/cypher-manual/current/clauses/transaction-clauses/#query-listing-transactions
            and https://neo4j.com/docs/operations-manual/current/reference/procedures/
            for reference.

        :param timeout:
            the transaction timeout in seconds.
            Transactions that execute longer than the configured timeout will
            be terminated by the database.
            This functionality allows user code to limit query/transaction
            execution time.
            The specified timeout overrides the default timeout configured in
            the database using the ``db.transaction.timeout`` setting
            (``dbms.transaction.timeout`` before Neo4j 5.0).
            Values higher than ``db.transaction.timeout`` will be ignored and
            will fall back to the default for server versions between 4.2 and
            5.2 (inclusive).
            The value should not represent a negative duration.
            A ``0`` duration will make the transaction execute indefinitely.
            :data:`None` will use the default timeout configured on the server.

        :returns: A new transaction instance.

        :raises TransactionError: if a transaction is already open.
        :raises SessionError: if the session has been closed.
        """"""
        self._check_state()
        # TODO: Implement TransactionConfig consumption

        if self._auto_result:
            self._auto_result.consume()

        if self._transaction:
            raise TransactionError(
                self._transaction, ""Explicit transaction already open""
            )

        self._open_transaction(
            tx_cls=Transaction, api=TelemetryAPI.TX,
            access_mode=self._config.default_access_mode, metadata=metadata,
            timeout=timeout
        )

        return t.cast(Transaction, self._transaction)",445,509
execute_read,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Execute a unit of work in a managed read transaction.

.. note::
    This does not necessarily imply access control, see the session
    configuration option :ref:`default-access-mode-ref`.

This transaction will automatically be committed when the function
returns, unless an exception is thrown during query execution or by
the user code. Note, that this function performs retries and that the
supplied `transaction_function` might get invoked more than once.
Therefore, it needs to be idempotent (i.e., have the same effect,
regardless if called once or many times).

Example::

    def do_cypher_tx(tx, cypher):
        result = tx.run(cypher)
        values = [record.values() for record in result]
        return values

    with driver.session() as session:
        values = session.execute_read(do_cypher_tx, ""RETURN 1 AS x"")

Example::

    def get_two_tx(tx):
        result = tx.run(""UNWIND [1,2,3,4] AS x RETURN x"")
        values = []
        for record in result:
            if len(values) >= 2:
                break
            values.append(record.values())
        # or shorter: values = [record.values()
        #                       for record in result.fetch(2)]

        # discard the remaining records if there are any
        summary = result.consume()
        # use the summary for logging etc.
        return values

    with driver.session() as session:
        values = session.execute_read(get_two_tx)

:param transaction_function: a function that takes a transaction as an
    argument and does work with the transaction.
    ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
    :class:`.ManagedTransaction`.
:type transaction_function:
    typing.Callable[[ManagedTransaction, P], typing.Union[R]]
:param args: additional arguments for the `transaction_function`
:type args: P
:param kwargs: key word arguments for the `transaction_function`
:type kwargs: P

:returns: whatever the given `transaction_function` returns
:rtype: R

:raises SessionError: if the session has been closed.

.. versionadded:: 5.0","def execute_read(
        self,
        transaction_function: t.Callable[
            te.Concatenate[ManagedTransaction, _P], t.Union[_R]
        ],
        *args: _P.args, **kwargs: _P.kwargs
    ) -> _R:
        """"""Execute a unit of work in a managed read transaction.

        .. note::
            This does not necessarily imply access control, see the session
            configuration option :ref:`default-access-mode-ref`.

        This transaction will automatically be committed when the function
        returns, unless an exception is thrown during query execution or by
        the user code. Note, that this function performs retries and that the
        supplied `transaction_function` might get invoked more than once.
        Therefore, it needs to be idempotent (i.e., have the same effect,
        regardless if called once or many times).

        Example::

            def do_cypher_tx(tx, cypher):
                result = tx.run(cypher)
                values = [record.values() for record in result]
                return values

            with driver.session() as session:
                values = session.execute_read(do_cypher_tx, ""RETURN 1 AS x"")

        Example::

            def get_two_tx(tx):
                result = tx.run(""UNWIND [1,2,3,4] AS x RETURN x"")
                values = []
                for record in result:
                    if len(values) >= 2:
                        break
                    values.append(record.values())
                # or shorter: values = [record.values()
                #                       for record in result.fetch(2)]

                # discard the remaining records if there are any
                summary = result.consume()
                # use the summary for logging etc.
                return values

            with driver.session() as session:
                values = session.execute_read(get_two_tx)

        :param transaction_function: a function that takes a transaction as an
            argument and does work with the transaction.
            ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
            :class:`.ManagedTransaction`.
        :type transaction_function:
            typing.Callable[[ManagedTransaction, P], typing.Union[R]]
        :param args: additional arguments for the `transaction_function`
        :type args: P
        :param kwargs: key word arguments for the `transaction_function`
        :type kwargs: P

        :returns: whatever the given `transaction_function` returns
        :rtype: R

        :raises SessionError: if the session has been closed.

        .. versionadded:: 5.0
        """"""
        return self._run_transaction(
            READ_ACCESS, TelemetryAPI.TX_FUNC,
            transaction_function, args, kwargs
        )",595,666
read_transaction,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Execute a unit of work in a managed read transaction.

.. note::
    This does not necessarily imply access control, see the session
    configuration option :ref:`default-access-mode-ref`.

:param transaction_function: a function that takes a transaction as an
    argument and does work with the transaction.
    ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
    :class:`.ManagedTransaction`.
:type transaction_function:
    typing.Callable[[ManagedTransaction, P], typing.Union[R]]
:param args: additional arguments for the `transaction_function`
:type args: P
:param kwargs: key word arguments for the `transaction_function`
:type kwargs: P

:returns: a result as returned by the given unit of work
:rtype: R

:raises SessionError: if the session has been closed.

.. deprecated:: 5.0
    Method was renamed to :meth:`.execute_read`.","def read_transaction(
        self,
        transaction_function: t.Callable[
            te.Concatenate[ManagedTransaction, _P], t.Union[_R]
        ],
        *args: _P.args, **kwargs: _P.kwargs
    ) -> _R:
        """"""Execute a unit of work in a managed read transaction.

        .. note::
            This does not necessarily imply access control, see the session
            configuration option :ref:`default-access-mode-ref`.

        :param transaction_function: a function that takes a transaction as an
            argument and does work with the transaction.
            ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
            :class:`.ManagedTransaction`.
        :type transaction_function:
            typing.Callable[[ManagedTransaction, P], typing.Union[R]]
        :param args: additional arguments for the `transaction_function`
        :type args: P
        :param kwargs: key word arguments for the `transaction_function`
        :type kwargs: P

        :returns: a result as returned by the given unit of work
        :rtype: R

        :raises SessionError: if the session has been closed.

        .. deprecated:: 5.0
            Method was renamed to :meth:`.execute_read`.
        """"""
        return self._run_transaction(
            READ_ACCESS, TelemetryAPI.TX_FUNC,
            transaction_function, args, kwargs
        )",671,706
execute_write,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Execute a unit of work in a managed write transaction.

.. note::
    This does not necessarily imply access control, see the session
    configuration option :ref:`default-access-mode-ref`.

This transaction will automatically be committed when the function
returns unless, an exception is thrown during query execution or by
the user code. Note, that this function performs retries and that the
supplied `transaction_function` might get invoked more than once.
Therefore, it needs to be idempotent (i.e., have the same effect,
regardless if called once or many times).

Example::

    def create_node_tx(tx, name):
        query = (""CREATE (n:NodeExample {name: $name, id: randomUUID()}) ""
                 ""RETURN n.id AS node_id"")
        result = tx.run(query, name=name)
        record = result.single()
        return record[""node_id""]

    with driver.session() as session:
        node_id = session.execute_write(create_node_tx, ""Bob"")

:param transaction_function: a function that takes a transaction as an
    argument and does work with the transaction.
    ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
    :class:`.ManagedTransaction`.
:type transaction_function:
    typing.Callable[[ManagedTransaction, P], typing.Union[R]]
:param args: additional arguments for the `transaction_function`
:type args: P
:param kwargs: key word arguments for the `transaction_function`
:type kwargs: P

:returns: a result as returned by the given unit of work
:rtype: R

:raises SessionError: if the session has been closed.

.. versionadded:: 5.0","def execute_write(
        self,
        transaction_function: t.Callable[
            te.Concatenate[ManagedTransaction, _P], t.Union[_R]
        ],
        *args: _P.args,  **kwargs: _P.kwargs
    ) -> _R:
        """"""Execute a unit of work in a managed write transaction.

        .. note::
            This does not necessarily imply access control, see the session
            configuration option :ref:`default-access-mode-ref`.

        This transaction will automatically be committed when the function
        returns unless, an exception is thrown during query execution or by
        the user code. Note, that this function performs retries and that the
        supplied `transaction_function` might get invoked more than once.
        Therefore, it needs to be idempotent (i.e., have the same effect,
        regardless if called once or many times).

        Example::

            def create_node_tx(tx, name):
                query = (""CREATE (n:NodeExample {name: $name, id: randomUUID()}) ""
                         ""RETURN n.id AS node_id"")
                result = tx.run(query, name=name)
                record = result.single()
                return record[""node_id""]

            with driver.session() as session:
                node_id = session.execute_write(create_node_tx, ""Bob"")

        :param transaction_function: a function that takes a transaction as an
            argument and does work with the transaction.
            ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
            :class:`.ManagedTransaction`.
        :type transaction_function:
            typing.Callable[[ManagedTransaction, P], typing.Union[R]]
        :param args: additional arguments for the `transaction_function`
        :type args: P
        :param kwargs: key word arguments for the `transaction_function`
        :type kwargs: P

        :returns: a result as returned by the given unit of work
        :rtype: R

        :raises SessionError: if the session has been closed.

        .. versionadded:: 5.0
        """"""
        return self._run_transaction(
            WRITE_ACCESS, TelemetryAPI.TX_FUNC,
            transaction_function, args, kwargs
        )",709,762
write_transaction,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Execute a unit of work in a managed write transaction.

.. note::
    This does not necessarily imply access control, see the session
    configuration option :ref:`default-access-mode-ref`.

:param transaction_function: a function that takes a transaction as an
    argument and does work with the transaction.
    ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
    :class:`.ManagedTransaction`.
:type transaction_function:
    typing.Callable[[ManagedTransaction, P], typing.Union[R]]
:param args: additional arguments for the `transaction_function`
:type args: P
:param kwargs: key word arguments for the `transaction_function`
:type kwargs: P

:returns: a result as returned by the given unit of work
:rtype: R

:raises SessionError: if the session has been closed.

.. deprecated:: 5.0
    Method was renamed to :meth:`.execute_write`.","def write_transaction(
        self,
        transaction_function: t.Callable[
            te.Concatenate[ManagedTransaction, _P], t.Union[_R]
        ],
        *args: _P.args,  **kwargs: _P.kwargs
    ) -> _R:
        """"""Execute a unit of work in a managed write transaction.

        .. note::
            This does not necessarily imply access control, see the session
            configuration option :ref:`default-access-mode-ref`.

        :param transaction_function: a function that takes a transaction as an
            argument and does work with the transaction.
            ``transaction_function(tx, *args, **kwargs)`` where ``tx`` is a
            :class:`.ManagedTransaction`.
        :type transaction_function:
            typing.Callable[[ManagedTransaction, P], typing.Union[R]]
        :param args: additional arguments for the `transaction_function`
        :type args: P
        :param kwargs: key word arguments for the `transaction_function`
        :type kwargs: P

        :returns: a result as returned by the given unit of work
        :rtype: R

        :raises SessionError: if the session has been closed.

        .. deprecated:: 5.0
            Method was renamed to :meth:`.execute_write`.
        """"""
        return self._run_transaction(
            WRITE_ACCESS, TelemetryAPI.TX_FUNC,
            transaction_function, args, kwargs
        )",767,802
cancel,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/session.py,"Cancel this session.

If the session is already closed, this method does nothing.
Else, it will if present, forcefully close the connection the
session holds. This will violently kill all work in flight.

The primary purpose of this function is to handle
:class:`asyncio.CancelledError`.

::

    session = driver.session()
    try:
        ...  # do some work
    except asyncio.CancelledError:
        session.cancel()
        raise","def cancel(self) -> None:
            """"""Cancel this session.

            If the session is already closed, this method does nothing.
            Else, it will if present, forcefully close the connection the
            session holds. This will violently kill all work in flight.

            The primary purpose of this function is to handle
            :class:`asyncio.CancelledError`.

            ::

                session = driver.session()
                try:
                    ...  # do some work
                except asyncio.CancelledError:
                    session.cancel()
                    raise

            """"""
            self._handle_cancellation(message=""manual cancel"")",230,250
__iter__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Iterator returning Records.

Advancing the iterator advances the underlying result stream.
So even when creating multiple iterators from the same result, each
Record will only be returned once.

:returns: Iterator over the result stream's records.","def __iter__(self) -> t.Iterator[Record]:
        """"""Iterator returning Records.

        Advancing the iterator advances the underlying result stream.
        So even when creating multiple iterators from the same result, each
        Record will only be returned once.

        :returns: Iterator over the result stream's records.
        """"""
        while self._record_buffer or self._attached:
            if self._record_buffer:
                yield self._record_buffer.popleft()
            elif self._streaming:
                self._connection.fetch_message()
            elif self._discarding:
                self._discard()
                self._connection.send_all()
            elif self._has_more:
                self._pull()
                self._connection.send_all()

        self._exhausted = True
        if self._exception is not None:
            raise ResultFailedError(self, _RESULT_FAILED_ERROR) \
                from self._exception
        if self._out_of_scope:
            raise ResultConsumedError(self, _RESULT_OUT_OF_SCOPE_ERROR)
        if self._consumed:
            raise ResultConsumedError(self, _RESULT_CONSUMED_ERROR)",361,389
__next__,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Advance the result stream and return the record.

:raises StopIteration: if no more records are available.","def __next__(self) -> Record:
        """"""Advance the result stream and return the record.

        :raises StopIteration: if no more records are available.
        """"""
        return self.__iter__().__next__()",392,397
_attach,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Sets the Result object in an attached state by fetching messages from
the connection to the buffer.","def _attach(self):
        """"""Sets the Result object in an attached state by fetching messages from
        the connection to the buffer.
        """"""
        if self._exhausted is False:
            while self._attached is False:
                self._connection.fetch_message()",399,405
_buffer,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Try to fill `self._record_buffer` with n records.

Might end up with more records in the buffer if the fetch size makes it
overshoot.
Might end up with fewer records in the buffer if there are not enough
records available.","def _buffer(self, n=None):
        """"""Try to fill `self._record_buffer` with n records.

        Might end up with more records in the buffer if the fetch size makes it
        overshoot.
        Might end up with fewer records in the buffer if there are not enough
        records available.
        """"""
        if self._out_of_scope:
            raise ResultConsumedError(self, _RESULT_OUT_OF_SCOPE_ERROR)
        if self._consumed:
            raise ResultConsumedError(self, _RESULT_CONSUMED_ERROR)
        if n is not None and len(self._record_buffer) >= n:
            return
        record_buffer = deque()
        for record in self:
            record_buffer.append(record)
            if n is not None and len(record_buffer) >= n:
                break
        if n is None:
            self._record_buffer = record_buffer
        else:
            self._record_buffer.extend(record_buffer)
        self._exhausted = not self._record_buffer",407,430
_buffer_all,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Sets the Result object in an detached state by fetching all records
from the connection to the buffer.","def _buffer_all(self):
        """"""Sets the Result object in an detached state by fetching all records
        from the connection to the buffer.
        """"""
        self._buffer()",432,436
_obtain_summary,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Obtain the summary of this result.

:returns: The :class:`neo4j.ResultSummary` for this result","def _obtain_summary(self) -> ResultSummary:
        """"""Obtain the summary of this result.

        :returns: The :class:`neo4j.ResultSummary` for this result
        """"""
        if self._summary is None:
            self._summary = ResultSummary(self._address, **self._metadata)
        return self._summary",438,445
keys,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"The keys for the records in this result.

:returns: tuple of key names
:rtype: tuple","def keys(self) -> t.Tuple[str, ...]:
        """"""The keys for the records in this result.

        :returns: tuple of key names
        :rtype: tuple
        """"""
        return self._keys",447,453
consume,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Consume the remainder of this result and return a :class:`neo4j.ResultSummary`.

Example::

    def create_node_tx(tx, name):
        result = tx.run(
            ""CREATE (n:ExampleNode {name: $name}) RETURN n"", name=name
        )
        record = result.single()
        value = record.value()
        summary = result.consume()
        return value, summary

    with driver.session() as session:
        node_id, summary = session.execute_write(
            create_node_tx, ""example""
        )

Example::

    def get_two_tx(tx):
        result = tx.run(""UNWIND [1,2,3,4] AS x RETURN x"")
        values = []
        for record in result:
            if len(values) >= 2:
                break
            values.append(record.values())
        # or shorter: values = [record.values()
        #                       for record in result.fetch(2)]

        # discard the remaining records if there are any
        summary = result.consume()
        # use the summary for logging etc.
        return values, summary

    with driver.session() as session:
        values, summary = session.execute_read(get_two_tx)

:returns: The :class:`neo4j.ResultSummary` for this result

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed.

.. versionchanged:: 5.0
    Can raise :exc:`.ResultConsumedError`.","def consume(self) -> ResultSummary:
        """"""Consume the remainder of this result and return a :class:`neo4j.ResultSummary`.

        Example::

            def create_node_tx(tx, name):
                result = tx.run(
                    ""CREATE (n:ExampleNode {name: $name}) RETURN n"", name=name
                )
                record = result.single()
                value = record.value()
                summary = result.consume()
                return value, summary

            with driver.session() as session:
                node_id, summary = session.execute_write(
                    create_node_tx, ""example""
                )

        Example::

            def get_two_tx(tx):
                result = tx.run(""UNWIND [1,2,3,4] AS x RETURN x"")
                values = []
                for record in result:
                    if len(values) >= 2:
                        break
                    values.append(record.values())
                # or shorter: values = [record.values()
                #                       for record in result.fetch(2)]

                # discard the remaining records if there are any
                summary = result.consume()
                # use the summary for logging etc.
                return values, summary

            with driver.session() as session:
                values, summary = session.execute_read(get_two_tx)

        :returns: The :class:`neo4j.ResultSummary` for this result

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed.

        .. versionchanged:: 5.0
            Can raise :exc:`.ResultConsumedError`.
        """"""
        if self._out_of_scope:
            raise ResultConsumedError(self, _RESULT_OUT_OF_SCOPE_ERROR)
        if self._consumed:
            return self._obtain_summary()

        self._exhaust()
        summary = self._obtain_summary()
        self._consumed = True
        return summary",477,532
single,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Obtain the next and only remaining record or None.

Calling this method always exhausts the result.

If ``strict`` is :data:`True`, this method will raise an exception if
there is not exactly one record left.

If ``strict`` is :data:`False`, fewer than one record will make this
method return :data:`None`, more than one record will make this method
emit a warning and return the first record.

:param strict:
    If :data:`True`, raise a :exc:`.ResultNotSingleError` instead of
    returning :data:`None` if there is more than one record or warning
    if there is more than 1 record.
    :data:`False` by default.
:type strict: bool

:returns: the next :class:`neo4j.Record` or :data:`None` if none remain

:warns: if more than one record is available and
    ``strict`` is :data:`False`

:raises ResultNotSingleError:
    If ``strict=True`` and not exactly one record is available.
:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. versionchanged:: 5.0

    * Added ``strict`` parameter.
    * Can raise :exc:`.ResultConsumedError`.","def single(self, strict: bool = False) -> t.Optional[Record]:
        """"""Obtain the next and only remaining record or None.

        Calling this method always exhausts the result.

        If ``strict`` is :data:`True`, this method will raise an exception if
        there is not exactly one record left.

        If ``strict`` is :data:`False`, fewer than one record will make this
        method return :data:`None`, more than one record will make this method
        emit a warning and return the first record.

        :param strict:
            If :data:`True`, raise a :exc:`.ResultNotSingleError` instead of
            returning :data:`None` if there is more than one record or warning
            if there is more than 1 record.
            :data:`False` by default.
        :type strict: bool

        :returns: the next :class:`neo4j.Record` or :data:`None` if none remain

        :warns: if more than one record is available and
            ``strict`` is :data:`False`

        :raises ResultNotSingleError:
            If ``strict=True`` and not exactly one record is available.
        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. versionchanged:: 5.0

            * Added ``strict`` parameter.
            * Can raise :exc:`.ResultConsumedError`.
        """"""
        self._buffer(2)
        buffer = self._record_buffer
        self._record_buffer = deque()
        self._exhaust()
        if not buffer:
            if not strict:
                return None
            raise ResultNotSingleError(
                self,
                ""No records found. ""
                ""Make sure your query returns exactly one record.""
            )
        elif len(buffer) > 1:
            res = buffer.popleft()
            if not strict:
                warn(""Expected a result with a single record, ""
                     ""but found multiple."")
                return res
            else:
                raise ResultNotSingleError(
                    self,
                    ""More than one record found. ""
                    ""Make sure your query returns exactly one record.""
                )
        return buffer.popleft()",545,604
fetch,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Obtain up to n records from this result.

Fetch ``min(n, records_left)`` records from this result and return them
as a list.

:param n: the maximum number of records to fetch.

:returns: list of :class:`neo4j.Record`

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. versionadded:: 5.0","def fetch(self, n: int) -> t.List[Record]:
        """"""Obtain up to n records from this result.

        Fetch ``min(n, records_left)`` records from this result and return them
        as a list.

        :param n: the maximum number of records to fetch.

        :returns: list of :class:`neo4j.Record`

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. versionadded:: 5.0
        """"""
        self._buffer(n)
        return [
            self._record_buffer.popleft()
            for _ in range(min(n, len(self._record_buffer)))
        ]",607,627
peek,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Obtain the next record from this result without consuming it.

This leaves the record in the buffer for further processing.

:returns: the next :class:`neo4j.Record` or :data:`None` if none
    remain.

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. versionchanged:: 5.0
    Can raise :exc:`.ResultConsumedError`.","def peek(self) -> t.Optional[Record]:
        """"""Obtain the next record from this result without consuming it.

        This leaves the record in the buffer for further processing.

        :returns: the next :class:`neo4j.Record` or :data:`None` if none
            remain.

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. versionchanged:: 5.0
            Can raise :exc:`.ResultConsumedError`.
        """"""
        self._buffer(1)
        if self._record_buffer:
            return self._record_buffer[0]
        return None",630,648
graph,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Turn the result into a :class:`.Graph`.

Return a :class:`.Graph` instance containing all the graph objects in
the result.
This graph will also contain already consumed records.

After calling this method, the result becomes detached, buffering all
remaining records.

:returns: a result graph

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. versionchanged:: 5.0
    Can raise :exc:`.ResultConsumedError`.","def graph(self) -> Graph:
        """"""Turn the result into a :class:`.Graph`.

        Return a :class:`.Graph` instance containing all the graph objects in
        the result.
        This graph will also contain already consumed records.

        After calling this method, the result becomes detached, buffering all
        remaining records.

        :returns: a result graph

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. versionchanged:: 5.0
            Can raise :exc:`.ResultConsumedError`.
        """"""
        self._buffer_all()
        return self._hydration_scope.get_graph()",651,671
value,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Return the remainder of the result as a list of values.

:param key: field to return for each remaining record. Obtain a single value from the record by index or key.
:param default: default value, used if the index of key is unavailable

:returns: list of individual values

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. seealso:: :meth:`.Record.value`

.. versionchanged:: 5.0
    Can raise :exc:`.ResultConsumedError`.","def value(
        self, key: _TResultKey = 0, default: t.Optional[object] = None
    ) -> t.List[t.Any]:
        """"""Return the remainder of the result as a list of values.

        :param key: field to return for each remaining record. Obtain a single value from the record by index or key.
        :param default: default value, used if the index of key is unavailable

        :returns: list of individual values

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. seealso:: :meth:`.Record.value`

        .. versionchanged:: 5.0
            Can raise :exc:`.ResultConsumedError`.
        """"""
        return [record.value(key, default) for record in self]",674,693
values,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Return the remainder of the result as a list of values lists.

:param keys: fields to return for each remaining record. Optionally filtering to include only certain values by index or key.

:returns: list of values lists

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. seealso:: :meth:`.Record.values`

.. versionchanged:: 5.0
    Can raise :exc:`.ResultConsumedError`.","def values(
        self, *keys: _TResultKey
    ) -> t.List[t.List[t.Any]]:
        """"""Return the remainder of the result as a list of values lists.

        :param keys: fields to return for each remaining record. Optionally filtering to include only certain values by index or key.

        :returns: list of values lists

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. seealso:: :meth:`.Record.values`

        .. versionchanged:: 5.0
            Can raise :exc:`.ResultConsumedError`.
        """"""
        return [record.values(*keys) for record in self]",696,714
data,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Return the remainder of the result as a list of dictionaries.

Each dictionary represents a record

This function provides a convenient but opinionated way to obtain the
remainder of the result as mostly JSON serializable data. It is mainly
useful for interactive sessions and rapid prototyping.

For details see :meth:`.Record.data`.

:param keys: Fields to return for each remaining record.
    Optionally filtering to include only certain values by index or
    key.

:returns: list of dictionaries

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. seealso:: :meth:`.Record.data`

.. versionchanged:: 5.0
    Can raise :exc:`.ResultConsumedError`.","def data(self, *keys: _TResultKey) -> t.List[t.Dict[str, t.Any]]:
        """"""Return the remainder of the result as a list of dictionaries.

        Each dictionary represents a record

        This function provides a convenient but opinionated way to obtain the
        remainder of the result as mostly JSON serializable data. It is mainly
        useful for interactive sessions and rapid prototyping.

        For details see :meth:`.Record.data`.

        :param keys: Fields to return for each remaining record.
            Optionally filtering to include only certain values by index or
            key.

        :returns: list of dictionaries

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. seealso:: :meth:`.Record.data`

        .. versionchanged:: 5.0
            Can raise :exc:`.ResultConsumedError`.
        """"""
        return [record.data(*keys) for record in self]",717,743
to_eager_result,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Convert this result to an :class:`.EagerResult`.

This method exhausts the result and triggers a :meth:`.consume`.

:returns: all remaining records in the result stream, the result's
    summary, and keys as an :class:`.EagerResult` instance.

:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.

.. versionadded:: 5.5

.. versionchanged:: 5.8 Stabilized from experimental.","def to_eager_result(self) -> EagerResult:
        """"""Convert this result to an :class:`.EagerResult`.

        This method exhausts the result and triggers a :meth:`.consume`.

        :returns: all remaining records in the result stream, the result's
            summary, and keys as an :class:`.EagerResult` instance.

        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.

        .. versionadded:: 5.5

        .. versionchanged:: 5.8 Stabilized from experimental.
        """"""

        self._buffer_all()
        return EagerResult(
            keys=list(self.keys()),
            records=Util.list(self),
            summary=self.consume()
        )",746,768
to_df,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Convert (the rest of) the result to a pandas DataFrame.

This method is only available if the `pandas` library is installed.

::

    res = tx.run(""UNWIND range(1, 10) AS n RETURN n, n+1 AS m"")
    df = res.to_df()

for instance will return a DataFrame with two columns: ``n`` and ``m``
and 10 rows.

:param expand: If :data:`True`, some structures in the result will be
    recursively expanded (flattened out into multiple columns) like so
    (everything inside ``<...>`` is a placeholder):

    * :class:`.Node` objects under any variable ``<n>`` will be
      expanded into columns (the recursion stops here)

      * ``<n>().prop.<property_name>`` (any) for each property of the
        node.
      * ``<n>().element_id`` (str) the node's element id.
        See :attr:`.Node.element_id`.
      * ``<n>().labels`` (frozenset of str) the node's labels.
        See :attr:`.Node.labels`.

    * :class:`.Relationship` objects under any variable ``<r>``
      will be expanded into columns (the recursion stops here)

      * ``<r>->.prop.<property_name>`` (any) for each property of the
        relationship.
      * ``<r>->.element_id`` (str) the relationship's element id.
        See :attr:`.Relationship.element_id`.
      * ``<r>->.start.element_id`` (str) the relationship's
        start node's element id.
        See :attr:`.Relationship.start_node`.
      * ``<r>->.end.element_id`` (str) the relationship's
        end node's element id.
        See :attr:`.Relationship.end_node`.
      * ``<r>->.type`` (str) the relationship's type.
        See :attr:`.Relationship.type`.

    * :class:`list` objects under any variable ``<l>`` will be expanded
      into

      * ``<l>[].0`` (any) the 1st list element
      * ``<l>[].1`` (any) the 2nd list element
      * ...

    * :class:`dict` objects under any variable ``<d>`` will be expanded
      into

      * ``<d>{}.<key1>`` (any) the 1st key of the dict
      * ``<d>{}.<key2>`` (any) the 2nd key of the dict
      * ...

    * :class:`list` and :class:`dict` objects are expanded recursively.
      Example::

        variable x: [{""foo"": ""bar"", ""baz"": [42, 0]}, ""foobar""]

      will be expanded to::

        {
            ""x[].0{}.foo"": ""bar"",
            ""x[].0{}.baz[].0"": 42,
            ""n[].0{}.baz[].1"": 0,
            ""n[].1"": ""foobar""
        }

    * Everything else (including :class:`.Path` objects) will not
      be flattened.

    :class:`dict` keys and variable names that contain ``.``  or ``\``
    will be escaped with a backslash (``\.`` and ``\\`` respectively).
:param parse_dates:
    If :data:`True`, columns that exclusively contain
    :class:`time.DateTime` objects, :class:`time.Date` objects, or
    :data:`None`, will be converted to :class:`pandas.Timestamp`.

:raises ImportError: if `pandas` library is not available.
:raises ResultConsumedError: if the transaction from which this result
    was obtained has been closed or the Result has been explicitly
    consumed.","def to_df(
        self,
        expand: bool = False,
        parse_dates: bool = False
    ) -> pandas.DataFrame:
        r""""""Convert (the rest of) the result to a pandas DataFrame.

        This method is only available if the `pandas` library is installed.

        ::

            res = tx.run(""UNWIND range(1, 10) AS n RETURN n, n+1 AS m"")
            df = res.to_df()

        for instance will return a DataFrame with two columns: ``n`` and ``m``
        and 10 rows.

        :param expand: If :data:`True`, some structures in the result will be
            recursively expanded (flattened out into multiple columns) like so
            (everything inside ``<...>`` is a placeholder):

            * :class:`.Node` objects under any variable ``<n>`` will be
              expanded into columns (the recursion stops here)

              * ``<n>().prop.<property_name>`` (any) for each property of the
                node.
              * ``<n>().element_id`` (str) the node's element id.
                See :attr:`.Node.element_id`.
              * ``<n>().labels`` (frozenset of str) the node's labels.
                See :attr:`.Node.labels`.

            * :class:`.Relationship` objects under any variable ``<r>``
              will be expanded into columns (the recursion stops here)

              * ``<r>->.prop.<property_name>`` (any) for each property of the
                relationship.
              * ``<r>->.element_id`` (str) the relationship's element id.
                See :attr:`.Relationship.element_id`.
              * ``<r>->.start.element_id`` (str) the relationship's
                start node's element id.
                See :attr:`.Relationship.start_node`.
              * ``<r>->.end.element_id`` (str) the relationship's
                end node's element id.
                See :attr:`.Relationship.end_node`.
              * ``<r>->.type`` (str) the relationship's type.
                See :attr:`.Relationship.type`.

            * :class:`list` objects under any variable ``<l>`` will be expanded
              into

              * ``<l>[].0`` (any) the 1st list element
              * ``<l>[].1`` (any) the 2nd list element
              * ...

            * :class:`dict` objects under any variable ``<d>`` will be expanded
              into

              * ``<d>{}.<key1>`` (any) the 1st key of the dict
              * ``<d>{}.<key2>`` (any) the 2nd key of the dict
              * ...

            * :class:`list` and :class:`dict` objects are expanded recursively.
              Example::

                variable x: [{""foo"": ""bar"", ""baz"": [42, 0]}, ""foobar""]

              will be expanded to::

                {
                    ""x[].0{}.foo"": ""bar"",
                    ""x[].0{}.baz[].0"": 42,
                    ""n[].0{}.baz[].1"": 0,
                    ""n[].1"": ""foobar""
                }

            * Everything else (including :class:`.Path` objects) will not
              be flattened.

            :class:`dict` keys and variable names that contain ``.``  or ``\``
            will be escaped with a backslash (``\.`` and ``\\`` respectively).
        :param parse_dates:
            If :data:`True`, columns that exclusively contain
            :class:`time.DateTime` objects, :class:`time.Date` objects, or
            :data:`None`, will be converted to :class:`pandas.Timestamp`.

        :raises ImportError: if `pandas` library is not available.
        :raises ResultConsumedError: if the transaction from which this result
            was obtained has been closed or the Result has been explicitly
            consumed.
        """"""
        import pandas as pd  # type: ignore[import]

        if not expand:
            df = pd.DataFrame(self.values(), columns=self._keys)
        else:
            df_keys = None
            rows = []
            for record in self:
                row = RecordTableRowExporter().transform(dict(record.items()))
                if df_keys == row.keys():
                    rows.append(row.values())
                elif df_keys is None:
                    df_keys = row.keys()
                    rows.append(row.values())
                elif df_keys is False:
                    rows.append(row)
                else:
                    # The rows have different keys. We need to pass a list
                    # of dicts to pandas
                    rows = [{k: v for k, v in zip(df_keys, r)} for r in rows]
                    df_keys = False
                    rows.append(row)
            if df_keys is False:
                df = pd.DataFrame(rows)
            else:
                columns = df_keys or [
                    k.replace(""."", ""\\."").replace(""\\"", ""\\\\"")
                    for k in self._keys
                ]
                df = pd.DataFrame(rows, columns=columns)
        if not parse_dates:
            return df
        dt_columns = df.columns[df.apply(
            lambda col: pd.api.types.infer_dtype(col) == ""mixed"" and col.map(
                lambda x: isinstance(x, (DateTime, Date, type(None)))
            ).all()
        )]
        df[dt_columns] = df[dt_columns].apply(
            lambda col: col.map(
                lambda x:
                pd.Timestamp(x.iso_format())
                .replace(tzinfo=getattr(x, ""tzinfo"", None))
                if x else pd.NaT
            )
        )
        return df",771,906
closed,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/result.py,"Return True if the result has been closed.

When a result gets consumed :meth:`consume` or the transaction that
owns the result gets closed (committed, rolled back, closed), the
result cannot be used to acquire further records.

In such case, all methods that need to access the Result's records,
will raise a :exc:`.ResultConsumedError` when called.

:returns: whether the result is closed.

.. versionadded:: 5.0","def closed(self) -> bool:
        """"""Return True if the result has been closed.

        When a result gets consumed :meth:`consume` or the transaction that
        owns the result gets closed (committed, rolled back, closed), the
        result cannot be used to acquire further records.

        In such case, all methods that need to access the Result's records,
        will raise a :exc:`.ResultConsumedError` when called.

        :returns: whether the result is closed.

        .. versionadded:: 5.0
        """"""
        return self._out_of_scope or self._consumed",908,922
closed,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/_sync/work/workspace.py,"Indicate whether the session has been closed.

:returns: :data:`True` if closed, :data:`False` otherwise.","def closed(self) -> bool:
        """"""Indicate whether the session has been closed.

        :returns: :data:`True` if closed, :data:`False` otherwise.
        """"""
        return self._closed",205,210
hydrate_point,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/spatial/__init__.py,"Create a new instance of a Point subclass from a raw
set of fields. The subclass chosen is determined by the
given SRID; a ValueError will be raised if no such
subclass can be found.","def hydrate_point(srid, *coordinates):
    """""" Create a new instance of a Point subclass from a raw
    set of fields. The subclass chosen is determined by the
    given SRID; a ValueError will be raised if no such
    subclass can be found.
    """"""
    return _hydration.hydrate_point(srid, *coordinates)",48,54
dehydrate_point,/Users/bytedance/test_repo/git/neo4j-python-driver/src/neo4j/spatial/__init__.py,"Dehydrator for Point data.

:param value:
:type value: Point
:returns:","def dehydrate_point(value):
    """""" Dehydrator for Point data.

    :param value:
    :type value: Point
    :returns:
    """"""
    return _hydration.dehydrate_point(value)",63,70
